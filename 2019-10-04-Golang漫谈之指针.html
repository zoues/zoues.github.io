<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="theme-color" content="#222">










<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"right","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的Golang 源码剖析。 Golang 1.13.1已在9月26日正式发布，主要修复CVE-2019-16276,当然docker等相关组件也同时做了update channel是Golang提供的goroutine间的通信方式，其为Golang并">
<meta name="keywords" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang漫谈之指针">
<meta property="og:url" content="https://ustack.io/2019-10-04-Golang漫谈之指针.html">
<meta property="og:site_name" content="Indagate">
<meta property="og:description" content="除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的Golang 源码剖析。 Golang 1.13.1已在9月26日正式发布，主要修复CVE-2019-16276,当然docker等相关组件也同时做了update channel是Golang提供的goroutine间的通信方式，其为Golang并">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/03/u0QEP1.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/03/u0lo7Q.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDMTbD.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/03/u08ctJ.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/03/u0YekF.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uB5B9g.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uBzUh9.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uBLZTA.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDSMUe.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDCHrq.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDiF6s.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDif3Q.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDkuQJ.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDAgN6.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDeSDH.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/04/uDm9QU.png">
<meta property="og:updated_time" content="2019-11-22T06:15:43.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang漫谈之指针">
<meta name="twitter:description" content="除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的Golang 源码剖析。 Golang 1.13.1已在9月26日正式发布，主要修复CVE-2019-16276,当然docker等相关组件也同时做了update channel是Golang提供的goroutine间的通信方式，其为Golang并">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg">



  <link rel="alternate" href="/atom.xml" title="Indagate" type="application/atom+xml">




  <link rel="canonical" href="https://ustack.io/2019-10-04-Golang漫谈之指针.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Golang漫谈之指针 | Indagate</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  
  <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdn.bootcss.com/jquery-migrate/1.4.1/jquery-migrate.min.js"></script>
  <link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">
  <link rel="stylesheet" id="stylesheet-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" id="gr_classic_style-css" href="/css/classic.css" type="text/css" media="all">
  <link rel="stylesheet" id="gr_options-css" href="/css/options.css" type="text/css" media="all">
  <link rel="stylesheet" id="gr_style-css" href="/css/style1.css" type="text/css" media="all">
  <link rel="stylesheet" id="contact-form-7-css" href="/css/styles.css" type="text/css" media="all">
  <link rel="stylesheet" id="cff-css" href="/css/cff-style.css" type="text/css" media="all">
  <link rel="stylesheet" id="cff-font-awesome-css" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/Valine.min.js"></script>
  
 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN" style="opacity: 1;" class="home blog">

  
  
    
  
<div class="preloader">
	<div class="gr_preload_logo">
    	<img src="/images/logo.png" alt="indagate">
    </div>
    <div class="gr_load_ring">
    	<h2>LOADING</h2>
    </div>
</div>
<div id="gr_box_search" class="gr_box_overlay">
    <div class="gr_close_over"></div>
    <div class="gr_box_holder">
        <h3 class="gr_box_title">Let's search</h3>
        <form role="search" method="get" action="/">
            <input type="search" name="s" value placeholder="..." class="gr_search_input">
            <button type="submit" value="Search" class="gr_search_submit">Search</button>
        </form>
        <button type="button" class="gr_close">Close</button>
    </div>
</div>
<div id="gr_box_social" class="gr_box_overlay">
    <div class="gr_close_over"></div>
    <div class="gr_box_holder">
        <h3 class="gr_box_title">Follow me</h3>
        <div class="gr_box_share_holder">
        <a href="http://github.com/zoues" target="_blank"><i class="fa fa-github"></i></a>                                                <a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a>        </div>
        <button type="button" class="gr_close">Close</button>
    </div>
</div>
  <div class="gr_site_holder">
    <header>
            <div class="gr_header_background">
                <div class="container">
                    <div class="row">
                        <div class="col-md-4 col-sm-4 col-xs-4">
                            <div class="gr-search">
                                <a href="#" title>search</a>
                            </div>
                        </div>
                        <div class="col-md-4 col-sm-4 col-xs-4">
                            <div class="gr-menu-top">
                                <div class="gr_menu_holder" style="margin-left: -60px; width:120px">
                                    <a href="#" title class="gr_menu_button">menu</a>
                                    <div class="menu-main-menu-container">
                                        <ul id="menu-main-menu" class="gr_header_menu center-block" style="display: none;">
                                            <li id="menu-item-344" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-344">
                                                <a href="/categories/" style="opacity: 1;">开发实践</a>
                                            </li>
                                            <li id="menu-item-344" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-344">
                                                <a href="/categories/" style="opacity: 1;">行业动态</a>
                                            </li>
                                            <li id="menu-item-344" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-344">
                                                <a href="/categories/" style="opacity: 1;">入门教程</a>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 col-sm-4 col-xs-4">
                            <div class="gr-social">
                                <a href="#" title class="gr_share_button">follow</a>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12">
                            <div class="gr-logo">
                                <a href="/">
                                    <img class="img-responsive" src="/images/logo.png" alt="Boroda">
                                </a>
                                <h2>My name is <span>Zouyee</span>. I’m a blogger based in SUZHOU.</h2>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
    </header>

    


    <main id="main" class="main row">
         
        <div class="main-inner">
         
            <div class="content-wrap">
                
                <div id="content" class="content gr_grid_container">
                

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="item post post-type-normal type-post status-publish format-gallery has-post-thumbnail hentry category-livestyle tag-face tag-redhead tag-young post_format-post-format-gallery" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="gr_post_holder">
    <link itemprop="mainEntityOfPage" href="https://ustack.io/2019-10-04-Golang漫谈之指针.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zouyee">
      <meta itemprop="description" content="Keep motivation for the world">
      <meta itemprop="image" content="/images/author.webp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Indagate">
    </span>

    
    <div class="head">
        <div class="gr_up_title">
          <span class="text-overflow-center">Golang漫谈之指针</span>
        </div>
        <div class="gr_blog_post_cat">
          <span class="gr_ddate">10月 04 2019</span><span class="gr_separate">|</span>
          
                <a href="/categories/golang漫谈/" itemprop="url" rel="category tag"><span itemprop="name">golang漫谈</span></a>

                
                
              
            
        </div>
        <div class="gr_blog_post_title_holder">
        
          
          <h3 class="blog_title" itemprop="name headline">Golang漫谈之指针
              
            
          </h3>
          
        </div>
        <div class="gr_blog_post_cat" style="text-align: center;">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：10月 04 2019 20:40:08" itemprop="dateCreated datePublished" datetime="2019-10-04T20:40:08+08:00">10月 04 2019</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：11月 22 2019 14:15:43" itemprop="dateModified" datetime="2019-11-22T14:15:43+08:00">11月 22 2019</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/golang漫谈/" itemprop="url" rel="index"><span itemprop="name">golang漫谈</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019-10-04-Golang漫谈之指针.html#comments" itemprop="discussionUrl" style="padding-left: 0px;">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019-10-04-Golang漫谈之指针.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019-10-04-Golang漫谈之指针.html" class="leancloud_visitors" data-flag-title="Golang漫谈之指针">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          

          

        </div>
    </div>   
    

    
    
    
    
    <div class="gr_media">
      <div class="gr_blog_post_featuder_holder text-center">
      
      </div>
    </div>
    
    <div class="post-body han-init-context" itemprop="articleBody" style="opacity: 1; display: block; transform: translateY(0px);">
    
      
        <p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p>
<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p>
<p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div>
<p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p>
<ul>
<li>channel介绍及范例</li>
<li>channel用法</li>
<li>channel使用场景</li>
<li>channel原理赏析</li>
</ul>
<p>下面在进入正题之前，简要介绍一下CSP模型：</p>
<blockquote>
<p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p>
</blockquote>
<a id="more"></a>
<hr>
<h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote>
<p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p>
</blockquote>
<ul>
<li><p>广播，如消费者/生产者模型</p>
</li>
<li><p>交换数据</p>
</li>
<li><p>并发控制</p>
</li>
<li><p>显示通知等</p>
</li>
</ul>
<p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p>
<h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p>
<p>2）先进先出：copying into and out of hchan buffer</p>
<p>3）channel的高性能所在：</p>
<ul>
<li>调用runtime scheduler实现，OS thread不需要阻塞；</li>
<li>跨goroutine栈可以直接进行读写；</li>
</ul>
<h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p>
<ul>
<li><p>无缓存channel</p>
<p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p>
</li>
<li><p>有缓存channel</p>
<p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p>
</li>
</ul>
<p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p>
<h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p>
<h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure>
<h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>关于channel的关闭，需要注意以下事项：</p>
<ul>
<li>关闭未初始化的channle(nil)会panic</li>
<li>重复关闭同一channel会panic</li>
<li>向以关闭channel发送消息会panic</li>
<li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li>
<li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure>
<h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select有以下特性：</p>
<ul>
<li>select可同时监听多个channel的读/写</li>
<li>执行select时，若只有一个case通过，则执行该case</li>
<li>若有多个，则随机执行一个case</li>
<li>若所有都不满足，则执行default，若无default，则等待</li>
<li>可使用break跳出select</li>
</ul>
<hr>
<h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>hchan类型</strong></strong></p>
<p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p>
<ul>
<li>elemetype代表类型，用于数据传递过程中的赋值</li>
<li>elemesize代码类型大小，用于在buf中定位元素位置</li>
</ul>
<p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p>
<p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p>
<ul>
<li>dataqsiz指示队列长度为6，即可缓存6个元素</li>
<li>buf指向队列的内存，队列中还剩余两个元素</li>
<li>qcount表示队列中还有两个元素</li>
<li>sendx指示后续写入的数据存储的位置，取值[0,6)</li>
<li>recvx指示从该位置读取数据，取值[0,6)</li>
</ul>
<p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p>
<p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p>
<ul>
<li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li>
<li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p>
<p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和其他一样，sudog也实现二级缓存复用结构。</p>
<p><code>runtime2.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p>
</blockquote>
<h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p>
<p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p>
<p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p>
<p>当执行recvq.dequeue()时，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p>
<h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p>
<ol>
<li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li>
<li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li>
<li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li>
</ol>
<p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p>
<blockquote>
<p>send 有以下几种情况：</p>
</blockquote>
<ul>
<li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li>
<li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li>
<li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向channel写入数据主要流程如下：<br><div class="note warning"><ul>
<li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li>
<li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li>
<li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li>
<li>CASE3：不能向已经关闭的channel send数据，会导致panic</li>
<li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol>
<li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li>
<li>释放channel的全局锁</li>
<li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li>
</ol>
</li>
<li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li>
<li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul>
<li>获取当前goroutine的sudog，然后入channel的send队列</li>
<li>将当前goroutine休眠</li>
</ul>
</li>
</ul></div></p>
<h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p>
<ol>
<li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li>
<li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li>
<li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li>
<li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li>
</ol>
<p>简单流程图如下所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>接收channel的数据的流程如下：</p>
<ul>
<li><p>CASE1：前置channel为nil的场景：</p>
<ul>
<li>如果block为非阻塞，直接return；</li>
<li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li>
</ul>
</li>
<li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p>
</li>
<li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li>
<li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li>
<li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p>
<ul>
<li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li>
<li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p>
<ol>
<li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li>
<li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li>
<li>释放channel的全局锁</li>
<li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li>
</ol>
</li>
</ul>
</li>
<li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p>
</li>
<li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li>
<li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li>
</ul></div>
<h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p>
<ol>
<li>关闭值为nil的channel</li>
<li>关闭已经被关闭的channel</li>
<li>向已经关闭的channel写数据</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭的主要流程如下所示：</p>
<div class="note warning"><ul>
<li>获取全局锁；</li>
<li>设置channel数据结构chan的关闭标志位；</li>
<li>获取当前channel上面的读goroutine并链接成链表；</li>
<li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li>
<li>释放全局锁；</li>
<li>唤醒所有的读写goroutine。</li>
</ul></div>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p>
<p>G1作用于底层<code>hchan</code>的流程如下：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p>
<ol>
<li>先获取全局锁</li>
<li>然后enqueue元素(通过移动拷贝的方式)</li>
<li>释放锁</li>
</ol>
<p>G2读取时作用于底层数据结构流程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p>
<ol>
<li>先获取全局锁</li>
<li>然后dequeue元素(通过移动拷贝的方式)</li>
<li>释放锁</li>
</ol>
<p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p>
<p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p>
<p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p>
<p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p>
<p>上图流程大致如下：</p>
<ol>
<li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li>
<li>将M和G1绑定关系断开</li>
<li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li>
</ol>
<p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p>
<p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p>
<p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p>
<p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p>
<p>整个过程如下所述：</p>
<ol>
<li>G2调用 t:=&lt;-ch 获取一个元素；</li>
<li>从channel的buffer里面取出一个元素task1；</li>
<li>从sender等待队列里面pop一个sudog；</li>
<li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li>
<li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li>
</ol>
<p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p>
<ol>
<li>首先G2会调用goready(G1)，唤起scheduler的调度；</li>
<li>将G1设置成Runable状态；</li>
<li>G1会加入到局部调度器P的local queue队列，等待运行。</li>
</ol>
<h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p>
<p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p>
<ol>
<li>将recvq中的task存入buffer</li>
<li>goready(G2) 唤醒G2</li>
</ol>
<p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p>
<hr>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p>
<hr>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li>
<li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li>
</ul>

      
    </div>

    
      


    

    
    
    

    
      <div class="qr_code_pc_inner">
        <div class="qr_code_pc">
    <img id="js_pc_qr_code_img" class="qr_code_pc_img" src="https://s2.ax1x.com/2019/09/22/upS79K.jpg" alt="zouyee wechat" style="width: 200px; max-width: 100%;">
    <p>微信扫一扫<br>关注该公众号</p>
</div>
<script>
jQuery.noConflict()(function ($) {
    $(function () {
		var offsetTop = $('#comments').offset().top - $(window).height();
		
		if (offsetTop <= 0) {
			// load directly when there's no a scrollbar
			console.log("....")
		} else {
			$(window).on('scroll', function () {
				var scrollTop = document.documentElement.scrollTop;
				var copyright = $('.post-copyright').offset().top;
				
				var imageH = $('.qr_code_pc').offset().top;
				console.log("scrollTop", scrollTop)
				console.log("copyright", copyright)
				console.log("qr_code_pc", imageH)
				if (scrollTop <= offsetTop) {
					$('.qr_code_pc').css('position', 'absolute')
					$('.qr_code_pc').css('top', 420)
				}
				if (scrollTop > 450 && copyright > scrollTop) {
					$('.qr_code_pc').css('top', 20)
					$('.qr_code_pc').css('position', 'fixed')
				} else {
					$('.qr_code_pc').css('position', 'absolute')
				}
			});
		}
	});

})
</script>

      </div>
      
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span style="padding-top: 5px;">打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://s2.ax1x.com/2019/09/22/uppS4P.jpg" alt="zouyee 微信支付">
        
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>zouyee</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ustack.io/2019-10-04-Golang漫谈之指针.html" title="Golang漫谈之指针">https://ustack.io/2019-10-04-Golang漫谈之指针.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer" stype="color:#5d3434">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag"># golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019-10-04-Golang漫谈之切片.html" rel="next" title="Golang漫谈之切片">
                <i class="fa fa-chevron-left"></i> Golang漫谈之切片
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019-10-04-Golang漫谈之channel妙法.html" rel="prev" title="Golang漫谈之channel妙法">
                Golang漫谈之channel妙法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


                </div>
                

  
    <div class="comments" id="comments">
    </div>
  



            </div>
                
                
  

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author.webp" alt="zouyee">
            
              <p class="site-author-name" itemprop="name">zouyee</p>
              <p class="site-description motion-element" itemprop="description">Keep motivation for the world</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/zouyee" target="_blank" title="Twitter" rel="external nofollow"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.instagram.com/ustackq/" target="_blank" title="Instagram" rel="external nofollow"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zouyee" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.zoues.com/" title="Zoues" target="_blank">Zoues</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、channel介绍及范例"><span class="nav-number">1.</span> <span class="nav-text">一、channel介绍及范例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-channel特性"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 channel特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-channel类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 channel类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-channel创建"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 channel创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-channel的读写操作"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 channel的读写操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-channel的关闭"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 channel的关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-两类channel"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 两类channel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、channel的用法"><span class="nav-number">2.</span> <span class="nav-text">二、channel的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-goroutine通信"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 goroutine通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-range遍历"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 range遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-配合select使用"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 配合select使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、channel使用场景"><span class="nav-number">3.</span> <span class="nav-text">三、channel使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-设置超时时间"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 设置超时时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-控制channel"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 控制channel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、channel原理赏析"><span class="nav-number">4.</span> <span class="nav-text">四、channel原理赏析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-channel结构体"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 channel结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-channel-make实现"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 channel make实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#channel发送"><span class="nav-number">4.3.</span> <span class="nav-text">channel发送</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#channel接受"><span class="nav-number">4.4.</span> <span class="nav-text">channel接受</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#channel关闭"><span class="nav-number">4.5.</span> <span class="nav-text">channel关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">4.6.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#读取空channel"><span class="nav-number">4.6.1.</span> <span class="nav-text">读取空channel</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后续"><span class="nav-number">5.</span> <span class="nav-text">后续</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


                
        </div>
        
        
    </main>


    <div class="gr_footer_widget">
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <div class="col-md-4 col-sm-12 col-xs-12">
                        <div class="gr_widget">
                            <h6 class="gr_widget_title"><span>Serveless Repo</span></h6>

                            <div class="gr_tweet TableObject org-header-wrapper mb-4">
                                <img id="github" itemprop="image" class="TableObject-item avatar" src="https://s2.ax1x.com/2019/09/22/uSzDzD.jpg" width="50" height="50" alt="@virtual-kubelet">
                                <div class="TableObject-item TableObject-item--primary">
                                    <p class="org-description" itemprop="description"></p><div>OCI-based implementation CRI</div><p></p>
                                    <ul class="org-header-meta has-location has-blog has-email">
                                        <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
                                            <a rel="nofollow" itemprop="url" class="text-gray" title="https://cri-o.io" href="https://cri-o.io">https://cri-o.io</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>

                            <div class="gr_tweet TableObject org-header-wrapper mb-4">
                                <img id="github" itemprop="image" class="TableObject-item avatar" src="https://s2.ax1x.com/2019/09/22/uSzISS.jpg" width="50" height="50" alt="@openfaas">
                                <div class="TableObject-item TableObject-item--primary">
                                    <p class="org-description" itemprop="description"></p><div>Serverless Functions Made Simple</div><p></p>
                                    <ul class="org-header-meta has-location has-blog has-email">
                                        <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
                                            <a rel="nofollow" itemprop="url" class="text-gray" title="https://www.openfaas.com" href="https://www.openfaas.com">https://www.openfaas.com</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>


                            <div class="gr_tweet TableObject org-header-wrapper mb-4">
                                <img id="github" itemprop="image" class="TableObject-item avatar" src="https://s2.ax1x.com/2019/09/22/uSzbes.jpg" width="50" height="50" alt="@virtual-kubelet">
                                <div class="TableObject-item TableObject-item--primary">
                                    <p class="org-description" itemprop="description"></p><div>Building serverless within Kubernetes</div><p></p>
                                    <ul class="org-header-meta has-location has-blog has-email">
                                        <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
                                            <a rel="nofollow" itemprop="url" class="text-gray" title="https://virtual-kubelet.io" href="https://virtual-kubelet.io">https://virtual-kubelet.io</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>


                            <div class="gr_tweet TableObject org-header-wrapper mb-4">
                                <img id="github" itemprop="image" class="TableObject-item avatar" src="https://s2.ax1x.com/2019/09/22/uSzjYV.jpg" width="50" height="50" alt="@virtual-kubelet">
                                <div class="TableObject-item TableObject-item--primary">
                                    <p class="org-description" itemprop="description"></p><div>Manage modern serverless workloads</div><p></p>
                                    <ul class="org-header-meta has-location has-blog has-email">
                                        <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
                                            <a rel="nofollow" itemprop="url" class="text-gray" title="https://knative.dev" href="https://knative.dev">https://knative.dev</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4 col-sm-12 col-xs-12">
                        <div class="gr_widget" style="line-height: 18px;">
                            <h6 class="gr_widget_title"><span>Calendar</span></h6>
                            <div id="calendar_wrap" class="calendar_wrap">
                                <table id="wp-calendar">
                                    <caption>July 2019</caption>
                                    <thead>
                                        <tr>
                                            <th scope="col" title="Monday">M</th>
                                            <th scope="col" title="Tuesday">T</th>
                                            <th scope="col" title="Wednesday">W</th>
                                            <th scope="col" title="Thursday">T</th>
                                            <th scope="col" title="Friday">F</th>
                                            <th scope="col" title="Saturday">S</th>
                                            <th scope="col" title="Sunday">S</th>
                                        </tr>
                                    </thead>

                                    <tfoot>
                                        <tr>
                                            <td colspan="3" id="prev"><a href="./wp/boroda/2015/05/">« May</a></td>
                                            <td class="pad">&nbsp;</td>
                                            <td colspan="3" id="next" class="pad">&nbsp;</td>
                                        </tr>
                                    </tfoot>

                                    <tbody>
                                        <tr>
                                            <td colspan="5" class="pad">&nbsp;</td>
                                            <td>1</td>
                                            <td>2</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>4</td>
                                            <td>5</td>
                                            <td>6</td>
                                            <td>7</td>
                                            <td>8</td>
                                            <td>9</td>
                                        </tr>
                                        <tr>
                                            <td>10</td>
                                            <td>11</td>
                                            <td>12</td>
                                            <td>13</td>
                                            <td>14</td>
                                            <td>15</td>
                                            <td>16</td>
                                        </tr>
                                        <tr>
                                            <td>17</td>
                                            <td>18</td>
                                            <td id="today">19</td>
                                            <td>20</td>
                                            <td>21</td>
                                            <td>22</td>
                                            <td>23</td>
                                        </tr>
                                        <tr>
                                            <td>24</td>
                                            <td>25</td>
                                            <td>26</td>
                                            <td>27</td>
                                            <td>28</td>
                                            <td>29</td>
                                            <td>30</td>
                                        </tr>
                                        <tr>
                                            <td>31</td>
                                            <td class="pad" colspan="6">&nbsp;</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4 col-sm-12 col-xs-12">
                        <div class="gr_widget">
                            <h6 class="gr_widget_title"><span>Dou Feed</span></h6>
                            

                            <div class="gr_tweet TableObject org-header-wrapper mb-4">
                                <img id="github" itemprop="image" class="TableObject-item douban" src="https://s2.ax1x.com/2019/09/22/upSEY6.jpg" width="50" height="50" alt="@virtual-kubelet">
                                <div class="TableObject-item TableObject-item--primary">
                                    <ul class="org-header-meta has-location has-blog has-email">
                                        <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
                                            <a rel="nofollow" itemprop="url" class="text-gray" title="少年赫比" href="https://book.douban.com/subject/33408001/?icn=index-latestbook-subject">书名: 少年赫比</a>
                                        </li>
                                         <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <a rel="nofollow" itemprop="url" class="text-gray">出版年: 2019-5</a>
                                        </li>
                                         <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <a rel="nofollow" itemprop="url" class="text-gray">原作名: CITY BOY</a>
                                        </li>
                                         <li class="meta-item v-align-middle" style="padding: 0px 0px;">
                                            <a rel="nofollow" itemprop="url" class="text-gray">定价: 58.00元</a>
                                        </li>
                                    </ul>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zouyee</span>

  

  
</div>


  







  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery.form/3.51/jquery.form.min.js"></script>
  </div>
    <script type="text/javascript" src="/js/custom.js"></script>
    <script type="text/javascript" src="/js/menu.js"></script>
  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























     <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="/js/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'jTOUB0OQ83CnjWySYgN5W1PV-gzGzoHsz',
        appKey: '8upIEt85LzIaq3NWQbUbfWI8',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Qg4Aol4dtKwpnLstsoOct5Ya-gzGzoHsz", "pRvygLtQ4atIrsbLXpXi9HXa");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text(counter.get('time'));
            
            counter.save(null, {
              success: function(counter) {
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  
  <script type="text/javascript" src="https://cdn.bootcss.com/js-cookie/2.1.4/js.cookie.js"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.3.0"></script>


  

  

  

</body>
</html>
