<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Indagate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ustack.io/"/>
  <updated>2019-11-26T02:10:41.297Z</updated>
  <id>https://ustack.io/</id>
  
  <author>
    <name>zouyee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes调度系统初探</title>
    <link href="https://ustack.io/2019-11-26-Kubernetes%20%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2.html"/>
    <id>https://ustack.io/2019-11-26-Kubernetes 调度系统初探.html</id>
    <published>2019-11-26T04:40:08.000Z</published>
    <updated>2019-11-26T02:10:41.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg" alt></p><div class="note default"><p>Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。</p><p>本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：</p><ul><li>Kubernetes version: <code>v1.10</code></li><li>System: <code>CentOS Linux 7</code></li><li>Kernel: <code>Linux 3.10.0</code></li></ul></div><p>Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。</p><a id="more"></a><hr><blockquote><p>在后续安装部署中，将不使用kube-apiserver的HTTP非安全端口，所有组件都启用TLS双向认证通信。因此TLS证书配置是在安装配置Kubernetes系统中最容易出错和难于排查问题的一步，所以请务必耐心仔细。</p></blockquote><p>在开始前，为了模拟集群节点，我们假定需要在以下三台Linux主机上部署Kubernetes:</p><ul><li><code>10.138.148.161</code>：作为<code>master</code>节点</li><li><code>10.138.196.180</code>：作为<code>Node</code>节点</li><li><code>10.138.212.68</code>：作为<code>Node</code>节点</li></ul><div class="note danger"><p>同一台主机上可以同时部署master和Node节点相关组件，即同时作为控制节点和工作节点，不过这么做可能导致master节点负载过高而失去响应进而导致整个集群出现无法预知的问题。</p></div><hr><h3 id="安装CFSSL证书生成工具"><a href="#安装CFSSL证书生成工具" class="headerlink" title="安装CFSSL证书生成工具"></a>安装<code>CFSSL</code>证书生成工具</h3><div class="note info"><p>我们将使用<code>Cloudflare</code>的PKI工具集<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">cloudflare/cfssl</a>来生成集群所需要的各种<code>TLS</code>证书。</p></div><p>执行以下命令直接下载二进制文件进行安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O cfssl </span><br><span class="line">chmod +x cfssl </span><br><span class="line">sudo mv cfssl /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O cfssljson </span><br><span class="line">chmod +x cfssljson </span><br><span class="line">sudo mv cfssljson /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O cfssl-certinfo </span><br><span class="line">chmod +x cfssl-certinfo </span><br><span class="line">sudo mv cfssl-certinfo /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h3 id="创建CA根证书（Certificate-Authority）"><a href="#创建CA根证书（Certificate-Authority）" class="headerlink" title="创建CA根证书（Certificate Authority）"></a>创建CA根证书（Certificate Authority）</h3><p>CA（Certificate Authority）是自签名的根证书，用来签名后续创建的其它 TLS 证书；<br>确认<code>CFSSL</code>工具安装成功之后，我们先通过<code>CFSSL</code>工具来创建模版配置json文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfssl <span class="built_in">print</span>-defaults config &gt; config.json</span><br><span class="line">cfssl <span class="built_in">print</span>-defaults csr &gt; csr.json</span><br></pre></td></tr></table></figure><h4 id="创建CA配置文件"><a href="#创建CA配置文件" class="headerlink" title="创建CA配置文件"></a>创建CA配置文件</h4><p>这将生成两个模版json文件，后续<code>CFSSL</code>将读取json文件内容并生成对应的<code>pem</code>文件。我们先复制<code>config.json</code>为<code>ca-config.json</code>文件并做如下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"signing"</span>: &#123;</span><br><span class="line">        <span class="attr">"default"</span>: &#123;</span><br><span class="line">            <span class="attr">"expiry"</span>: <span class="string">"99999h"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">            <span class="attr">"kubernetes"</span>: &#123;</span><br><span class="line">                <span class="attr">"expiry"</span>: <span class="string">"99999h"</span>,</span><br><span class="line">                <span class="attr">"usages"</span>: [</span><br><span class="line">                    <span class="string">"signing"</span>,</span><br><span class="line">                    <span class="string">"key encipherment"</span>,</span><br><span class="line">                    <span class="string">"server auth"</span>,</span><br><span class="line">                    <span class="string">"client auth"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>profiles</code>：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个特定的profile。</p><p><code>signing</code>：表示该证书可用于签名(签发)其它证书，生成的 ca.pem 证书中 CA=TRUE。</p><p><code>server auth</code>：表示`client可以用该 CA（生成的ca.pem） 对server提供的证书进行验证。</p><p><code>client auth</code>：表示server可以用该CA(生成的ca.pem）对client提供的证书进行验证。</p></div><h4 id="创建CA证书签名请求"><a href="#创建CA证书签名请求" class="headerlink" title="创建CA证书签名请求"></a>创建CA证书签名请求</h4><p>我们复制<code>csr.json</code>为<code>ca-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code>(<code>Common Name</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户名；</p><p><code>O</code>(<code>Organtzation</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户所属的用户组；</p></div><h4 id="生成CA证书和私钥"><a href="#生成CA证书和私钥" class="headerlink" title="生成CA证书和私钥"></a>生成CA证书和私钥</h4><p>执行以下命令来生成CA证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls ca*</span><br><span class="line">ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>这样，我们就生成了CA证书和私钥了，因为我们需要双向<code>TLS</code>认证，所以需要拷贝<code>ca-key.pem</code>和<code>ca.pem</code>到所有要部署的机器的<code>/etc/kubernetes/ssl</code>目录下备用。</p><h3 id="创建kubernetes组件认证授权证书"><a href="#创建kubernetes组件认证授权证书" class="headerlink" title="创建kubernetes组件认证授权证书"></a>创建kubernetes组件认证授权证书</h3><p>因为我们准备部署的kubernetes组件是使用<code>TLS</code>双向认证的，包括<code>kube-apiserver</code>不打算使用HTTP端口，因此，我们需要生成以下的证书以供后续组件部署的时候备用：</p><div class="note info"><ul><li><code>etcd</code>证书：etcd集群之间通信加密使用的<code>TLS</code>证书。</li><li><code>kube-apiserver</code>证书：配置<code>kube-apiserver</code>组件的证书。</li><li><code>kube-controller-manager</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kube-scheduler</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kubelet</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li><li><code>kube-proxy</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li></ul></div><p>下面我们将逐个创建对应的<code>TLS</code>证书，并做相应的简短说明：</p><h4 id="创建etcd证书："><a href="#创建etcd证书：" class="headerlink" title="创建etcd证书："></a>创建<code>etcd</code>证书：</h4><p>首选我们创建<code>etcd</code>证书签名请求(CSR)，拷贝<code>csr.json</code>为<code>etcd-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"etcd"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">        <span class="string">"master"</span>,</span><br><span class="line">        <span class="string">"node1"</span>,</span><br><span class="line">        <span class="string">"node2"</span></span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger"><p>此处需要指定<code>host</code>字段的值，该值为所有需要部署etcd节点的<code>ip 域名 或者 hostname</code>，etcd需要使用<code>Subject Alternative Name（SAN）</code>来校验集群以及防止滥用。如果你不清楚应该使用哪个ip，默认情况下使用<code>ip a</code>查看<code>eth0</code>即可。此处指定的<code>ip</code>与后续指定的<code>etcd的systemd</code>配置<code>initial-cluster</code>相关。</p><p>相关阅读: <a href="https://github.com/coreos/etcd/issues/2056" target="_blank" rel="noopener">Option to accept TLS client certificates even if they lack correct Subject Alternative Names</a></p></div><p>生成<code>etcd</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line">ls etcd*</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem etcd.pem</span><br></pre></td></tr></table></figure><p>将生成的<code>etch-key.pem</code>和<code>etcd.pem</code>拷贝到所有需要部署<code>etcd</code>集群的服务器<code>/etc/etcd/ssl</code>目录下备用。</p><h4 id="创建kube-apiserver证书"><a href="#创建kube-apiserver证书" class="headerlink" title="创建kube-apiserver证书"></a>创建<code>kube-apiserver</code>证书</h4><p>创建<code>kube-apiserver</code>证书签名请求配置文件，拷贝<code>csr.json</code>为<code>kubernetes-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">      <span class="string">"10.254.0.1"</span>,</span><br><span class="line">      <span class="string">"kubernetes"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster.local"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"key"</span>: &#123;</span><br><span class="line">        <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>此处指定了<code>host</code>字段来表示授权使用该证书的<code>ip或域名</code>列表，因此上述配置文件指定了要部署的kubernetes三台服务器ip（实际上只需要指定打算部署master节点的ip即可）以及<code>kube-apiserver</code>注册的名为<code>kubernetes</code>服务的服务ip（一般默认为后续配置<code>kube-apiserve</code>组件的时候指定的<code>—service-cluster-ip-range</code>网段的第一个ip。）如果你不清楚怎么操作，可以留空<code>host</code>字段。</p><p>如果你指定了<code>host</code>字段，这里如果有 <code>VIP</code> 的，也是需要填写的。</p></div><p>生成<code>kube-apiserver</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare apiserver</span><br><span class="line">ls apiserver*</span><br><span class="line">apiserver.csr  apiserver-key.pem  apiserver.pem</span><br></pre></td></tr></table></figure><p>我们将该证书拷贝到需要部署到<code>master</code>节点上的<code>/etc/kubernetes/ssl</code>上备用。</p><div class="note info"><p>因为我们master节点的组件之间的通信使用<code>非HTTP</code>的安全端口，所以同样也需要<code>TLS</code>认证授权，因此我们也需要配置<code>kube-controller-manager</code>和<code>kube-scheduler</code>的证书来供这两个组件访问<code>kube-apiserver</code>.如果你的集群master节点组件使用HTTP非安全端口通信，那么可以不需要配置这两个证书。</p></div><h4 id="创建kube-controller-manager证书"><a href="#创建kube-controller-manager证书" class="headerlink" title="创建kube-controller-manager证书"></a>创建<code>kube-controller-manager</code>证书</h4><p>复制<code>car.json</code>为<code>kube-controller-manager-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-controller-manager"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的配置中，<code>kube-apiserver</code>将提取<code>CN</code>作为客户端组件(kube-controller-manager)的用户名(system:kube-controller-manager)，<code>kube-apiserver</code>预定义的RBAC使用ClusterRoleBinding <code>system:kube-controller-manager</code>将<code>用户system:kube-controller-manager</code>与<code>ClusterRole system:kube-controller-manager</code>绑定。</p><p>生成<code>kube-controller-manager</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare controller-manager</span><br><span class="line">ls controller-manager*</span><br><span class="line">controller-manager.csr  controller-manager-key.pem  controller-manager.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-controller-manager</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><h4 id="创建kube-scheduler-证书"><a href="#创建kube-scheduler-证书" class="headerlink" title="创建kube-scheduler`证书"></a>创建kube-scheduler`证书</h4><p>与<code>kube-controller-manager</code>一样，<code>kube-scheduler</code>同样也需要<code>TLS</code>证书来访问<code>kube-apiserver</code>。此处不再赘述。直接上<code>kube-scheduler-csr.json</code>文件内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-scheduler"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code></code>kube-scheduler <code>将提取</code>CN作为客户端的用户名<code>,这里是</code>system:kube-scheduler<code>。 kube-apiserver 预定义的 RBAC 使用的 ClusterRoleBindings</code>system:kube-scheduler <code>将</code>用户system:kube-scheduler <code>与</code>ClusterRole system:kube-scheduler `绑定。</p><p>生成<code>kube-scheduler</code>证书以及私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare scheduler</span><br><span class="line">ls scheduler*</span><br><span class="line">scheduler.csr  scheduler-key.pem  scheduler.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-scheduler</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><p>至此，<code>master</code>节点上的证书生成就全部完成了，接下来是生成<code>worker</code>节点的证书，需要注意的是：生成<code>worker</code>证书是可选的，如果你使用<code>TLS Bootstarpping</code>那么你可以跳过以下步骤<code>worker</code>证书生成工作。直接转到部署的实际操作环节。关于<code>TLS</code>证书和<code>TLS Bootstarpping</code>认证方式的区别，后续考虑单独写一遍文章展开来讲。</p><hr><h4 id="创建kubelet证书"><a href="#创建kubelet证书" class="headerlink" title="创建kubelet证书"></a>创建<code>kubelet</code>证书</h4><p>拷贝<code>car.json</code>为<code>kubelet-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:node:node"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"system:nodes"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>O</code>为用户组，kubernetes RBAC定义了ClusterRoleBinding将Group system:nodes和CLusterRole system:node关联起来。</p><p>注意:在<code>kubernetes v1.8+</code>以上版本，将不会自动创建<code>binding</code>,因此我们后续需要手动创建绑定关系。</p></div><p>生成<code>kubelet</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubelet-csr.json | cfssljson -bare kubelet</span><br><span class="line">ls kubelet*</span><br><span class="line">kubelet.csr  kubelet-csr.json  kubelet-key.pem  kubelet.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和秘钥拷贝到所有需要部署的worker节点上的<code>/etc/kubernetes/ssl</code>下备用。</p><h4 id="创建kube-proxy证书"><a href="#创建kube-proxy证书" class="headerlink" title="创建kube-proxy证书"></a>创建<code>kube-proxy</code>证书</h4><p>拷贝<code>car.json</code>为<code>kube-proxy-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-proxy"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code> 指定该证书的 User为 system:kube-proxy。Kubernetes RBAC定义了ClusterRoleBinding将<code>system:kube-proxy用户</code>与<code>system:node-proxier 角色</code>绑定。system:node-proxier具有kube-proxy组件访问ApiServer的相关权限。</p></div><p>生成<code>kube-proxy</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">ls kube-proxy*</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和私钥拷贝到所有需要部署<code>worker</code>节点的<code>/etc/kubernetes/ssl</code>下备用。</p><p>在完成证书分发之后，这样我们的证书相关的生成工作就完成了。接下来开始配置各个组件。</p><p>参考资料：</p><ul><li><a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">Using RBAC Authorization</a></li><li><a href="https://wiki.shileizcc.com/display/KUB/Kubernetes+HA+Cluster+Build" target="_blank" rel="noopener">Kubernetes HA Cluster Build</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-centos.html" target="_blank" rel="noopener">在CentOS上部署kubernetes集群</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。&lt;/p&gt;
&lt;p&gt;本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes version: &lt;code&gt;v1.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System: &lt;code&gt;CentOS Linux 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kernel: &lt;code&gt;Linux 3.10.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes GO" scheme="https://ustack.io/categories/Kubernetes-GO/"/>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之cond</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bcond.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之cond.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:53:55.777Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Cond在client-go等库中广泛使用，该文对此做知识铺垫。<br>Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Cond在client-go等库中广泛使用，该文对此做知识铺垫。&lt;br&gt;Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之信号处理</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之信号处理.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:57:02.570Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之heap</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bheap.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之heap.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:36:51.986Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.</p><p>[</p></div><p>heap是Golang内置的标准库封装，该文章主要介绍，以下内容:</p><ul><li>heap介绍及范例</li><li>heap解析</li></ul><a id="more"></a><hr><h4 id="一、heap介绍及范例"><a href="#一、heap介绍及范例" class="headerlink" title="一、heap介绍及范例"></a>一、heap介绍及范例</h4><blockquote><p>堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p></blockquote><p>堆的常用方法：</p><ul><li><p>构建优先队列</p></li><li><p>支持堆排序</p></li><li><p>快速找出一个集合中的最小值（或者最大值）</p></li></ul><h5 id="1-1-堆属性"><a href="#1-1-堆属性" class="headerlink" title="1.1 堆属性"></a>1.1 堆属性</h5><p>堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。</p><p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHIrTS.png" alt="heap1"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。10比7和2都大。7比5和1都大。</p><p>根据这一属性，那么最大堆总是将其中的最大值存放在树的根节点。而对于最小堆，根节点中的元素总是树中的最小值。堆属性非常的有用，因为堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素。</p><blockquote><p>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p></blockquote><h5 id="1-2-堆和普通树的区别"><a href="#1-2-堆和普通树的区别" class="headerlink" title="1.2 堆和普通树的区别"></a>1.2 堆和普通树的区别</h5><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p><ul><li><p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p></li><li><p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。</p></li><li><p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p></li><li><p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p></li></ul><p><strong><em>来自数组的树</em></strong></p><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间山都是很高效的。我们准备将上面的例子中的树这样存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 7, 2, 5, 1 ]</span><br></pre></td></tr></table></figure><p>就这多！我们除了一个简单的数组以外，不需要任何额外的空间。</p><p>如果我们不允许使用指针，那么我们怎么知道哪一个节点是父节点，哪一个节点是它的子节点呢？问得好！节点在数组中的位置index 和它的父节点已经子节点的索引之间有一个映射关系。</p><p>如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent(i) = floor((i - 1)/2)</span><br><span class="line">left(i)   = 2i + 1</span><br><span class="line">right(i)  = 2i + 2</span><br></pre></td></tr></table></figure><p>注意 right(i) 就是简单的 left(i) + 1。左右节点总是处于相邻的位置。</p><p>我们将写公式放到前面的例子中验证一下。</p><table><thead><tr><th>Node</th><th>Array index (i)</th><th>Parent index</th><th>Left child</th><th>Right child</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>-1</td><td>1</td><td>2</td></tr><tr><td>7</td><td>1</td><td>0</td><td>3</td><td>4</td></tr><tr><td>2</td><td>2</td><td>0</td><td>5</td><td>6</td></tr><tr><td>5</td><td>3</td><td>1</td><td>7</td><td>8</td></tr><tr><td>1</td><td>4</td><td>1</td><td>9</td><td>10</td></tr></tbody></table><blockquote><p>根节点(10)没有父节点，因为 -1 不是一个有效的数组索引。同样，节点 (2)，(5)和(1) 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。</p></blockquote><p>在最大堆中，父节点的值总是要大于（或者等于）其子节点的值。这意味下面的公式对数组中任意一个索引i都成立：<code>array[parent(i)] &gt;= array[i]</code></p><p>可以用上面的例子来验证一下这个堆属性。</p><p>如你所见，这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要O(1)的时间。</p><p>理解数组索引和节点位置之间的关系非常重要。这里有一个更大的堆，它有15个节点被分成了4层:</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoCfH.png" alt="树"></p><p>图片中的数字不是节点的值，而是存储这个节点的数组索引！这里是数组索引和树的层级之间的关系：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoUNF.png" alt="数组"></p><p>由上图可以看到，数组中父节点总是在子节点的前面。注意这个方案与一些限制。你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoh3d.png" alt="一般树"></p><p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHovgs.png" alt="heapshap"></p><blockquote><p>注意：你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</p></blockquote><p>假设我们有这样一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 14, 25, 33, 81, 82, 99 ]</span><br></pre></td></tr></table></figure><p>这是一个有效的堆吗？答案是 yes ！一个从低到高有序排列的数组是以有效的最小堆，我们可以将这个堆画出来：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTMVK.png" alt="sortedArray"></p><p>堆属性适用于每一个节点，因为父节点总是比它的字节点小。（你也可以验证一下：一个从高到低有序排列的数组是一个有效的最大堆）</p><blockquote><p>注意：并不是每一个最小堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</p></blockquote><h5 id="1-3-堆的用途"><a href="#1-3-堆的用途" class="headerlink" title="1.3 堆的用途"></a>1.3 堆的用途</h5><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p><ul><li>shiftUp(): 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。</li><li>shiftDown(): 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。</li></ul><p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 O(log n)。</p><p>基于这两个原始操作还有一些其他的操作：</p><ul><li>insert(value): 在堆的尾部添加一个新的元素，然后使用 shiftUp 来修复对。</li><li>remove(): 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 shiftDown 方法来修复堆。</li><li>removeAtIndex(index): 和 remove() 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。当它与子节点比较位置不时无序时使用 shiftDown()，如果与父节点比较发现无序则使用 shiftUp()。</li><li><p>replace(index, value)：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 shiftUp() 来修复堆属性。<br>上面所有的操作的时间复杂度都是 O(log n)，因为 shiftUp 和 shiftDown 都很费时。还有少数一些操作需要更多的时间：</p></li><li><p>search(value):堆不是为快速搜索而建立的，但是 replace() 和 removeAtIndex() 操作需要找到节点在数组中的index，所以你需要先找到这个index。时间复杂度：O(n)。</p></li><li>buildHeap(array):通过反复调用 insert() 方法将一个（无序）数组转换成一个堆。如果你足够聪明，你可以在 O(n) 时间内完成。</li><li>堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度：O(n lg n)。</li></ul><p>堆还有一个 peek() 方法，不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。时间复杂度 O(1) 。</p><blockquote><p>注意：到目前为止，堆的常用操作还是使用 insert() 插入一个新的元素，和通过 remove()移除最大或者最小值。两者的时间复杂度都是O(log n)。其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p></blockquote><p><strong><em>插入</em></strong></p><p>我们通过一个插入例子来看看插入操作的细节。我们将数字16插入到这个堆中：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTgrq.png" alt="heap1"></p><p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。<br>第一股是将新的元素插入到数组的尾部。数组变成：<br><code>[ 10, 7, 2, 5, 1, 16 ]</code><br>相应的树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTHMR.png" alt="Insert1"></p><p>16 被添加最后一行的第一个空位。<br>不行的是，现在堆属性不满足，因为2在16的上面，我们需要将大的数字在上面（这是一个最大堆）<br>为了恢复堆属性，我们需要交换16和2。</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7SRH.png" alt="Insert2"></p><p>现在还没有完成，因为 10 也比 16 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 shift-up，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。<br>最后我们得到的堆：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH73wV.png" alt="Insert3"></p><p>现在每一个父节点都比它的子节点大。</p><p><strong><em>删除根节点</em></strong></p><p>我们将这个树中的 (10) 删除：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7Tk8.png" alt="Heap1"></p><p>现在顶部有一个空的节点，怎么处理？</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHsun.png" alt="Remove1"></p><p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHqUK.png" alt="Remove2"></p><p>现在来看怎么 shift-down (1)。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 7 和 2。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 7 和 1，现在树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbiUf.png" alt="Remove3"></p><p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbmKs.png" alt="Remove4"></p><p><strong><em>删除任一节点</em></strong></p><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。</p><p>但是，删除任意节点也很有用。这是 remove() 的通用版本，它可能会使用到 shiftDown 和 shiftUp。</p><p>我们还是用前面的例子，删除 (7):</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbG24.png" alt="Heap1"></p><p>对应的数组是:<code>[ 10, 7, 2, 5, 1 ]</code></p><p>你知道，移除一个元素会破坏最大堆或者最小堆属性。我们需要将删除的元素和最后一个元素交换：<br><code>[ 10, 1, 2, 5, 7 ]</code></p><p>最后一个元素就是我们需要返回的元素；然后调用 removeLast() 来将它删除。 (1) 比它的子节点小，所以需要 shiftDown() 来修复。</p><p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 (5) 会发生什么：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbyxH.png" alt="Remove5"></p><p>现在 (5) 和 (8) 交换了。因为 (8) 比它的父节点大，我们需要 shiftUp()。</p><hr><h4 id="二、heap解析"><a href="#二、heap解析" class="headerlink" title="二、heap解析"></a>二、heap解析</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>heap包对任意实现了heap接口的类型提供堆操作。（小根）堆是具有“每个节点都是以其为根的子树中最小值”属性的树。树的最小元素在根部，为index 0.<br>heap是常用的实现优先队列的方法。要创建一个优先队列，实现一个具有使用（负的）优先级作为比较的依据的Less方法的Heap接口，如此一来可用Push添加项目而用Pop取出队列最高优先级的项目。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：</p><ul><li>Len() int</li><li>Less(i, j int) bool  </li><li>Swap(i, j int)</li></ul><p>再加上堆接口定义的两个方法：</p><ul><li>Push(x interface{})</li><li>Pop() interface{}。</li></ul><p>故只要实现了这五个方法，变定义了一个堆。</p><p>任何实现了本接口的类型都可以用于构建最小堆。最小堆可以通过heap.Init建立，数据是递增顺序或者空的话也是最小堆。最小堆的约束条件是：</p><p><code>!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()</code></p><p>注意接口的Push和Pop方法是供heap包调用的，请使用heap.Push和heap.Pop来向一个堆添加或者删除元素。</p><ul><li>func Fix(h Interface, i int)  //  在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Init(h Interface)  //初始化一个堆。一个堆在使用任何堆操作之前应先初始化。Init函数对于堆的约束性是幂等的（多次执行无意义），并可能在任何时候堆的约束性被破坏时被调用。本函数复杂度为O(n)，其中n等于h.Len()。</li><li>func Pop(h Interface) interface{}  //删除并返回堆h中的最小元素（不影响约束性）。复杂度O(log(n))，其中n等于h.Len()。该函数等价于Remove(h, 0)。</li><li>func Push(h Interface, x interface{})  //向堆h中插入元素x，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Remove(h Interface, i int) interface{}  //删除堆中的第i个元素，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li></ul><p>利用heap创建一个优先级队列:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line">  <span class="comment">// not just its contents.</span></span><br><span class="line">  *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *h</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  x := old[n<span class="number">-1</span>]</span><br><span class="line">  *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  heap.Init(h)</span><br><span class="line">  heap.Push(h, <span class="number">3</span>)</span><br><span class="line">  heap.Fix(h, <span class="number">3</span>)</span><br><span class="line">  fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用heap创建一个优先级队列</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates a priority queue built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">  priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">  <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">  index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">  <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">  pq[i].index = i</span><br><span class="line">  pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  n := <span class="built_in">len</span>(*pq)</span><br><span class="line">  item := x.(*Item)</span><br><span class="line">  item.index = n</span><br><span class="line">  *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *pq</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  item := old[n<span class="number">-1</span>]</span><br><span class="line">  item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">  *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  item.value = value</span><br><span class="line">  item.priority = priority</span><br><span class="line">  heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Some items and their priorities.</span></span><br><span class="line">  items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"banana"</span>: <span class="number">3</span>, <span class="string">"apple"</span>: <span class="number">2</span>, <span class="string">"pear"</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">  <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">  pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">    pq[i] = &amp;Item&#123;</span><br><span class="line">      value:    value,</span><br><span class="line">      priority: priority,</span><br><span class="line">      index:    i,</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">  item := &amp;Item&#123;</span><br><span class="line">    value:    <span class="string">"orange"</span>,</span><br><span class="line">    priority: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  heap.Push(&amp;pq, item)</span><br><span class="line">  pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">  <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">    fmt.Printf(<span class="string">"%.2d:%s \n"</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类,实现相关接口后,交由heap.Init()去构建堆.</p><ul><li>从堆中Pop()后,数据就被从heap中移除了.</li><li>升降序由Less()来决定.</li><li>自定义类也可以直接用Sort来排序,因为实现了相关接口.</li></ul><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>heap在kubernetes scheduler相关内容涉及，将会在后续推出。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;heap是Golang内置的标准库封装，该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heap介绍及范例&lt;/li&gt;
&lt;li&gt;heap解析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>容器那些事</title>
    <link href="https://ustack.io/2019-11-21-container%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-21-container相关概念梳理.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T14:13:17.226Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续对于kubelet相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><h4 id="container与docker"><a href="#container与docker" class="headerlink" title="container与docker"></a>container与docker</h4><blockquote><p>container的概念早于docker，其源于LXC技术，当然在此需要感谢docker社区对于容器技术的贡献，因为docker的出现，container的概念深入人心，容器的特性类似sandbox，进程受到资源的限制，并且彼此间隔离，当然容器区别与虚拟机的技术，主要区别在于内核的是否共享，上述的论断可能不太精确，因此后期如gvisor技术，其通过隔离层实现系统调用。通俗来说容器技术主要指资源限制的cgroup、用于隔离的namespace以及共享内核。</p></blockquote><p>11月13日，Mirantis收购Docker的消息引爆开源届。</p><h4 id="OCI标准"><a href="#OCI标准" class="headerlink" title="OCI标准"></a>OCI标准</h4><p>Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。<br>所谓container runtime，主要负责的是容器的生命周期的管理。oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义。<br>其中<code>runc</code>，是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。</p><p>为了兼容oci标准，docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。</p><h4 id="container-engine"><a href="#container-engine" class="headerlink" title="container engine"></a>container engine</h4><p>容器引擎，或者说容器平台，不仅包含对于容器的生命周期的管理，还包括了对于容器生态的管理，比如对于镜像等。现在的docker、rkt以及阿里推出的pouch均可属于此范畴。<br>docker，随着docker的发展，docker就不再局限于容器的管理，还囊括了存储(volume)、网络(net)等的管理，因此后来的docker是一个容器的管理平台。而runtime逐渐插件化，如下图的runc与kata runtime。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTc92D.jpg" alt="docker runtime plugin"></p><hr><h3 id="Kubernetes相关"><a href="#Kubernetes相关" class="headerlink" title="Kubernetes相关"></a>Kubernetes相关</h3><p>kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。</p><p>在k8s 1.5版本之后，kubernetes推出了自己的运行时接口CRI(container runtime interface)。cri接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。</p><p>与oci不同，cri与kubernetes的概念更加贴合，并紧密绑定。cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为PodSandbox。在cri开始之初，主要是支持docker和rkt两种。其中kubelet是通过cri接口，调用dockershim，并进一步调用docker api实现的。</p><p>如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。</p><p>在之后的社区发展中，kubelet支持docker及remote两种类型，其中docker即内置的dockershim以满足CRI接口，remote方式同样需要满足CRI接口规范。</p><blockquote><p>下图为各runtime与kubelet的通信</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/22/MTc1qs.jpg" alt="kubelet CRI"></p><p>其中的CRI-O插件实现kubelet CRI接口，并能够兼容OCI标准，作为一种可替换docker的轻量级运行时方案，其允许kubelet允许任一符合OCI标准的runtime来运行Pod。<br>下图为CRI-O与OCI接口通信图示。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTgdtP.jpg" alt="CRI-O通信"></p><p>CRI-O插件主要有以下功能：</p><ul><li>镜像服务</li><li>runtime服务</li><li>CNI</li><li>OCI 生成器</li></ul><p>最后，kubelet与CRI-O的交互流程如下：</p><ol><li>kubelet通过list接口获悉启动POD，其中POD是kubernetes的一个概念，由一个或多个共享IPC，NET和PID名称空间并位于同一cgroup中的容器组成。</li><li>kubelet将请求下发到kubernetes CRI-O服务，即kubelet启动时的remote配置（容器运行时接口），以启动新的POD。</li><li>CRI-O使用containers/image库从镜像仓库拉取镜像。</li><li>下载后的镜像解压存储到为容器创建rootfs，即存储在COW文件系统中。</li><li>在rootfs创建后，CRI-O会生成OCI运行时规范json文件，该文件描述了如何使用OCI Generate工具运行容器。</li><li>CRI-O使用该配置启动OCI兼容的运行时，以运行容器进程。默认的OCI运行时是runc。</li><li>每个容器都由单独的通用程序进行监控。 conmon进程保留了容器进程的PID1。它处理容器的日志记录并记录容器过程的退出代码。</li><li>通过CNI设置Pod的网络，因此任何CNI插件均可与CRI-O一起使用。</li></ol><p>下图为CRI的功能图。<br><img src="https://s2.ax1x.com/2019/11/22/MTWv90.md.png" alt="CRI-O功能"></p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将推出kubernetes runtimeclass文章</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://medium.com/kata-containers/why-kata-containers-doesnt-replace-kubernetes-75e484679727" target="_blank" rel="noopener">why-kata-containers-doesnt-replace-kubernetes</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">CRI-O</a></li><li><a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noopener">runtime-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续对于kubelet相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="linux" scheme="https://ustack.io/tags/linux/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes展望与思考</title>
    <link href="https://ustack.io/2019-11-21-Kubernetes%201.17%20%E5%B1%95%E6%9C%9B%E4%B8%8E%E6%80%9D%E8%80%83.html"/>
    <id>https://ustack.io/2019-11-21-Kubernetes 1.17 展望与思考.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T06:50:31.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt></p><div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a>当前changlog，</p></div><p>距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。</p><a id="more"></a><hr><h3 id="一、1-16版本回顾"><a href="#一、1-16版本回顾" class="headerlink" title="一、1.16版本回顾"></a>一、1.16版本回顾</h3><blockquote><p>9月18日，Kubernetes 1.16正式发布，其包含31项增强功能，其中8项增强功能已经GA，另有8项增强功能处于beta阶段，15项处于alpha阶段，该版本有以下亮点:</p></blockquote><ul><li><p>自定义资源(CRD)</p><p>  CRD作为Kubernetes的可扩展机制之一得到广泛使用，其自1.7版本发布以来就一直处于beta阶段。Kubernetes 1.16版本，也标志着CRD迎来了GA版本。</p></li><li><p>存储卷扩展</p><p>  新版本当中包含一系列与存储卷以及卷修改相关的功能。CSI规范中的存储卷大小调整能力提升为beta阶段，允许用户对CSI规范下的存储卷插件进行大小调整。</p></li><li><p>拓扑管理[alpha]</p><p>  Kubelet中旨在协调资源分配决策，从而提供优化效果更好的资源分配能力</p></li><li><p>双栈[alpha]</p><p>  IPv4/IPv6双栈可以将IPv4与IPv6地址分配给各Pod与服务<br>  a. Pod 的多个 IPv4/IPv6 地址分配<br>  b. 集群之间本地双栈通信</p></li></ul><p>下述表单为kubernetes维护时限</p><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、1-17-版本动态"><a href="#二、1-17-版本动态" class="headerlink" title="二、1.17 版本动态"></a>二、1.17 版本动态</h3><pre><code>社区1.17版本的代码freeze时间节点为11月18日，正式发布在12月9日左右，社区在调度、存储等方面进行大量优化，一些PR的进展如下：</code></pre><h4 id="一般更新"><a href="#一般更新" class="headerlink" title="一般更新"></a>一般更新</h4><ol><li>klog升级至v1.0.0</li><li><p>更新SIG图谱，详见community#4129</p><ul><li><p>将特定cloud provider修改为公有云SIG子项目</p></li><li><p>移除容器认证工作组</p></li><li><p>新增Usability SIG等</p></li></ul></li><li>推迟NodeRestriction admission插件研发时间至1.19</li><li>解决kubectl flag <code>--certificate-authority</code>重写问题</li><li>kubeadm不再移除/etc/cni/net.d目录</li><li>etcd server版本升级至3.3.17</li><li>kubeadm配置版本从v1beta1升级至v1beta2</li><li><p>golang性能优化</p><ul><li><p>encoding/json中的sync.Pool使用scanner</p></li><li><p>golang抢占调度，详见golang#24543，里程碑设定于Go 1.14版本</p></li><li><p>优化complie、link</p></li></ul></li><li><p>统一CRI于docker shim字节流长度，限定readiness/liveness字节流输出长度10kb</p></li><li>为相关组件新增readyz及livez接口</li><li>限制kubelet静态pod文件最大长度为10MB，防范Dos</li><li>增加PVC存储需求为负数的校验</li><li>移除firewalld监控，优化iptables处理</li><li><p>云服务商相关：</p><ul><li><p>openstack中doSafeMakeDir时可能带来的fd泄露</p></li><li><p>openstack LB删除故障处理，详见kubernetes#82264</p></li><li><p>azure控制器新增操作技术相关指标</p></li><li><p>升级azure sdk client至v33.1.0，优化API调用</p></li></ul></li><li><p>metrics-server版本升级至0.3.5</p></li><li>hyperkube镜像将不再与kubernetes一同发行</li></ol><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li><p>解决API-Server处理JSON/YAML时面临DoS安全风险（CVE-2019-11253），详情可参看issue#83253</p></li><li><p>net/textproto 头部字段兼容性处理导致CVE-2019-16276</p></li><li><p>非常规构建JSON安全风险问题，详见kubernetes#81158</p></li></ul><h4 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h4><ol><li><p>升级Go 1.13.3</p><ul><li><p>解决当http2握手时的写错误，transport永久缓存断链，详见go#34978</p></li><li><p>Go页分配器未优化导致apiserver延迟及内存趋高等问题，解决详见go#34978、go#35112，此问题的讨论过程详见go#32828</p></li><li><p>解决go mod在k8s模块的使用，更新heketi模块，详见kuberneets#82506</p></li></ul></li><li><p>升级etcd client 3.3.17：详见kubernetes#83801</p><ul><li><p>解决客户端无法正确解析IPv6</p></li><li><p>etcd集群故障时无法证书检查时dns不匹配</p></li></ul></li><li><p>apiserver故障</p><ul><li>当CRD资源定义中包含x-kubernetes-int-or-string字段，导致apiextensions panic：详见kubernetes#83787</li></ul></li><li><p>存储故障</p><ul><li>kubelet重启时清理raw bolck，详见kubernetes#83451</li></ul></li></ol><h4 id="特性维护"><a href="#特性维护" class="headerlink" title="特性维护"></a>特性维护</h4><ol><li><p>调度优化</p><ul><li><p>新增pre-filter插件以更新pod状态</p></li><li><p>将内置调度算法插件化：framwork等</p></li><li><p>TaintNodesByCondition特性1.17正式GA，移除节点状态相关predicate算法：内存、磁盘、PID、状态，以TaintNodesByCondition替换</p></li><li><p>新增调度队列操作pod的相关指标</p></li><li><p>新增调度相关延迟及请求相关指标</p></li><li><p>将调度插件中节点计算分范围从【0，10】调整为【0，100】，其不会影响第三方及RequestedToCapacityRatio算法</p></li></ul></li><li><p>优化EndpointSlice特性</p><ul><li>通过使用string对比替换IP，在kube-proxy启用EndpointSlice时，显著提升性能～50%，详见kubernetes#83035</li></ul></li><li><p>apiserver增强</p><ul><li>新增认证功能延迟的监控指标</li><li>移除apiserver loopback客户端QPS限制，其将影响apiserver性能，详见kuberneets#80465</li><li>提供开启/关闭 REST API及特性配置：–runtime-config=api/beta=false –feature-gates=AllBeta=false</li><li>解决kube-apiserver goroutine泄露，详见kubernetes#83333</li><li>WatchBookmark特性1.17正式GA</li></ul></li><li><p>dns优化</p><ul><li>kube-dns降权运行，详见kubernetes#82347</li></ul></li><li><p>存储优化：</p><p> a. CSI raw block特性</p><ul><li>拆分NodeStage / NodePublish</li><li><p>修改重启kubelet时的volume重建逻辑</p><p>b. VolumeSubpathEnvExpansion特性正式GA</p></li></ul></li><li><p>控制器优化</p><ul><li><p>优化ReplicaSet处理逻辑：创建/删除时考虑pod相关性，详见kubernetes#80004</p></li><li><p>Pod Disruption Budged对象处理优化，详见kubernetes#83951</p></li></ul></li></ol><hr><h3 id="三、CNCF相关"><a href="#三、CNCF相关" class="headerlink" title="三、CNCF相关"></a>三、CNCF相关</h3><ol><li><p>Jaeger项目顺利毕业</p><p> 相关介绍：Jaeger由Uber开源的端到端分布式追踪平台，用于监控与排查应用故障。</p></li><li><p>Vitess项目顺利毕业</p><p> 相关介绍：Vitess最初在2010年由YouTube创建的一个内部解决方案，用于MySQL集群扩展 ，近期发布4.0版本。</p></li><li><p>CNCF发布2019/2020赞助企划书及KubeCon相关日程</p><p> 会议：2020年KubeCon + CloudNativeCon + 中国开源峰会<br> 日程：中国上海|2020年7月28日-30日<br> 人数：4000多名参会者</p></li></ol><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kubernetes 1.17&lt;/a&gt;当前changlog，&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>证书相关概念</title>
    <link href="https://ustack.io/2019-11-21-%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-21-证书相关概念梳理.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T08:53:43.411Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>之前没接触过证书加密的话,对证书相关的这些概念一知半解,虽然属于密码学范畴，但从事计算机专业，就需要保持时刻学习的态度.写这篇文章的目的就是为了理理清这些概念及后续推出的kubernetes安全相关文档.</p></div><a id="more"></a><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>SSL: Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,https就是带加密的http协议,而https的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的.</p><p>OpenSSL:简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到.</p><h4 id="证书标准"><a href="#证书标准" class="headerlink" title="证书标准"></a>证书标准</h4><p>X.509:这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.</p><h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式.</p><ul><li><p>PEM: Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>  查看PEM格式证书的信息: <code>openssl x509 -in certificate.pem -text -noout</code><br>  Apache和*NIX服务器偏向于使用这种编码格式.</p></li><li><p>DER: Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>  查看DER格式证书的信息: <code>openssl x509 -in certificate.der -inform der -text -noout</code><br>  Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><blockquote><p>虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</p></blockquote><ul><li>CRT: CRT是certificate的三个字母,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码.</li><li>CER: 同样是certificate,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</li><li>KEY: 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.<br>查看方式:<br>  PEM格式:<code>openssl rsa -in mykey.key -text -noout</code><br>  DER格式:<code>openssl rsa -in mykey.key -text -noout -inform der</code></li><li>CSR: Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.<br>  查看方式:<pre><code>PEM格式:`openssl req -in mykey.csr -text -noout`DER格式:`openssl req -in mykey.csr -text -noout -inform der`  </code></pre></li><li>PFX/P12: predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br>  查看方式:<code>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</code><br>  这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.<br>  生成pfx的命令类似这样:<code>openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CACert.crt</code><br>  其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</li></ul><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><blockquote><p>要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req</p></blockquote><ul><li>PEM转为DER: <code>openssl x509 -in cert.crt -outform der -out cert.der</code></li><li>DER转为PEM: <code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></li></ul><h4 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h4><ol><li><p>向权威证书颁发机构申请证书<br>用这命令生成一个csr: 把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变.</p></li><li><p>自签证书<br><code>openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</code><br>在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如”yourcompany.com”,或者你服务器的IP地址,其它都可以留空的.<br>生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.有兴趣的话查查”沃通数字证书”.</p></li></ol><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将推出kubernetes AuthN/z及CSR等系列文章</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://www.360doc.com/content/15/0520/10/21412_471902987.shtml" target="_blank" rel="noopener">证书相关概念</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">CRI-O</a></li><li><a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noopener">runtime-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;之前没接触过证书加密的话,对证书相关的这些概念一知半解,虽然属于密码学范畴，但从事计算机专业，就需要保持时刻学习的态度.写这篇文章的目的就是为了理理清这些概念及后续推出的kubernetes安全相关文档.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux hugepages原理概念</title>
    <link href="https://ustack.io/2019-11-21-Linux%E4%B9%8Bhugepages%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5.html"/>
    <id>https://ustack.io/2019-11-21-Linux之hugepages原理概念.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T14:27:53.836Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p> hugepage是在Linux2.6内核被引入的，主要提供4k的page和比较大的page的选择。</p></div><a id="more"></a><p>系统进程是通过虚拟地址访问内存，但是CPU必须把它转换程物理内存地址才能真正访问内存。为了提高这个转换效率，CPU会缓存最近的虚拟内存地址和物理内存地址的映射关系，并保存在一个由CPU维护的映射表中。为了尽量提高内存的访问速度，需要在映射表中保存尽量多的映射关系。<br>而在Linux中，内存都是以页的形式划分的，默认情况下每页是4K，这就意味着如果物理内存很大，则映射表的条目将会非常多，会影响CPU的检索效率。因为内存大小是固定的，为了减少映射表的条目，可采取的办法只有增加页的尺寸。</p><hr><h3 id="1、hugepages及相关概念"><a href="#1、hugepages及相关概念" class="headerlink" title="1、hugepages及相关概念"></a>1、hugepages及相关概念</h3><p>有一些显示的概念需要澄清，在我们继续讨论Hugepages之前， 如hugetlb, hugetlbfs.<br>page table（页表）是操作系统上的虚拟内存系统的数据结构模型，用于存储虚拟地址与物理地址的对应关系。当我们访问内存时，首先访问”page table“，然后Linux在通过“page table”的mapping来访问真实物理内存（ram+swap）</p><ul><li>TLB: A Translation Lookaside Buffer (TLB)<br>TLB是在cpu中分配的一个固定大小的buffer(or cache)，用于保存“page table”的部分内容，使CPU更快的访问并进行地址转换。</li><li>hugetlb: hugetlb 是记录在TLB 中条目并指向到Hugepage。所以HugePages 通过 hugetlb entries来调用的。</li><li>hugetlbfs: 这是一个新的基于2.6 kernel之上的内存文件系统，如同tmpfs。</li></ul><p>在TLB中通过hugetlb来指向hugepage。这些被分配的hugepage作为内存文件系统hugetlbfs(类似tmpfs)提供给进程使用。</p><h3 id="2、“regular-page”和“huge-page“的请求过程"><a href="#2、“regular-page”和“huge-page“的请求过程" class="headerlink" title="2、“regular page”和“huge page“的请求过程"></a>2、“regular page”和“huge page“的请求过程</h3><p>当一个进程请求内存时，它需要访问文件系统的“页表”（Pagetable）去调用一个实际的物理内存地址,逻辑如下图所示。</p><p><img src="https://s2.ax1x.com/2019/11/23/Mq2La4.md.png" alt="regular"></p><p>当Hugepage部署后，依然是调用普通的页表。 最大的不同是process pagetable和system pagetable增加了Hugepage属性。所以任何页表中的page条目可以是“regular page” 或者是“huge page”.</p><p><img src="https://s2.ax1x.com/2019/11/23/MqRpM6.md.png" alt="huge"></p><h3 id="3、hugepage-优点"><a href="#3、hugepage-优点" class="headerlink" title="3、hugepage 优点"></a>3、hugepage 优点</h3><ol><li><p>HugePages 会在系统启动时，直接分配并保留对应大小的内存区域</p></li><li><p>HugePages 在开机之后，如果没有管理员的介入，是不会释放和改变的。</p></li><li><p>Not swappable: HugePages 是不会swap.也就是没有page-in/page-out。HugePages一直被pin在内存中</p></li><li><p>Relief of TLB pressure:</p></li></ol><p>在purge TLB的时候，减少了事物条目的加载，提高了性能。使用Hugepages后TLB能覆盖更大的内存地址空间，加快地址转换的时间更少的TLB条目，意味着有更大空间用来记录其他的地址空间.</p><ul><li>No ‘kswapd’ Operations：在Linux下进程“kswapd”是管理swap的，如果是大内存，那pages的数量就非常庞大（例如：50G内存包含1千3百万页表条目），就会耗费惊人的CPU资源。如果使用hugepages，kswapd就不会耗费资源去管理它，可以查看文档361670.1。</li><li>Eliminated page table lookup overhead: 因为hugepage是不swappable的，所有就没有page table lookups。</li><li>Faster overall memory performance:  由于虚拟内存需要两步操作才能实际对应到物理内存地址，因此更少的pages，减轻了page table访问热度，避免了page table热点瓶颈问题。</li></ul><h3 id="4、配置Hugepages"><a href="#4、配置Hugepages" class="headerlink" title="4、配置Hugepages"></a>4、配置Hugepages</h3><p>根据下面的步骤来配置Hugepages，修改Hugepages需要重启机器，使用请计划停机时间。</p><p>需要在/etc/security/limits.conf 中设置memlock值(单位KB)，该值小于内存大小，例如你的内存大小是64G，有可以设置以下的值.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft   memlock    60397977</span><br><span class="line">hard   memlock    60397977</span><br></pre></td></tr></table></figure><ul><li>编辑/etc/sysctl.conf 设置 vm.nr_hugepages参数：vm.nr_hugepages = 1496</li><li>reboot</li><li>系统重启后，启动全部的数据库，通过以下命令检查</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep HugePages /proc/meminfo</span></span><br><span class="line">HugePages_Total:    1496</span><br><span class="line">HugePages_Free:      485</span><br><span class="line">HugePages_Rsvd:      446</span><br><span class="line">HugePages_Surp:        0</span><br></pre></td></tr></table></figure><p>HugePages_Free&lt; HugePages_Total 既说明Hugepages已经生效，同时HugePages_Rsvd不为“0”.</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为linux hugepages相关内容的网络优化，后续推出kubelet涉及hugepages的相关内容。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt; hugepage是在Linux2.6内核被引入的，主要提供4k的page和比较大的page的选择。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存控制之oom killer机制</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E4%B9%8Boom%20killer%E6%9C%BA%E5%88%B6.html"/>
    <id>https://ustack.io/2019-11-21-Linux内存控制之oom killer机制.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T15:36:30.366Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及oom killer相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>OOM就是out of memory的缩写，虽然linux kernel有很多的内存管理技巧（从cache中回收、swap out等）来满足各种应用空间的vm内存需求，但是，当你的系统配置不合理，让一匹小马拉大车的时候，linux kernel会运行非常缓慢并且在某个时间点分配page frame的时候遇到内存耗尽、无法分配的状况。应对这种状况首先应该是系统管理员，他需要首先给系统增加内存，不过对于kernel而言，当面对OOM的时候，要根据OOM参数来进行相应的处理。oom kiiler会在内存紧张的时候，会依次kill内存占用较高的进程，发送Sig15(SIGTERM)或Sig9(SIGKILL)，取决于内核版本(可见uname -a，&gt;= 2.6.32只会发送<a href="https://elixir.free-electrons.com/linux/v2.6.18/source/mm/oom_kill.c" target="_blank" rel="noopener">sigkill</a>，并在/var/log/message中进行记录。里面会记录一些如pid，process name，cpu mask，trace等信息，通过监控可以发现类似问题。</p><p><strong><strong>初探</strong></strong></p><p>一个简单分配heap memroy的代码片段(big_mm.c)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> block (1024L*1024L*MB)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB 64L</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">  <span class="comment">// malloc big block memory and ZERO it !!</span></span><br><span class="line">  <span class="keyword">char</span>* mm = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(block);</span><br><span class="line">  usleep(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mm)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    bzero(mm,block);</span><br><span class="line">    total += MB;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"alloc %lum mem\n"</span>,total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有2个地方需要注意：</p><p>1、malloc是分配虚拟地址空间，如果不memset或者bzero，那么就不会触发physical allocate，不会映射物理地址，所以这里用bzero填充<br><br><br>2、每次申请的block大小比较有讲究，Linux内核分为LowMemroy和HighMemroy，LowMemory为内存紧张资源，LowMemroy有个阀值，通过free -lm和<br>/proc/sys/vm/lowmem_reserve_ratio来查看当前low大小和阀值low大小。低于阀值时候才会触发oom killer，所以这里block的分配小雨默认的256M，否则如果每次申请512M(大于128M)，malloc可能会被底层的brk这个syscall阻塞住，内核触发page cache回写或slab回收。</p><p>测试：<code>gcc big_mm.c -o big_mm ; ./big_mm &amp; ./big_mm &amp; ./big_mm &amp;</code></p><h3 id="2、oom-killer机制分析"><a href="#2、oom-killer机制分析" class="headerlink" title="2、oom killer机制分析"></a>2、oom killer机制分析</h3><h4 id="2-1-参数"><a href="#2-1-参数" class="headerlink" title="2.1 参数"></a>2.1 参数</h4><p><strong><strong>panic_on_oom</strong></strong></p><p>当kernel遇到OOM的时候，可以有两种选择：<br>（1）产生kernel panic<br><br><br>（2）积极面对人生，选择一个或者几个最“适合”的进程，启动OOM killer，干掉那些选中的进程，释放内存，让系统勇敢的活下去。</p><p>panic_on_oom这个参数就是控制遇到OOM的时候，系统如何反应的。当该参数等于0的时候，表示选择积极面对人生，启动OOM killer。当该参数等于2的时候，表示无论是哪一种情况，都强制进入kernel panic。panic_on_oom等于其他值的时候，表示要区分具体的情况，对于某些情况可以panic，有些情况启动OOM killer。kernel的代码中，enum oom_constraint 就是一个进一步描述OOM状态的参数。系统遇到OOM总是有各种各样的情况的，kernel中定义如下：</p><p>（1）CONSTRAINT_CPUSET。cpusets是kernel中的一种机制，通过该机制可以把一组cpu和memory node资源分配给特定的一组进程。这时候，如果出现OOM，仅仅说明该进程能分配memory的那个node出现状况了，整个系统有很多的memory node，其他的node可能有充足的memory资源。</p><p>（2）CONSTRAINT_MEMORY_POLICY。memory policy是NUMA系统中如何控制分配各个memory node资源的策略模块。用户空间程序（NUMA-aware的程序）可以通过memory policy的API，针对整个系统、针对一个特定的进程，针对一个特定进程的特定的VMA来制定策略。产生了OOM也有可能是因为附加了memory policy的约束导致的，在这种情况下，如果导致整个系统panic似乎有点不太合适吧。</p><p>（3）CONSTRAINT_MEMCG。MEMCG就是memory control group，Cgroup中的memory子系统就是控制系统memory资源分配的控制器，通俗的将就是把一组进程的内存使用限定在一个范围内。当这一组的内存使用超过上限就会OOM，在这种情况下的OOM就是CONSTRAINT_MEMCG类型的OOM。</p><p><strong><strong>oom_adj、oom_score_adj和oom_score</strong></strong></p><p>准确的说这几个参数都是和具体进程相关的，因此它们位于/proc/xxx/目录下（xxx是进程ID）。假设我们选择在出现OOM状况的时候杀死进程，那么一个很自然的问题就浮现出来：到底干掉哪一个呢？内核的算法倒是非常简单，那就是打分（oom_score，注意，该参数是read only的），找到分数最高的就OK了。那么怎么来算分数呢？<br>我们触发了oom killer的机制，那么oom killer是计算出选择哪个进程kill呢？我们先来看一下kernel提供给用户态的/proc下的一些参数：</p><p>(1）对某一个task进行打分（oom_score）主要有两部分组成，一部分是系统打分，主要是根据该task的内存使用情况。另外一部分是用户打分，也就是oom_score_adj了，该task的实际得分需要综合考虑两方面的打分。如果用户将该task的 oom_score_adj设定成OOM_SCORE_ADJ_MIN（-1000）的话，那么实际上就是禁止了OOM killer杀死该进程。<br><br><br>(2）这里返回了0也就是告知OOM killer，该进程是“good process”，不要干掉它。后面我们可以看到，实际计算分数的时候最低分是1分。<br><br><br>(3）前面说过了，系统打分就是看物理内存消耗量，主要是三部分，RSS部分，swap file或者swap device上占用的内存情况以及页表占用的内存情况。<br><br><br>(4）root进程有3%的内存使用特权，因此这里要减去那些内存使用量。<br><br><br>(5）用户可以调整oom_score，具体如何操作呢？oom_score_adj的取值范围是-1000～1000，0表示用户不调整oom_score，负值表示要在实际打分值上减去一个折扣，正值表示要惩罚该task，也就是增加该进程的oom_score。在实际操作中，需要根据本次内存分配时候可分配内存来计算（如果没有内存分配约束，那么就是系统中的所有可用内存，如果系统支持cpuset，那么这里的可分配内存就是该cpuset的实际额度值）。oom_badness函数有一个传入参数totalpages，该参数就是当时的可分配的内存上限值。实际的分数值（points）要根据oom_score_adj进行调整，例如如果oom_score_adj设定-500，那么表示实际分数要打五折（基数是totalpages），也就是说该任务实际使用的内存要减去可分配的内存上限值的一半。</p><p>了解了oom_score_adj和oom_score之后，应该是尘埃落定了，oom_adj是一个旧的接口参数，其功能类似oom_score_adj，为了兼容，目前仍然保留这个参数，当操作这个参数的时候，kernel实际上是会换算成oom_score_adj。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/[pid]/oom_adj <span class="comment">#该pid进程被oom killer杀掉的权重，介于 [-17,15]之间，越高的权重，意味着更可能被oom killer选中，-17表示禁止被kill掉。</span></span><br><span class="line">/proc/[pid]/oom_score <span class="comment">#当前该pid进程的被kill的分数，越高的分数意味着越可能被kill，这个数值是根据oom_adj运算后的结果，是oom_killer的主要参考。</span></span><br></pre></td></tr></table></figure><p>sysctl 下有2个可配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.panic_on_oom = 0       <span class="comment">#内存不够时内核是否直接panic</span></span><br><span class="line">vm.oom_kill_allocating_task = 1      <span class="comment">#oom-killer是否选择当前正在申请内存的进程进行kill</span></span><br></pre></td></tr></table></figure><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linux-mm.org/OOM_Killer" target="_blank" rel="noopener">oom</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及oom killer相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux几个重要的内核配置</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE.html"/>
    <id>https://ustack.io/2019-11-21-Linux几个重要的内核配置.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T13:50:17.539Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>以下是在/etc/sysctl.conf文件中配置的几个重要内核参数，这几个参数的设置关系到系统性能。</p></div><a id="more"></a><hr><h3 id="1、net-ipv4-tcp-syncookies"><a href="#1、net-ipv4-tcp-syncookies" class="headerlink" title="1、net.ipv4.tcp_syncookies"></a>1、net.ipv4.tcp_syncookies</h3><blockquote><p>此参数应该设置为1，防止SYN Flood</p></blockquote><p>处在SYN_RECV的TCP连接称为半连接，存储在SYN队列。大量SYN_RECV会导致队列溢出，后续请求将被内核直接丢弃，也就是SYN Flood攻击。开启syncookies后，当SYN队列满了后，TCP会通过原地址端口，目的地址端口和时间戳打造一个特别的Sequence Number(又叫cookie发回去，如果是攻击者则不会有响应，如果是正常连接则把这个SYNCookie发回来，然后服务器端可以通过cookie建立连接(即使不在SYN队列)。</p><h3 id="2、net-ipv4-tcp-fin-timeout"><a href="#2、net-ipv4-tcp-fin-timeout" class="headerlink" title="2、net.ipv4.tcp_fin_timeout"></a>2、net.ipv4.tcp_fin_timeout</h3><blockquote><p>此参数默认值60</p></blockquote><p>TCP保持在FIN_WAIT2状态的时间，超时后直接处于CLOSED，所以降低tcp_fin_timeout有助于减少TIME_WAIT数量。注意：虽然shutdown(SHUD_WR)也会处于FIN_WAIT2状态，但超时并不起作用。</p><h3 id="3、net-ipv4-tcp-tw-recycle"><a href="#3、net-ipv4-tcp-tw-recycle" class="headerlink" title="3、net.ipv4.tcp_tw_recycle"></a>3、net.ipv4.tcp_tw_recycle</h3><blockquote><p>此参数默认值0，打开快速TIME_WAIT socket回收</p></blockquote><p>如果tcp_timestamps开启的话，会缓存每个连接的最新时间戳，如果后续请求时间戳小于缓存的时间戳，即视为无效，相应的包被丢弃。所以如果是在NAT(Network Address Translation)网络下，就可能出现数据包丢弃的现象，会导致大量的TCP连接建立错误。</p><h3 id="4、net-ipv4-tcp-tw-resue"><a href="#4、net-ipv4-tcp-tw-resue" class="headerlink" title="4、net.ipv4.tcp_tw_resue"></a>4、net.ipv4.tcp_tw_resue</h3><blockquote><p>此参数默认值0，是否重用TIME_WAIT状态的socket用于新的连接</p></blockquote><p>这个选项要比net.ipv4.tcp_tw_recycle安全，从协议的角度看，复用是安全的。复用条件:</p><ul><li>net.ipv4.tcp_timestamps选项必须打开(客户端也必须打开) ；</li><li>重用TIME_WAIT的条件是收到最后一个包后超过1秒；</li></ul><h3 id="5、net-ipv4-tcp-keepalive-time-1200"><a href="#5、net-ipv4-tcp-keepalive-time-1200" class="headerlink" title="5、net.ipv4.tcp_keepalive_time = 1200"></a>5、net.ipv4.tcp_keepalive_time = 1200</h3><blockquote><p>此参数表示TCP发送keepalive探测消息的间隔时间（秒）</p></blockquote><p>用于确认TCP连接是否有效。当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，可改为20分钟。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为linux相关内容的网络优化，后续推出CNI相关内容。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;以下是在/etc/sysctl.conf文件中配置的几个重要内核参数，这几个参数的设置关系到系统性能。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存控制之overcommit</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E4%B9%8B%E8%B6%85%E5%88%86.html"/>
    <id>https://ustack.io/2019-11-21-Linux内存控制之超分.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T13:50:12.730Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及内存分配相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>Memory Overcommit的意思是操作系统承诺给进程的内存大小超过了实际可用的内存。一个保守的操作系统不会允许memory overcommit，有多少就分配多少，再申请就没有了，这其实有些浪费内存，因为进程实际使用到的内存往往比申请的内存要少，比如某个进程malloc()了200MB内存，但实际上只用到了100MB，按照UNIX/Linux的算法，物理内存页的分配发生在使用的瞬间，而不是在申请的瞬间，也就是说未用到的100MB内存根本就没有分配，这100MB内存就闲置了。下面这个概念很重要，是理解memory overcommit的关键：commit(或overcommit)针对的是内存申请，内存申请不等于内存分配，内存只在实际用到的时候才分配。</p><p>Linux是允许memory overcommit的，只要你来申请内存我就给你，寄希望于进程实际上用不到那么多内存，但万一用到那么多了呢？那就会发生类似“银行挤兑”的危机，现金(内存)不足了。Linux设计了一个OOM killer机制(OOM = out-of-memory)来处理这种危机：挑选一个进程出来杀死，以腾出部分内存，如果还不够就继续杀…也可通过设置内核参数 vm.panic_on_oom 使得发生OOM时自动重启系统。这都是有风险的机制，重启有可能造成业务中断，杀死进程也有可能导致业务中断，我自己的这个小网站就碰到过这种问题，参见前文。所以Linux 2.6之后允许通过内核参数 vm.overcommit_memory 禁止memory overcommit。</p><p>内核参数 vm.overcommit_memory 接受三种取值：</p><ul><li>Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法（对该算法的详细解释请看文末）猜测你的内存申请是否合理，它认为不合理就会拒绝overcommit。</li><li>Always overcommit. 允许overcommit，对内存申请来者不拒。</li><li>Don’t overcommit. 禁止overcommit。</li></ul><p>关于禁止overcommit (vm.overcommit_memory=2) ，需要知道的是，怎样才算是overcommit呢？kernel设有一个阈值，申请的内存总数超过这个阈值就算overcommit，在/proc/meminfo中可以看到这个阈值的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i commit /proc/meminfo</span></span><br><span class="line">CommitLimit:     5967744 kB</span><br><span class="line">Committed_AS:    5363236 kB</span><br></pre></td></tr></table></figure><p>CommitLimit 就是overcommit的阈值，申请的内存总数超过CommitLimit的话就算是overcommit。<br>这个阈值是如何计算出来的呢？它既不是物理内存的大小，也不是free memory的大小，它是通过内核参数vm.overcommit_ratio或vm.overcommit_kbytes间接设置的，公式如下：<br><code>CommitLimit = (Physical RAM * vm.overcommit_ratio / 100) + Swap</code></p><blockquote><p>vm.overcommit_ratio 是内核参数，缺省值是50，表示物理内存的50%。如果你不想使用比率，也可以直接指定内存的字节数大小，通过另一个内核参数 vm.overcommit_kbytes 即可；<br>如果使用了huge pages，那么需要从物理内存中减去，公式变成：<br>CommitLimit = ([total RAM] – [total huge TLB RAM]) * vm.overcommit_ratio / 100 + swap<br>参见<a href="https://access.redhat.com/solutions/665023" target="_blank" rel="noopener">链接</a></p></blockquote><p>/proc/meminfo中的 Committed_AS 表示所有进程已经申请的内存总大小，（注意是已经申请的，不是已经分配的），如果 Committed_AS 超过 CommitLimit 就表示发生了 overcommit，超出越多表示 overcommit 越严重。Committed_AS 的含义换一种说法就是，如果要绝对保证不发生OOM (out of memory) 需要多少物理内存。</p><p>“sar -r”是查看内存使用状况的常用工具，它的输出结果中有两个与overcommit有关，kbcommit 和 %commit：<br>kbcommit对应/proc/meminfo中的 Committed_AS；<br>%commit的计算公式并没有采用 CommitLimit作分母，而是Committed_AS/(MemTotal+SwapTotal)，意思是<em>内存申请</em>占<em>物理内存与交换区之和</em>的百分比。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sar -r</span><br><span class="line">05:00:01 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">05:10:01 PM    160576   3648460     95.78         0   1846212   4939368     62.74   1390292   1854880</span><br></pre></td></tr></table></figure><h3 id="2、Heuristic-overcommit算法"><a href="#2、Heuristic-overcommit算法" class="headerlink" title="2、Heuristic overcommit算法"></a>2、Heuristic overcommit算法</h3><p>内核参数 vm.overcommit_memory 的值0，1，2，其中heuristic overcommit对应的是OVERCOMMIT_GUESS：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_GUESS                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_ALWAYS               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_NEVER                2</span></span><br></pre></td></tr></table></figure><p>Heuristic overcommit算法在以下函数中实现，基本上可以这么理解：<br>单次申请的内存大小不能超过 【free memory + free swap + pagecache的大小 + SLAB中可回收的部分】，否则本次申请就会失败。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及内存分配相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>谈谈linux中各式锁</title>
    <link href="https://ustack.io/2019-11-21-%E8%B0%88%E8%B0%88linux%E4%B8%ADflock%E3%80%81lockf%E4%B8%8Efcntl.html"/>
    <id>https://ustack.io/2019-11-21-谈谈linux中flock、lockf与fcntl.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T14:39:19.992Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>首先flock和fcntl是系统调用，而lockf是库函数。lockf实际上是fcntl的封装，所以lockf和fcntl的底层实现是一样的，对文件加锁的效果也是一样的。后面分析不同点时大多数情况是将fcntl和lockf放在一起的。下面首先看每个函数的使用，从使用的方式和效果来看各个函数的区别。</p></div><a id="more"></a><hr><h3 id="1、flock"><a href="#1、flock" class="headerlink" title="1、flock"></a>1、flock</h3><p><strong><strong>函数原型</strong></strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flock(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation);  <span class="comment">// Apply or remove an advisory lock on the open file specified by fd，只是建议性锁</span></span><br></pre></td></tr></table></figure><p>其中fd是系统调用open返回的文件描述符，operation的选项有：</p><ol><li>LOCK_SH ：共享锁</li><li>LOCK_EX ：排他锁或者独占锁</li><li>LOCK_UN : 解锁。</li><li>LOCK_NB：非阻塞（与以上三种操作一起使用）</li></ol><p>关于flock函数，首先要知道flock函数只能对整个文件上锁，而不能对文件的某一部分上锁，这是于fcntl/lockf的第一个重要区别，后者可以对文件的某个区域上锁。其次，flock只能产生劝告性锁。我们知道，linux存在强制锁（mandatory lock）和劝告锁（advisory lock）。所谓强制锁，比较好理解，就是你家大门上的那把锁，最要命的是只有一把钥匙，只有一个进程可以操作。所谓劝告锁，本质是一种协议，你访问文件前，先检查锁，这时候锁才其作用，如果你不那么kind，不管三七二十一，就要读写，那么劝告锁没有任何的作用。而遵守协议，读写前先检查锁的那些进程，叫做合作进程。再次，flock和fcntl/lockf的区别主要在fork和dup。</p><p>(1)、flock创建的锁是和文件打开表项（struct file）相关联的，而不是fd。这就意味着复制文件fd（通过fork或者dup）后，那么通过这两个fd都可以操作这把锁（例如通过一个fd加锁，通过另一个fd可以释放锁），也就是说子进程继承父进程的锁。但是上锁过程中关闭其中一个fd，锁并不会释放（因为file结构并没有释放），只有关闭所有复制出的fd，锁才会释放。对fd1上锁，并不影响程序通过fd2上锁。子进程持有锁，并不影响父进程通过相同的fd获取锁，反之亦然。<br><br><br>(2)、使用open两次打开同一个文件，得到的两个fd是独立的（因为底层对应两个file对象），通过其中一个加锁，通过另一个无法解锁，并且在前一个解锁前也无法上锁。通过fd1获取锁后，无法再通过fd2获取锁。<br><br><br>(3)、使用exec后，文件锁的状态不变。<br><br><br>(4)、flock不能再NFS文件系统上使用，如果要在NFS使用文件锁，请使用fcntl。<br><br><br>(5)、flock锁可递归，即通过dup或者或者fork产生的两个fd，都可以加锁而不会产生死锁。</p><h3 id="2、lockf与fcntl"><a href="#2、lockf与fcntl" class="headerlink" title="2、lockf与fcntl"></a>2、lockf与fcntl</h3><p><strong><strong>函数原型</strong></strong></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lockf(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, off_t <span class="built_in">len</span>);  <span class="comment">// fd为通过open返回的打开文件描述符。</span></span><br></pre></td></tr></table></figure><p>cmd的取值为：</p><ol><li>F_LOCK：给文件互斥加锁，若文件以被加锁，则会一直阻塞到锁被释放。</li><li>F_TLOCK：同F_LOCK，但若文件已被加锁，不会阻塞，而回返回错误。</li><li>F_ULOCK：解锁。</li><li>F_TEST：测试文件是否被上锁，若文件没被上锁则返回0，否则返回-1。</li><li>len：为从文件当前位置的起始要锁住的长度。</li></ol><p>通过函数参数的功能，可以看出lockf只支持排他锁，不支持共享锁。</p><p>文件记录加锁相关的cmd 分三种：</p><ol><li>F_SETLK：申请锁（读锁F_RDLCK，写锁F_WRLCK）或者释放所（F_UNLCK），但是如果kernel无法将锁授予本进程（被其他进程抢了先，占了锁），不傻等，返回error。</li><li>F_SETLKW：和F_SETLK几乎一样，唯一的区别，这厮是个死心眼的主儿，申请不到，就傻等。</li><li>F_GETLK：这个接口是获取锁的相关信息： 这个接口会修改我们传入的struct flock。</li></ol><p>通过函数参数功能可以看出fcntl是功能最强大的，它既支持共享锁又支持排他锁，即可以锁住整个文件，又能只锁文件的某一部分。</p><h4 id="fcntl-lockf特性"><a href="#fcntl-lockf特性" class="headerlink" title="fcntl/lockf特性"></a>fcntl/lockf特性</h4><p>(1) 上锁可递归，如果一个进程对一个文件区间已经有一把锁，后来进程又企图在同一区间再加一把锁，则新锁将替换老锁。<br><br><br>(2) 加读锁（共享锁）文件必须是读打开的，加写锁（排他锁）文件必须是写打开。<br><br><br>(3) 进程不能使用F_GETLK命令来测试它自己是否再文件的某一部分持有一把锁。F_GETLK命令定义说明，返回信息指示是否现存的锁阻止调用进程设置它自己的锁。因为，F_SETLK和F_SETLKW命令总是替换进程的现有锁，所以调用进程绝不会阻塞再自己持有的锁上，于是F_GETLK命令绝不会报告调用进程自己持有的锁。<br><br><br>(4) 进程终止时，他所建立的所有文件锁都会被释放，队医flock也是一样的。<br><br><br>(5) 任何时候关闭一个描述符时，则该进程通过这一描述符可以引用的文件上的任何一把锁都被释放（这些锁都是该进程设置的），这一点与flock不同。<br><br><br>(6) 由fork产生的子进程不继承父进程所设置的锁，这点与flock也不同。<br><br><br>(8) 支持强制性锁：对一个特定文件打开其设置组ID位(S_ISGID)，并关闭其组执行位(S_IXGRP)，则对该文件开启了强制性锁机制。再Linux中如果要使用强制性锁，则要在文件系统mount时，使用_omand打开该机制。</p><h4 id="fcntl-lockf关联"><a href="#fcntl-lockf关联" class="headerlink" title="fcntl/lockf关联"></a>fcntl/lockf关联</h4><blockquote><p>flock和lockf/fcntl所上的锁有什么关系呢？答案时互不影响。测试程序如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd, ret;</span><br><span class="line">  <span class="keyword">int</span> pid;</span><br><span class="line">  fd = open(<span class="string">"./tmp.txt"</span>, O_RDWR);</span><br><span class="line">  ret = flock(fd, LOCK_EX);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"flock return ret : %dn"</span>, ret);</span><br><span class="line">  ret = lockf(fd, F_LOCK, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"lockf return ret: %dn"</span>, ret);</span><br><span class="line">  sleep(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">flock <span class="built_in">return</span> ret : 0</span><br><span class="line">lockf <span class="built_in">return</span> ret: 0</span><br></pre></td></tr></table></figure><p>可见flock的加锁，并不影响lockf的加锁。另外我们可以通过<code>/proc/locks</code>查看进程获取锁的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ps</span> aux | grep a.out | grep -v grep</span><br><span class="line">123751   18849  0.0  0.0  11904   440 pts/5    S+   01:09   0:00 ./a.out</span><br><span class="line"><span class="variable">$sudo</span> cat /proc/locks | grep 18849</span><br><span class="line">1: POSIX  ADVISORY  WRITE 18849 08:02:852674 0 EOF</span><br><span class="line">2: FLOCK  ADVISORY  WRITE 18849 08:02:852674 0 EOF</span><br></pre></td></tr></table></figure><p>我们可以看到/proc/locks下面有锁的信息：我现在分别叙述下含义：</p><p>(1) POSIX FLOCK 这个比较明确，就是哪个类型的锁。flock系统调用产生的是FLOCK，fcntl调用F_SETLK，F_SETLKW或者lockf产生的是POSIX类型，有次可见两种调用产生的锁的类型是不同的；<br><br><br>(2) ADVISORY表明是劝告锁；<br><br><br>(3) WRITE顾名思义，是写锁，还有读锁；<br><br><br>(4) 18849是持有锁的进程ID。当然对于flock这种类型的锁，会出现进程已经退出的状况。<br><br><br>(5) 08:02:852674表示的对应磁盘文件的所在设备的主设备好，次设备号，还有文件对应的inode number。<br><br><br>(6) 0表示的是所的其实位置<br><br><br>(7) EOF表示的是结束位置。 这两个字段对fcntl类型比较有用，对flock来是总是0 和EOF。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于锁的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.jb51.net/article/90255.htm" target="_blank" rel="noopener">锁相关概念</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;首先flock和fcntl是系统调用，而lockf是库函数。lockf实际上是fcntl的封装，所以lockf和fcntl的底层实现是一样的，对文件加锁的效果也是一样的。后面分析不同点时大多数情况是将fcntl和lockf放在一起的。下面首先看每个函数的使用，从使用的方式和效果来看各个函数的区别。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构原理解析</title>
    <link href="https://ustack.io/2019-11-21-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html"/>
    <id>https://ustack.io/2019-11-21-分布式架构原理解析.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T14:59:10.629Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>etcd作为kubernetes数据存储，其是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</p></div><a id="more"></a><hr><h3 id="1、分布式概念"><a href="#1、分布式概念" class="headerlink" title="1、分布式概念"></a>1、分布式概念</h3><h4 id="1-1-异常"><a href="#1-1-异常" class="headerlink" title="1.1 异常"></a>1.1 异常</h4><p><strong><strong>服务器宕机</strong></strong></p><p>内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。</p><p><strong><strong>网络异常</strong></strong></p><p>有一种特殊的网络异常称为——网络分区 ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p><strong><strong>磁盘故障</strong></strong></p><p>磁盘故障是一种发生概率很高的异常。使用冗余机制，将数据存储到多台服务器。</p><h4 id="1-2-超时"><a href="#1-2-超时" class="headerlink" title="1.2 超时"></a>1.2 超时</h4><p>在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。可以将服务器的操作设计为具有 幂等性 ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。</p><h4 id="1-3-衡量指标"><a href="#1-3-衡量指标" class="headerlink" title="1.3 衡量指标"></a>1.3 衡量指标</h4><p><strong><strong>性能</strong></strong></p><p>常见的性能指标有：吞吐量、响应时间。<br><br><br>其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。<br><br><br>这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下：<br><br><br>a、在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。<br><br><br>b、但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。</p><p><strong><strong>可用性</strong></strong></p><p>可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p><strong><strong>一致性</strong></strong></p><p>可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。</p><p><strong><strong>可扩展性</strong></strong></p><p>指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线性增加。</p><h3 id="2-数据分布"><a href="#2-数据分布" class="headerlink" title="2. 数据分布"></a>2. 数据分布</h3><p>分布式存储系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。</p><p>数据库的水平切分（Sharding）也是一种分布式存储方法，下面的数据分布方法同样适用于 Sharding。</p><h4 id="2-1-哈希分布"><a href="#2-1-哈希分布" class="headerlink" title="2.1 哈希分布"></a>2.1 哈希分布</h4><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><p><strong><strong>一致性哈希</strong></strong></p><p>Distributed Hash Table（DHT）：对于哈希空间 [0, 2n-1]，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p>一致性哈希的优点是在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。</p><h4 id="2-2-顺序分布"><a href="#2-2-顺序分布" class="headerlink" title="2.2 顺序分布"></a>2.2 顺序分布</h4><p>哈希分布式破坏了数据的有序性，顺序分布则不会。</p><p>顺序分布的数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如下图中，User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布的优点是可以充分利用每个节点的空间，而哈希分布很难控制一个节点存储多少数据。</p><p>但是顺序分布需要使用一个映射表来存储数据到节点的映射，这个映射表通常使用单独的节点来存储。当数据量非常大时，映射表也随着变大，那么一个节点就可能无法存放下整个映射表。并且单个节点维护着整个映射表的开销很大，查找速度也会变慢。为了解决以上问题，引入了一个中间层，也就是 Meta 表，从而分担映射表的维护工作。</p><h4 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3 负载均衡"></a>2.3 负载均衡</h4><p>衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。</p><p>分布式系统存储应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。</p><p>每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。</p><p>一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。</p><h3 id="3-分布式理论"><a href="#3-分布式理论" class="headerlink" title="3. 分布式理论"></a>3. 分布式理论</h3><h4 id="3-1-CAP"><a href="#3-1-CAP" class="headerlink" title="3.1 CAP"></a>3.1 CAP</h4><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><p>一致性<br>一致性指的是多个数据副本是否能保持一致的特性。</p><p>在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><p>可用性<br>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><p>分区容忍性<br>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><p>权衡<br>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难都使它们同时满足。在多个节点之间进行数据同步时，</p><p>为了保证一致性（CP），就需要让所有节点下线成为不可用的状态，等待同步完成；<br>为了保证可用性（AP），在同步过程中允许读取所有节点的数据，但是数据可能不一致。<br>3.2. BASE<br>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><p>基本可用<br>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><p>软状态<br>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。</p><p>最终一致性<br>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><ol start="4"><li>分布式事务问题<br>4.1. 两阶段提交（2PC）<br>两阶段提交（Two-phase Commit，2PC）</li></ol><p>主要用于实现分布式事务，分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</p><p>通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p>运行过程<br>准备阶段</p><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p>提交阶段</p><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p>问题<br>同步阻塞</p><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p><p>单点问题</p><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p><p>数据不一致</p><p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><p>太过保守</p><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><p>2PC 优缺点<br>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致） 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p><p>4.2. 补偿事务（TCC）<br>补偿事务（TCC）其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><p>Try 阶段主要是对业务系统做检测及资源预留。<br>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。<br>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。<br>举个例子，假设 Bob 要向 Smith 转账，思路大概是：</p><p>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。<br>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。<br>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。<br>TCC 优缺点<br>优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。<br>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。<br>4.3. 本地消息表（异步确保）<br>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。</p><p>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。<br>之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。<br>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</p><p>这种方案遵循 BASE 理论，采用的是最终一致性。</p><p>本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。</p><p>本地消息表优缺点<br>优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。<br>缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。<br>4.4. MQ 事务消息<br>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><p>Prepared 消息，会拿到消息的地址。<br>执行本地事务。<br>通过第一阶段拿到的地址去访问消息，并修改状态。<br>也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p>MQ 事务消息优缺点<br>优点：实现了最终一致性，不需要依赖本地数据库事务。<br>缺点：实现难度大，主流 MQ 不支持。</p><ol start="5"><li>共识性问题<br>5.1. Paxos<br>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</li></ol><p>主要有三类节点：</p><p>提议者（Proposer）：提议一个值；<br>接受者（Acceptor）：对每个提议进行投票；<br>告知者（Learner）：被告知投票的结果，不参与投票过程。<br>算法需要满足 safety 和 liveness 两方面的约束要求（实际上这两个基础属性是大部分分布式算法都该考虑的）：</p><p>safety：保证决议结果是对的，无歧义的，不会出现错误情况。<br>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；<br>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；<br>liveness：保证决议过程能在有限时间内完成。<br>决议总会产生，并且 learners 能获得被批准（chosen）的决议。<br>基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。</p><p>Paxos 能保证在超过 1/2 的正常节点存在时，系统能达成共识。</p><p>单个提案者+多接收者<br>如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接收者的投票，即可认为通过，因为系统中不存在其他的提案。</p><p>但一旦提案者故障，则系统无法工作。</p><p>多个提案者+单个接收者<br>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。</p><p>缺陷也是容易发生单点故障，包括接收者故障或首个提案者节点故障。</p><p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p><p>当提案者和接收者都推广到多个的情形，会出现一些挑战。</p><p>多个提案者+多个接收者<br>既然限定单提案者或单接收者都会出现故障，那么就得允许出现多个提案者和多个接收者。问题一下子变得复杂了。</p><p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个数字来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p><p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p><p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p><p>此外，提案者即便收到了多数接收者的投票，也不敢说就一定通过。因为在此过程中系统可能还有其它的提案。</p><p>5.2. Raft<br>Raft 算法是 Paxos 算法的一种简化实现。</p><p>包括三种角色：leader、candidate 和 follower，其基本过程为：</p><p>Leader 选举 - 每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；<br>同步 log - leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；<br>注：此处 log 并非是指日志消息，而是各种事件的发生记录。</p><p>单个 Candidate 的竞选<br>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><p>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p><p>此时 A 发送投票请求给其它所有节点。</p><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p><p>多个 Candidate 竞选<br>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</p><p>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p><p>同步日志<br>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p><p>Leader 会把修改复制到所有 Follower。</p><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</p><ol start="6"><li>分布式缓存问题<br>6.1. 缓存雪崩<br>缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</li></ol><p>解决方案：</p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<br>还有一个简单的方案，就是将缓存失效时间分散开，不要所有缓存时间长度都设置成 5 分钟或者 10 分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p><p>6.2. 缓存穿透<br>缓存穿透是指：用户查询的数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。</p><p>解决方案：</p><p>在封装的缓存 SET 和 GET 部分增加个步骤，如果查询一个 KEY 不存在，就以这个 KEY 为前缀设定一个标识 KEY；以后再查询该 KEY 的时候，先查询标识 KEY，如果标识 KEY 存在，就返回一个协定好的非 false 或者 NULL 值，然后 APP 做相应的处理，这样缓存层就不会被穿透。当然这个验证 KEY 的失效时间不能太长。<br>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。<br>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。<br>6.3. 缓存预热<br>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决方案：</p><p>直接写个缓存刷新页面，上线时手工操作下；<br>数据量不大，可以在项目启动的时候自动进行加载；<br>定时刷新缓存；<br>6.4. 缓存更新<br>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>定时去清理过期的缓存；<br>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><p>6.5. 缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于锁的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.jb51.net/article/90255.htm" target="_blank" rel="noopener">锁相关概念</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;etcd作为kubernetes数据存储，其是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之mod详解</title>
    <link href="https://ustack.io/2019-10-17-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bmod%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://ustack.io/2019-10-17-Golang漫谈之mod详解.html</id>
    <published>2019-10-17T12:40:08.000Z</published>
    <updated>2019-10-18T08:50:47.449Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>Go modules是Golang官方在1.11版本推出的包管理工具，在此之前，周边社区提供多种包管理方案，在讨论此类方案之前，可以先回顾一个golang关于包管理的发展。该文章主要介绍，以下内容:</p><ul><li>mod简介及入门</li><li>mod特性</li><li>社区动向</li></ul><a id="more"></a><hr><h4 id="一、mod简介"><a href="#一、mod简介" class="headerlink" title="一、mod简介"></a>一、mod简介</h4><h5 id="1-1-包管理历史发展"><a href="#1-1-包管理历史发展" class="headerlink" title="1.1 包管理历史发展"></a>1.1 包管理历史发展</h5><p> 官方对于Golang的包管理前期一直未释出官方版本，这同样也是被人所诟病的一大缺陷，下面我们看看包管理的历史发展：</p><ul><li>在1.5版本前，所有的依赖都在GOPATH之下，没有版本控制，更别谈其他特性，该方式无法实现包的多版本依赖控制，如project A和B依赖不同的project C版本</li><li>1.15推出vendor机制，即每个项目的跟目录下可以有一个vendor目录，里面存放该项目的依赖库，类似nodejs，在执行go build时会先查找vendor目录</li><li>1.9版本推出dep、vgo，dep被废弃</li><li>1.11版本推出modules机制，基于vgo实现，1.11.2得到增强，并在1.12中默认开启</li></ul><p>除此之外，社区周边还活跃着以下几种包管理工具：</p><ul><li>godep 废弃</li><li>glide 不再维护</li><li>govendor 维护</li></ul><h5 id="1-2-环境介绍"><a href="#1-2-环境介绍" class="headerlink" title="1.2 环境介绍"></a>1.2 环境介绍</h5><p>Golang版本: 1.12.7，在1.12之前，启用mod需要设置环境变量<code>GO111MODULE=on</code>，若需要关闭该特性使用GOPATH，则<code>GO111MODULE=off</code>，说明如下：</p><ul><li>GO111MODULE=off：关闭mod特性，使用GOPATH</li><li>GO111MODULE=on：启用mod特性</li><li>GO111MODULE=auto：自动检测是否使用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  kubernetes git:(master) <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.12</span><span class="number">.7</span> darwin/amd64</span><br></pre></td></tr></table></figure><h5 id="1-3-项目体验"><a href="#1-3-项目体验" class="headerlink" title="1.3 项目体验"></a>1.3 项目体验</h5><h5 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h5><p>mod的初始化工作：</p><ul><li>创建项目目录，如项目：indagate，该目录需要在GOPATH之外</li><li>切换到项目目录，如<code>/Users/zoues/Code/indagate</code></li><li>执行初始化目录：<code>go mod init &lt;项目名称&gt;</code>，如 go mod init github.com/ustackq/indagate</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir indagate</span><br><span class="line">➜  cd indagate</span><br><span class="line">➜  <span class="keyword">go</span> mod init github.com/ustackq/indagate</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module github.com/ustackq/indagate</span><br><span class="line">➜  indagate ll</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-------  <span class="number">1</span> zoues  staff    <span class="number">25</span>B <span class="number">10</span> <span class="number">17</span> <span class="number">17</span>:<span class="number">00</span> <span class="keyword">go</span>.mod</span><br><span class="line">➜  indagate cat <span class="keyword">go</span>.mod</span><br><span class="line">module github.com/ustackq/indagate</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br></pre></td></tr></table></figure><p>使用init命令，会自动生成go.mod文件，在该文件中，存储项目的第三方包的依赖版本，需要注意的是，只有在run/test或者go mod tidy时，才会触发依赖解析，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  indagate git:(master) ✗ <span class="keyword">go</span> mod tidy</span><br><span class="line">➜ indagate git:(master) ✗ cat <span class="keyword">go</span>.mod</span><br><span class="line">module github.com/ustackq/indagate</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/coreos/<span class="keyword">go</span>-systemd v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190719114852</span>-fd7a80b32e1f</span><br><span class="line">  github.com/denisenkom/<span class="keyword">go</span>-mssqldb v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20191001013358</span>-cfbb681360f0</span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">➜  indagate git:(master) ✗ ls|grep <span class="keyword">go</span>.</span><br><span class="line"><span class="keyword">go</span>.mod</span><br><span class="line"><span class="keyword">go</span>.sum</span><br></pre></td></tr></table></figure><p>此时，可以发现上述目录多了go.sum文件，其用于记录每个包的版本及hash。go.mod 文件正常情况会包含 module 和 require 模块，除此之外还可以包含 replace 和 exclude等模块。</p><h5 id="上传代码仓库"><a href="#上传代码仓库" class="headerlink" title="上传代码仓库"></a>上传代码仓库</h5><p>然后上传代码至代码仓库，如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add *</span><br><span class="line">git commit -am <span class="string">"First commit"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>在上传完毕后，可以通过<code>go get -v github.com/ustackq/indagate</code>拉取进行测试，该命令获取的是master分支最新代码，这种方式不好之处就是无法对其进行版本管理。</p><p> 在构建项目时，可以为代码库添加tag：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>如果不打算维护小版本，可以简化成如下操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b v1</span><br><span class="line">git push -u origin v1</span><br></pre></td></tr></table></figure><h5 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h5><p>项目在v1.0.1上新增功能，并且在v1修复某一个bug，操作如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"Emphasize our friendliness"</span> testmod.<span class="keyword">go</span></span><br><span class="line">git tag v1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">git push --tags origin v1</span><br></pre></td></tr></table></figure><h5 id="依赖升级"><a href="#依赖升级" class="headerlink" title="依赖升级"></a>依赖升级</h5><p>golang提供包依赖查询命令，<code>go help list</code>，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  indagate git:(master) ✗ <span class="keyword">go</span> list -m -u all</span><br><span class="line"><span class="keyword">go</span>: finding github.com/<span class="keyword">go</span>-openapi/validate v0<span class="number">.19</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/gomail.v2 latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/modern-<span class="keyword">go</span>/concurrent latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/nfnt/resize latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/coreos/pkg latest</span><br><span class="line"><span class="keyword">go</span>: finding github.com/<span class="keyword">go</span>-openapi/runtime v0<span class="number">.19</span><span class="number">.7</span></span><br><span class="line"><span class="keyword">go</span>: finding golang.org/x/sync latest</span><br><span class="line"><span class="keyword">go</span>: finding gopkg.in/check.v1 latest</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>若需要升/降某个包时，可以执行 <code>go help get</code>，如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v &lt;包&gt;@&lt;版本号&gt;</span><br><span class="line"># 该处为将validate v0<span class="number">.19</span><span class="number">.4</span>降级到<span class="number">0.19</span><span class="number">.3</span></span><br><span class="line">➜  indagate git:(master) ✗ <span class="keyword">go</span> get -v github.com/<span class="keyword">go</span>-openapi/validate@v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">Fetching https:<span class="comment">//goproxy.io/github.com/go-openapi/validate/@v/list</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/validate</span><br><span class="line">➜  indagate git:(master) ✗ cat <span class="keyword">go</span>.sum|grep v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/jsonpointer v0<span class="number">.19</span><span class="number">.3</span> h1:gihV7YNZK1iK6Tgwwsxo2rJbD1GTbdm72325Bq8FI3w=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/jsonpointer v0<span class="number">.19</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/loads v0<span class="number">.19</span><span class="number">.3</span> h1:jwIoahqCmaA5OBoc/B+<span class="number">1</span>+Mu2L0Gr8xYQnbeyQEo/<span class="number">7</span>b0=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/loads v0<span class="number">.19</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:YVfqhUCdahYwR3f3iiwQLhicVRvLlU/WO5WPaZvcvSI=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span> h1:<span class="number">0</span>XRyw8kguri6Yw4SxhsQA/atC88yqrk0+G4YhI2wabc=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:FpwSN1ksY1eteniUU7X0N/BgJ7a4WvBFVA8Lj9mJglo=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/strfmt v0<span class="number">.19</span><span class="number">.3</span> h1:eRfyY5SkaNJCAwmmMcADjY31ow9+N7MCLW7oRkbsINA=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/strfmt v0<span class="number">.19</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:<span class="number">0</span>yX7dbo8mKIvc3XSKp7MNfxw4JytCfCD6+bY1AVL9LU=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/validate v0<span class="number">.19</span><span class="number">.3</span> h1:PAH/<span class="number">2</span>DylwWcIU1s0Y7k3yNmeAgWOcKrNE2Q7Ww/kCg4=</span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/validate v0<span class="number">.19</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:<span class="number">90</span>Vh6jjkTn+OT1Eefm0ZixWNFjhtOH7vS9k0lo6zwJo=</span><br><span class="line">➜  indagate git:(master) ✗ cat <span class="keyword">go</span>.mod|grep v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/loads v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/spec v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/strfmt v0<span class="number">.19</span><span class="number">.3</span></span><br><span class="line">github.com/<span class="keyword">go</span>-openapi/validate v0<span class="number">.19</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在 modules 模式开启和关闭的情况下，go get 的使用方式不是完全相同的。在 modules 模式开启的情况下，可以通过在 package 后面添加 @version 来表明要升级（降级）到某个版本。如果没有指明 version 的情况下，则默认先下载打了 tag 的 release 版本，比如 v0.4.5 或者 v1.2.3；如果没有 release 版本，则下载最新的 pre release 版本，比如 v0.0.1-pre1。如果还没有则下载最新的 commit。包的的tag需要遵循semver规范，否则modules 是无法管理的。version 的格式为 v(major).(minor).(patch) 即vX.Y.Z，更多信息可以参考参考链接 。</p></blockquote><p>此外，在 modules 开启的模式下，go get 还支持 version 模糊查询，比如&gt;v1.0.0表示大于v1.0.0的可使用版本；&lt; v1.12.0 表示小于 v1.12.0  版本下最近可用的版本。版本的比较规按照semver规范的各个字段来进行。</p><h5 id="vendor依赖"><a href="#vendor依赖" class="headerlink" title="vendor依赖"></a>vendor依赖</h5><p> Go 1.5 推出了 vendor 机制，go mod 也可以支持 vendor 机制，将依赖包拷贝到 vendor 目录。但是像一些 test case 里面的依赖包并不会拷贝的 vendor 目录中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  indagate git:(master) ✗ <span class="keyword">go</span> help mod vendor</span><br><span class="line">usage: <span class="keyword">go</span> mod vendor [-v]</span><br><span class="line"></span><br><span class="line">Vendor resets the main module<span class="string">'s vendor directory to include all packages</span></span><br><span class="line"><span class="string">needed to build and test all the main module'</span>s packages.</span><br><span class="line">It does not include test code <span class="keyword">for</span> vendored packages.</span><br><span class="line"></span><br><span class="line">The -v flag causes vendor to <span class="built_in">print</span> the names of vendored</span><br><span class="line">modules and packages to standard error.</span><br></pre></td></tr></table></figure><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>在处理完项目的初步功能，需要编译时，执行以下步骤</p><ul><li>清理不需要的依赖，下载所缺依赖：go mod tidy</li><li>使用依赖编译执行文件：go build -mod vendor main.go</li></ul><hr><h5 id="2-mod特性"><a href="#2-mod特性" class="headerlink" title="2 mod特性"></a>2 mod特性</h5><p>上面介绍了 go modules 的简单使用方法，但是 modules 的一些更高级的特性没有介绍，将在下面进行展开。</p><ol><li>GoProxy</li><li>Replace</li></ol><h6 id="GoProxy"><a href="#GoProxy" class="headerlink" title="GoProxy"></a>GoProxy</h6><p>proxy 顾名思义，代理服务器。众所周知，有些 Golang 的 package 在国内是无法直接 go get 的。在之前，我们解决这个问题，一般都是通过设置 http_proxy/https_proxy 来解决。GoProxy 相当于官方提供了一种 proxy 的方式让用户来进行包下载。要使用 GoProxy 只需要设置环境变量 GOPROXY 即可。目前公开的 GOPROXY 有：</p><ul><li>goproxy.io</li><li>goproxy.cn: 由七牛云提供，参考 github repo</li></ul><p>当然你也可以实现自己的 GoProxy 服务，比如项目中的依赖包含外部依赖和内部依赖的时候，那么只需要实现 module proxy protocal 协议即可。</p><p>值得注意的是，在最新 release 的 Go 1.13 版本中默认将 GOPROXY 设置为 <a href="https://proxy.golang.org" target="_blank" rel="noopener">https://proxy.golang.org</a>，这个对于国内的开发者是无法直接使用的。所以如果升级了 Go 1.13 版本一定要把 GOPROXY 手动改掉。</p><h6 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h6><p>replace 主要有以下典型应用：</p><ul><li>为了解决某些包发生改名的问题</li><li>解决包名不规范问题，如github.com/sirupsen/Logrus当初的不规范问题，现在已经改名为github.com/sirupsen/logrus</li><li>比如对于有些 golang.org/x/ 下面的包由于某些原因在国内是下载不了的，但是对应的包在 github 上面是有一份拷贝的，这个时候我们就可以将 go.mod 中的包进行 replace 操作</li></ul><p>比较典型的是kubernetes中go.mod 的replace使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">bitbucket.org/bertimus9/systemstat =&gt; bitbucket.org/bertimus9/systemstat v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180207000608</span><span class="number">-0</span>eeff89b0690</span><br><span class="line">  cloud.google.com/<span class="keyword">go</span> =&gt; cloud.google.com/<span class="keyword">go</span> v0<span class="number">.38</span><span class="number">.0</span></span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h6 id="SubCommand"><a href="#SubCommand" class="headerlink" title="SubCommand"></a>SubCommand</h6><p>modules 支持的 subcommand 如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  indagate git:(master) ✗ <span class="keyword">go</span> help mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support <span class="keyword">for</span> modules is built into all the <span class="keyword">go</span> commands,</span><br><span class="line">not just <span class="string">'go mod'</span>. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using <span class="string">'go get'</span>.</span><br><span class="line">See <span class="string">'go help modules'</span> <span class="keyword">for</span> an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> mod &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">download    download modules to local cache</span><br><span class="line">edit        edit <span class="keyword">go</span>.mod from tools or scripts</span><br><span class="line">graph       <span class="built_in">print</span> module requirement graph</span><br><span class="line">init        initialize <span class="built_in">new</span> module in current directory</span><br><span class="line">tidy        add missing and remove unused modules</span><br><span class="line">vendor      <span class="built_in">make</span> vendored <span class="built_in">copy</span> of dependencies</span><br><span class="line">verify      verify dependencies have expected content</span><br><span class="line">why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use <span class="string">"go help mod &lt;command&gt;"</span> <span class="keyword">for</span> more information about a command.</span><br></pre></td></tr></table></figure><p>对应解释如下：</p><ul><li>download: 下载 modules 到本地缓存</li><li>edit: 提供一种命令行交互修改 go.mod 的方式</li><li>graph: 将 module 的依赖图在命令行打印出来，其实并不是很直观</li><li>init: 初始化 modules，会生成一个 go.mod 文件</li><li>tidy: 清理 go.mod 中的依赖，会添加缺失的依赖，同时移除没有用到的依赖</li><li>vendor: 将依赖包打包拷贝到项目的 vendor 目录下，值得注意的是并不会将 test code 中的依赖包打包到 vendor 中。这种设计在社区也引起过几次争论，但是并没有达成一致。</li><li>verify: verify 用来检测依赖包自下载之后是否被改动过。</li><li>why: 解释为什么 package 或者 module 是需要，但是看上去解释的理由并不是非常的直观。</li></ul><hr><h5 id="4-社区动向"><a href="#4-社区动向" class="headerlink" title="4 社区动向"></a>4 社区动向</h5><p>上面在讨论 GoProxy 的时候提到了 Go 1.13 默认设置环境变量 GOPROXY 的值，除此之外 Go 1.13 对 modules 还有哪些值得注意的改动呢？</p><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>modules 在 Go 1.13 的版本下是默认开启的。</p><h6 id="私库"><a href="#私库" class="headerlink" title="私库"></a>私库</h6><p>前面也说到对于一些内部的 package，GoProxy 并不能很好的处理，Go 1.13 推出了 GOPRIVATE 机制。只需要设置这个环境变量，然后标识出哪些 package 是 private 的，那么对于这个 package 的处理将不会从 proxy 下载。GOPRIVATE 的值是一个以逗号分隔的列表，支持正则（正则语法遵守 Golang 的 包 path.Match）。下面是一个 GOPRIVATE 的示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=*.xxx.com,yy.zz/private</span><br></pre></td></tr></table></figure><h6 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h6><p>GOSUMDB 的全称为 Go CheckSum Database，用来下载的包的安全性校验问题。包的安全性在使用 GoProxy 之后更容易出现，比如我们引用了一个不安全的 GoProxy 之后然后下载了一个不安全的包，这个时候就出现了安全性问题。对于这种情况，可以通过 GOSUMDB 来对包的哈希值进行校验。当然如果想要关闭哈希校验，可以将 GOSUMDB 设置为 off；如果要对部分包关闭哈希校验，则可以将包的前缀设置到环境变量中 GONOSUMDB 中，设置规则类似 GOPRIVATE。</p><p>关于 GOSUMDB 的配置格式为：<code>&lt;db_name&gt;+&lt;publickey&gt;+&lt;url&gt;</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org+&lt;publickey&gt;"</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org+&lt;publickey&gt; https://sum.golang.org"</span></span><br></pre></td></tr></table></figure><p>上面三种配置都是合理的，因为对于 sum.golang.org，Go 自己知道其对应的 publickey 和 url，所以我们只要配置一个名字即可，对于另外一个 sum.golang.google.cn 也是一样。除此之外的，都需要指明 publickey，url 默认是 <code>https://&lt;db_name&gt;</code>。</p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>**请关注后续golang内置数据结构漫谈<br>Golang 包管理历经多个版本，目前来看并没有一个完全让开发者满意的方案，比如类似 Java 的 maven 的包管理方式。很多开发者也表示 modules 的管理方式也不是很直观。其实 Golang 的 package 使用 git 的管理方式来管理其实是一个很好的管理方式，我们最需要的其实如何能让普通开发者获取到任何 package 的心智负担降到最低。值得欣慰的是我们确实有看到大家在这个方向上的努力，比如 modules 的 GoProxy。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Modules-wiki]</a></li><li><a href="https://roberto.selbach.ca/playing-with-go-modules/" target="_blank" rel="noopener">playing-with-go-modules</a></li><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">introduce-go-modules</a></li><li><a href="https://roberto.selbach.ca/go-proxies/" target="_blank" rel="noopener">learning-go-proxy</a></li><li><a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">modules2019</a></li><li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">版本</a></li><li><a href="https://mp.weixin.qq.com/s/v-NdYEJBgKbiKsdoQaRsQg##" target="_blank" rel="noopener">golang不完全教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Go modules是Golang官方在1.11版本推出的包管理工具，在此之前，周边社区提供多种包管理方案，在讨论此类方案之前，可以先回顾一个golang关于包管理的发展。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mod简介及入门&lt;/li&gt;
&lt;li&gt;mod特性&lt;/li&gt;
&lt;li&gt;社区动向&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之channel妙法</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bchannel%E5%A6%99%E6%B3%95.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之channel妙法.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-10-04T12:48:21.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p><div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p><ul><li>channel介绍及范例</li><li>channel用法</li><li>channel使用场景</li><li>channel原理赏析</li></ul><p>下面在进入正题之前，简要介绍一下CSP模型：</p><blockquote><p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p></blockquote><a id="more"></a><hr><h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote><p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p></blockquote><ul><li><p>广播，如消费者/生产者模型</p></li><li><p>交换数据</p></li><li><p>并发控制</p></li><li><p>显示通知等</p></li></ul><p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p><h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p><p>2）先进先出：copying into and out of hchan buffer</p><p>3）channel的高性能所在：</p><ul><li>调用runtime scheduler实现，OS thread不需要阻塞；</li><li>跨goroutine栈可以直接进行读写；</li></ul><h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p><ul><li><p>无缓存channel</p><p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p></li><li><p>有缓存channel</p><p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p></li></ul><p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p><h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p><h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure><h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于channel的关闭，需要注意以下事项：</p><ul><li>关闭未初始化的channle(nil)会panic</li><li>重复关闭同一channel会panic</li><li>向以关闭channel发送消息会panic</li><li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li><li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><hr><h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure><h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select有以下特性：</p><ul><li>select可同时监听多个channel的读/写</li><li>执行select时，若只有一个case通过，则执行该case</li><li>若有多个，则随机执行一个case</li><li>若所有都不满足，则执行default，若无default，则等待</li><li>可使用break跳出select</li></ul><hr><h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><strong>hchan类型</strong></strong></p><p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p><ul><li>elemetype代表类型，用于数据传递过程中的赋值</li><li>elemesize代码类型大小，用于在buf中定位元素位置</li></ul><p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p><ul><li>dataqsiz指示队列长度为6，即可缓存6个元素</li><li>buf指向队列的内存，队列中还剩余两个元素</li><li>qcount表示队列中还有两个元素</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p><ul><li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li><li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li></ul><p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p><p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他一样，sudog也实现二级缓存复用结构。</p><p><code>runtime2.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p></blockquote><h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p><p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p><p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p><p>当执行recvq.dequeue()时，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p><h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p><ol><li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li><li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li></ol><p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p><blockquote><p>send 有以下几种情况：</p></blockquote><ul><li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li><li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li><li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向channel写入数据主要流程如下：<br><div class="note warning"><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li><li>释放channel的全局锁</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li></ol></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列</li><li>将当前goroutine休眠</li></ul></li></ul></div></p><h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p><ol><li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li><li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li><li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li><li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li></ol><p>简单流程图如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>接收channel的数据的流程如下：</p><ul><li><p>CASE1：前置channel为nil的场景：</p><ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p></li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p><ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p><ol><li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li><li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li><li>释放channel的全局锁</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li></ol></li></ul></li><li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p></li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li></ul></div><h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭的主要流程如下所示：</p><div class="note warning"><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul></div><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p><p>G1作用于底层<code>hchan</code>的流程如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后enqueue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>G2读取时作用于底层数据结构流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后dequeue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p><p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p><p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p><p>上图流程大致如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li><li>将M和G1绑定关系断开</li><li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p><p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p><p>整个过程如下所述：</p><ol><li>G2调用 t:=&lt;-ch 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer</li><li>goready(G2) 唤醒G2</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li><li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;channel介绍及范例&lt;/li&gt;
&lt;li&gt;channel用法&lt;/li&gt;
&lt;li&gt;channel使用场景&lt;/li&gt;
&lt;li&gt;channel原理赏析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面在进入正题之前，简要介绍一下CSP模型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之指针</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E6%8C%87%E9%92%88.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之指针.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-11-22T06:15:43.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p><div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p><ul><li>channel介绍及范例</li><li>channel用法</li><li>channel使用场景</li><li>channel原理赏析</li></ul><p>下面在进入正题之前，简要介绍一下CSP模型：</p><blockquote><p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p></blockquote><a id="more"></a><hr><h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote><p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p></blockquote><ul><li><p>广播，如消费者/生产者模型</p></li><li><p>交换数据</p></li><li><p>并发控制</p></li><li><p>显示通知等</p></li></ul><p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p><h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p><p>2）先进先出：copying into and out of hchan buffer</p><p>3）channel的高性能所在：</p><ul><li>调用runtime scheduler实现，OS thread不需要阻塞；</li><li>跨goroutine栈可以直接进行读写；</li></ul><h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p><ul><li><p>无缓存channel</p><p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p></li><li><p>有缓存channel</p><p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p></li></ul><p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p><h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p><h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure><h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于channel的关闭，需要注意以下事项：</p><ul><li>关闭未初始化的channle(nil)会panic</li><li>重复关闭同一channel会panic</li><li>向以关闭channel发送消息会panic</li><li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li><li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><hr><h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure><h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select有以下特性：</p><ul><li>select可同时监听多个channel的读/写</li><li>执行select时，若只有一个case通过，则执行该case</li><li>若有多个，则随机执行一个case</li><li>若所有都不满足，则执行default，若无default，则等待</li><li>可使用break跳出select</li></ul><hr><h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><strong>hchan类型</strong></strong></p><p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p><ul><li>elemetype代表类型，用于数据传递过程中的赋值</li><li>elemesize代码类型大小，用于在buf中定位元素位置</li></ul><p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p><ul><li>dataqsiz指示队列长度为6，即可缓存6个元素</li><li>buf指向队列的内存，队列中还剩余两个元素</li><li>qcount表示队列中还有两个元素</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p><ul><li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li><li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li></ul><p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p><p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他一样，sudog也实现二级缓存复用结构。</p><p><code>runtime2.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p></blockquote><h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p><p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p><p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p><p>当执行recvq.dequeue()时，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p><h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p><ol><li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li><li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li></ol><p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p><blockquote><p>send 有以下几种情况：</p></blockquote><ul><li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li><li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li><li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向channel写入数据主要流程如下：<br><div class="note warning"><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li><li>释放channel的全局锁</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li></ol></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列</li><li>将当前goroutine休眠</li></ul></li></ul></div></p><h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p><ol><li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li><li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li><li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li><li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li></ol><p>简单流程图如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>接收channel的数据的流程如下：</p><ul><li><p>CASE1：前置channel为nil的场景：</p><ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p></li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p><ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p><ol><li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li><li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li><li>释放channel的全局锁</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li></ol></li></ul></li><li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p></li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li></ul></div><h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭的主要流程如下所示：</p><div class="note warning"><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul></div><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p><p>G1作用于底层<code>hchan</code>的流程如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后enqueue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>G2读取时作用于底层数据结构流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后dequeue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p><p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p><p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p><p>上图流程大致如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li><li>将M和G1绑定关系断开</li><li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p><p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p><p>整个过程如下所述：</p><ol><li>G2调用 t:=&lt;-ch 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer</li><li>goready(G2) 唤醒G2</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li><li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;channel介绍及范例&lt;/li&gt;
&lt;li&gt;channel用法&lt;/li&gt;
&lt;li&gt;channel使用场景&lt;/li&gt;
&lt;li&gt;channel原理赏析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面在进入正题之前，简要介绍一下CSP模型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之切片</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E5%88%87%E7%89%87.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之切片.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-11-26T02:08:34.976Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p>切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。</p></div><p>切片的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为机遇数组实现，所以它的底层的内存是连续非配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化的好处。切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。我们在本文中有以下内容:</p><ul><li>切片介绍</li><li>切片用法</li><li>切片原理</li></ul><a id="more"></a><hr><h4 id="一、slice介绍"><a href="#一、slice介绍" class="headerlink" title="一、slice介绍"></a>一、slice介绍</h4><h5 id="1-1-声明和初始化"><a href="#1-1-声明和初始化" class="headerlink" title="1.1 声明和初始化"></a>1.1 声明和初始化</h5><p>切片创建的方式有好几种，我们先看下最简洁的make方式。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>使用内置的make函数时，需要传入一个参数，指定切片的长度，例子中我们使用的时5，这时候切片的容量也是5。当然我们也可以单独指定切片的容量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>这时，我们创建的切片长度是5，容量是10,需要注意的这个容量10其实对应的是切片底层数组的。</p><p>因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以指定了容量是10，但是我们职能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。</p><blockquote><p>容量必须&gt;=长度，我们是不能创建长度大于容量的切片的。</p></blockquote><p>还有一种创建切片的方式，是使用字面量，就是指定初始化的值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>有没有发现，是创建数组非常像，只不过不用制定[]中的值，这时候切片的长度和容量是相等的，并且会根据我们指定的字面量推导出来。当然我们也可以像数组一样，只初始化某个索引的值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>这是指定了第5个元素为1，其他元素都是默认值0。这时候切片的长度和容量也是一样的。这里再次强调一下切片和数组的微小差别。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line">array:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nil切片</span></span><br><span class="line"><span class="keyword">var</span> nilSlice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">//空切片</span></span><br><span class="line">slice:=[]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>nil切片表示不存在的切片，而空切片表示一个空集合，它们各有用处。切片另外一个用处比较多的创建是基于现有的数组或者切片创建。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice1 := slice[:]</span><br><span class="line">slice2 := slice[<span class="number">0</span>:]</span><br><span class="line">slice3 := slice[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(slice1)</span><br><span class="line">fmt.Println(slice2)</span><br><span class="line">fmt.Println(slice3)</span><br></pre></td></tr></table></figure><p>基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，她表示以<code>i</code>索引开始，到j索引结束,截取原数组或者切片，创建而成的新切片，新切片的值包含原切片的i索引，但是不包含j索引。对比Java的话，发现和String的subString方法很像。<code>i</code>如果省略，默认是0；<code>j</code>如果省略默认是原数组或者切片的长度,所以例子中的三个新切片的值是一样的。这里注意的是<code>i</code>和<code>j</code>都不能超过原切片或者数组的索引。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">newSlice[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Println(slice)</span><br><span class="line">fmt.Println(newSlice)</span><br></pre></td></tr></table></figure><p>这个例子证明了，新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变，所以原切片的值也改变了。当然对于基于数组的切片也一样的。<br>我们基于原数组或者切片创建一个新的切片后，那么新的切片的大小和容量是多少呢？这里有个公式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于底层数组容量是k的切片slice[i:j]来说</span><br><span class="line">长度：j-i</span><br><span class="line">容量:k-i</span><br></pre></td></tr></table></figure><p>比如我们上面的例子slice[1:3],长度就是3-1=2，容量是5-1=4。不过代码中我们计算的时候不用这么麻烦，因为Go语言为我们提供了内置的<code>len</code>和<code>cap</code>函数来计算切片的长度和容量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"newSlice长度:%d,容量:%d"</span>,<span class="built_in">len</span>(newSlice),<span class="built_in">cap</span>(newSlice))</span><br></pre></td></tr></table></figure><p>以上基于一个数组或者切片使用2个索引创建新切片的方法，此外还有一种3个索引的方法，第3个用来限定新切片的容量，其用法为slice[i:j:k]。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>这样我们就创建了一个长度为2-1=1，容量为3-1=2的新切片,不过第三个索引，不能超过原切片的最大索引值5。</p><hr><h4 id="二、slice的用法"><a href="#二、slice的用法" class="headerlink" title="二、slice的用法"></a>二、slice的用法</h4><h5 id="2-1-使用简介"><a href="#2-1-使用简介" class="headerlink" title="2.1 使用简介"></a>2.1 使用简介</h5><p>使用切片，和使用数组一样，通过索引就可以获取切片对应元素的值，同样也可以修改对应元素的值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice[<span class="number">2</span>]) <span class="comment">//获取值</span></span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">10</span> <span class="comment">//修改值</span></span><br><span class="line">fmt.Println(slice[<span class="number">2</span>]) <span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><blockquote><p>切片只能访问到其长度内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长</p></blockquote><p>我们前面讲了，切片算是一个动态数组，所以它可以按需增长，我们使用内置append函数即可。append函数可以为一个切片追加一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，append函数都会帮我们自动处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">newSlice=<span class="built_in">append</span>(newSlice,<span class="number">10</span>)</span><br><span class="line">fmt.Println(newSlice)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">10</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>例子中，通过append函数为新创建的切片newSlice,追加了一个元素10，我们发现打印的输出，原切片slice的第4个值也被改变了，变成了10。引起这种结果的原因是因为newSlice有可用的容量，不会创建新的切片来满足追加，所以直接在newSlice后追加了一个元素10，因为newSlice和slice切片共用一个底层数组，所以切片slice的对应的元素值也被改变了。</p><blockquote><p>这里newSlice新追加的第3个元素，其实对应的是slice的第4个元素，所以这里的追加其实是把底层数组的第4个元素修改为10，然后把newSlice长度调整为3。</p></blockquote><p>如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来数组的值复制到新底层数组里，再追加新值，这时候就不会影响原来的底层数组了。</p><blockquote><p>所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。</p></blockquote><p><code>append</code>函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。内置的<code>append</code>也是一个可变参数的函数，所以我们可以同时追加好几个值。<br><code>newSlice=append(newSlice,10,20,30)</code></p><p>此外，我们还可以通过…操作符，把一个切片追加到另一个切片里。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">newSlice=<span class="built_in">append</span>(newSlice,slice...)</span><br><span class="line">fmt.Println(newSlice)</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><h5 id="2-2-迭代切片"><a href="#2-2-迭代切片" class="headerlink" title="2.2 迭代切片"></a>2.2 迭代切片</h5><p>切片是一个集合，我们可以使用 for range 循环来迭代它，打印其中的每个元素以及对应的索引。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">  fmt.Printf(<span class="string">"索引:%d,值:%d\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不想要索引，可以使用_来忽略它，这是Go语言的用法，很多不需要的函数等返回值，都可以忽略。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">  fmt.Printf(<span class="string">"值:%d\n"</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是<code>range</code>返回的是切片元素的复制，而不是元素的引用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"值:%d\n"</span>, slice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-在函数间传递切片"><a href="#2-3-在函数间传递切片" class="headerlink" title="2.3 在函数间传递切片"></a>2.3 在函数间传递切片</h5><p>我们知道切片是3个字段构成的结构类型，所以在函数间以值的方式传递的时候，占用的内存非常小，成本很低。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice)</span><br><span class="line">  modify(slice)</span><br><span class="line">  fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice)</span><br><span class="line">  slice[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印的输出如下</span></span><br><span class="line"><span class="number">0xc420082060</span></span><br><span class="line"><span class="number">0xc420082080</span></span><br><span class="line">[<span class="number">1</span> <span class="number">10</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>仔细看，这两个切片的地址不一样，所以可以确认切片在函数间传递是复制的。而我们修改一个索引的值后，发现原切片的值也被修改了，说明它们共用一个底层数组。</p><p>在函数间传递切片非常高效，而且不需要传递指针和处理复杂的语法，只需要复制切片，然后根据自己的业务修改，最后传递回一个新的切片副本即可，这也是为什么函数间传递参数，使用切片，而不是数组的原因。</p><p>关于多维切片就不介绍了，还有多维数组，一来它和普通的切片数组一样，只不过是多个一维组成的多维；二来不推荐用多维切片和数组，可读性不好，结构不够清晰。</p><hr><h4 id="三、切片原理"><a href="#三、切片原理" class="headerlink" title="三、切片原理"></a>三、切片原理</h4><h5 id="3-1-切片结构体"><a href="#3-1-切片结构体" class="headerlink" title="3.1 切片结构体"></a>3.1 切片结构体</h5><p>SliceHeader是Slice运行时的具体表现，它的结构定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">uintptr</span></span><br><span class="line">  Len  <span class="keyword">int</span></span><br><span class="line">  Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正好对应Slice的三要素，Data指向具体的底层数据源数组，Len代表长度，Cap代表容量。既然Slice就是SliceHeader，那么我们把Slice转化为SliceHeader，来看看A和A1内部具体的字段值，这样来判断他们是否一致，我们修改Append方法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A Slice)</span><span class="title">Append</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  A1 := <span class="built_in">append</span>(A, value)</span><br><span class="line"></span><br><span class="line">  sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A))</span><br><span class="line">  fmt.Printf(<span class="string">"A Data:%d,Len:%d,Cap:%d\n"</span>,sh.Data,sh.Len,sh.Cap)</span><br><span class="line"></span><br><span class="line">  sh1:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A1))</span><br><span class="line">  fmt.Printf(<span class="string">"A1 Data:%d,Len:%d,Cap:%d\n"</span>,sh1.Data,sh1.Len,sh1.Cap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过unsafe.Pointer指针进行强制类型转换，都转换为*reflect.SliceHeader类型后，我们分别输出他们的Data、Len、Cap字段，现在我们看看输出的结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  Data:<span class="number">824634204160</span>,Len:<span class="number">10</span>,Cap:<span class="number">20</span></span><br><span class="line">A1 Data:<span class="number">824634204160</span>,Len:<span class="number">11</span>,Cap:<span class="number">20</span></span><br></pre></td></tr></table></figure><p>这下大家明白了吧，他们的Len不一样，并不是一个Slice，所以使用append方法并没有改变原来的A，而是新生成了一个A1，即使通过如下代码 A = append(A, value) 进行复制，也只是一个mSlice的拷贝A的指向被改变了，而且这个A只在Append方法内有效，mSlice本身并没有改变，所以输出的mSlice不会有任何变化。<br>这里正确的做法是让Append返回append后的结果。其实对于内置函数append的使用，Go语言(golang)官方做了说明的，要保存返回的值。</p><p>设置的Len是10，Cap是20，因为Cap足够大，所以内置函数append并没有生成新的底层数组，现在我们把Cap改为10。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A Slice)</span><span class="title">Append</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  A1 := <span class="built_in">append</span>(A, value)</span><br><span class="line"></span><br><span class="line">  sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A))</span><br><span class="line">  fmt.Printf(<span class="string">"A Data:%d,Len:%d,Cap:%d\n"</span>,sh.Data,sh.Len,sh.Cap)</span><br><span class="line"></span><br><span class="line">  sh1:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A1))</span><br><span class="line">  fmt.Printf(<span class="string">"A1 Data:%d,Len:%d,Cap:%d\n"</span>,sh1.Data,sh1.Len,sh1.Cap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mSlice := <span class="built_in">make</span>(Slice, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">  mSlice.Append(<span class="number">5</span>)</span><br><span class="line">  fmt.Println(mSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码我们会发现两个Slice的Data不再一样了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  Data:<span class="number">824633835680</span>,Len:<span class="number">10</span>,Cap:<span class="number">10</span></span><br><span class="line">A1 Data:<span class="number">824634204160</span>,Len:<span class="number">11</span>,Cap:<span class="number">20</span></span><br></pre></td></tr></table></figure><p>这是因为在append的时候，发现Cap不够，生成了一个新的Data数组，用于存储新的数据，并且同时扩充了Cap容量。</p><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.jianshu.com/p/030aba2bff41" target="_blank" rel="noopener">深入解析Go中Slice底层实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;切片的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为机遇数组实现，所以它的底层的内存是连续非配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化的好处。切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。我们在本文中有以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切片介绍&lt;/li&gt;
&lt;li&gt;切片用法&lt;/li&gt;
&lt;li&gt;切片原理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之接口</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之接口.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-11-22T06:15:18.412Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p><div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p><ul><li>channel介绍及范例</li><li>channel用法</li><li>channel使用场景</li><li>channel原理赏析</li></ul><p>下面在进入正题之前，简要介绍一下CSP模型：</p><blockquote><p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p></blockquote><a id="more"></a><hr><h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote><p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p></blockquote><ul><li><p>广播，如消费者/生产者模型</p></li><li><p>交换数据</p></li><li><p>并发控制</p></li><li><p>显示通知等</p></li></ul><p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p><h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p><p>2）先进先出：copying into and out of hchan buffer</p><p>3）channel的高性能所在：</p><ul><li>调用runtime scheduler实现，OS thread不需要阻塞；</li><li>跨goroutine栈可以直接进行读写；</li></ul><h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p><ul><li><p>无缓存channel</p><p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p></li><li><p>有缓存channel</p><p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p></li></ul><p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p><h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p><h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure><h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于channel的关闭，需要注意以下事项：</p><ul><li>关闭未初始化的channle(nil)会panic</li><li>重复关闭同一channel会panic</li><li>向以关闭channel发送消息会panic</li><li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li><li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><hr><h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure><h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select有以下特性：</p><ul><li>select可同时监听多个channel的读/写</li><li>执行select时，若只有一个case通过，则执行该case</li><li>若有多个，则随机执行一个case</li><li>若所有都不满足，则执行default，若无default，则等待</li><li>可使用break跳出select</li></ul><hr><h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><strong>hchan类型</strong></strong></p><p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p><ul><li>elemetype代表类型，用于数据传递过程中的赋值</li><li>elemesize代码类型大小，用于在buf中定位元素位置</li></ul><p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p><ul><li>dataqsiz指示队列长度为6，即可缓存6个元素</li><li>buf指向队列的内存，队列中还剩余两个元素</li><li>qcount表示队列中还有两个元素</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p><ul><li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li><li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li></ul><p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p><p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他一样，sudog也实现二级缓存复用结构。</p><p><code>runtime2.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p></blockquote><h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p><p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p><p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p><p>当执行recvq.dequeue()时，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p><h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p><ol><li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li><li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li></ol><p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p><blockquote><p>send 有以下几种情况：</p></blockquote><ul><li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li><li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li><li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向channel写入数据主要流程如下：<br><div class="note warning"><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li><li>释放channel的全局锁</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li></ol></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列</li><li>将当前goroutine休眠</li></ul></li></ul></div></p><h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p><ol><li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li><li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li><li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li><li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li></ol><p>简单流程图如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>接收channel的数据的流程如下：</p><ul><li><p>CASE1：前置channel为nil的场景：</p><ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p></li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p><ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p><ol><li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li><li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li><li>释放channel的全局锁</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li></ol></li></ul></li><li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p></li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li></ul></div><h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭的主要流程如下所示：</p><div class="note warning"><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul></div><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p><p>G1作用于底层<code>hchan</code>的流程如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后enqueue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>G2读取时作用于底层数据结构流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后dequeue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p><p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p><p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p><p>上图流程大致如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li><li>将M和G1绑定关系断开</li><li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p><p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p><p>整个过程如下所述：</p><ol><li>G2调用 t:=&lt;-ch 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer</li><li>goready(G2) 唤醒G2</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li><li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;channel介绍及范例&lt;/li&gt;
&lt;li&gt;channel用法&lt;/li&gt;
&lt;li&gt;channel使用场景&lt;/li&gt;
&lt;li&gt;channel原理赏析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面在进入正题之前，简要介绍一下CSP模型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之字符串</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之字符串.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-11-22T06:15:49.219Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p><div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p><ul><li>channel介绍及范例</li><li>channel用法</li><li>channel使用场景</li><li>channel原理赏析</li></ul><p>下面在进入正题之前，简要介绍一下CSP模型：</p><blockquote><p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p></blockquote><a id="more"></a><hr><h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote><p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p></blockquote><ul><li><p>广播，如消费者/生产者模型</p></li><li><p>交换数据</p></li><li><p>并发控制</p></li><li><p>显示通知等</p></li></ul><p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p><h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p><p>2）先进先出：copying into and out of hchan buffer</p><p>3）channel的高性能所在：</p><ul><li>调用runtime scheduler实现，OS thread不需要阻塞；</li><li>跨goroutine栈可以直接进行读写；</li></ul><h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p><ul><li><p>无缓存channel</p><p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p></li><li><p>有缓存channel</p><p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p></li></ul><p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p><h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p><h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure><h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于channel的关闭，需要注意以下事项：</p><ul><li>关闭未初始化的channle(nil)会panic</li><li>重复关闭同一channel会panic</li><li>向以关闭channel发送消息会panic</li><li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li><li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><hr><h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure><h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select有以下特性：</p><ul><li>select可同时监听多个channel的读/写</li><li>执行select时，若只有一个case通过，则执行该case</li><li>若有多个，则随机执行一个case</li><li>若所有都不满足，则执行default，若无default，则等待</li><li>可使用break跳出select</li></ul><hr><h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><strong>hchan类型</strong></strong></p><p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p><ul><li>elemetype代表类型，用于数据传递过程中的赋值</li><li>elemesize代码类型大小，用于在buf中定位元素位置</li></ul><p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p><ul><li>dataqsiz指示队列长度为6，即可缓存6个元素</li><li>buf指向队列的内存，队列中还剩余两个元素</li><li>qcount表示队列中还有两个元素</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p><ul><li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li><li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li></ul><p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p><p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他一样，sudog也实现二级缓存复用结构。</p><p><code>runtime2.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p></blockquote><h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p><p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p><p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p><p>当执行recvq.dequeue()时，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p><h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p><ol><li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li><li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li></ol><p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p><blockquote><p>send 有以下几种情况：</p></blockquote><ul><li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li><li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li><li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向channel写入数据主要流程如下：<br><div class="note warning"><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li><li>释放channel的全局锁</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li></ol></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列</li><li>将当前goroutine休眠</li></ul></li></ul></div></p><h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p><ol><li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li><li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li><li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li><li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li></ol><p>简单流程图如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>接收channel的数据的流程如下：</p><ul><li><p>CASE1：前置channel为nil的场景：</p><ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p></li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p><ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p><ol><li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li><li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li><li>释放channel的全局锁</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li></ol></li></ul></li><li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p></li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li></ul></div><h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭的主要流程如下所示：</p><div class="note warning"><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul></div><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p><p>G1作用于底层<code>hchan</code>的流程如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后enqueue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>G2读取时作用于底层数据结构流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后dequeue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p><p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p><p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p><p>上图流程大致如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li><li>将M和G1绑定关系断开</li><li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p><p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p><p>整个过程如下所述：</p><ol><li>G2调用 t:=&lt;-ch 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer</li><li>goready(G2) 唤醒G2</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li><li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;channel介绍及范例&lt;/li&gt;
&lt;li&gt;channel用法&lt;/li&gt;
&lt;li&gt;channel使用场景&lt;/li&gt;
&lt;li&gt;channel原理赏析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面在进入正题之前，简要介绍一下CSP模型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之反射</title>
    <link href="https://ustack.io/2019-10-04-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E5%8F%8D%E5%B0%84.html"/>
    <id>https://ustack.io/2019-10-04-Golang漫谈之反射.html</id>
    <published>2019-10-04T12:40:08.000Z</published>
    <updated>2019-11-22T06:15:11.038Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg" alt></p><div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:</p><ul><li>channel介绍及范例</li><li>channel用法</li><li>channel使用场景</li><li>channel原理赏析</li></ul><p>下面在进入正题之前，简要介绍一下CSP模型：</p><blockquote><p>传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。</p></blockquote><a id="more"></a><hr><h4 id="一、channel介绍及范例"><a href="#一、channel介绍及范例" class="headerlink" title="一、channel介绍及范例"></a>一、channel介绍及范例</h4><blockquote><p>如上所言，channel 提供了一种通信机制，其为gouroutine之间的通信提供了一种可能，执行体拷贝数据，channel负责传递，有以下应用场景:</p></blockquote><ul><li><p>广播，如消费者/生产者模型</p></li><li><p>交换数据</p></li><li><p>并发控制</p></li><li><p>显示通知等</p></li></ul><p>Golang鼓励使用通讯来实现数据共享，而不是经由内存。</p><h5 id="1-1-channel特性"><a href="#1-1-channel特性" class="headerlink" title="1.1 channel特性"></a>1.1 channel特性</h5><p>1）线程安全：hchan mutex</p><p>2）先进先出：copying into and out of hchan buffer</p><p>3）channel的高性能所在：</p><ul><li>调用runtime scheduler实现，OS thread不需要阻塞；</li><li>跨goroutine栈可以直接进行读写；</li></ul><h5 id="1-2-channel类型"><a href="#1-2-channel类型" class="headerlink" title="1.2 channel类型"></a>1.2 channel类型</h5><p>channel分为非缓存channel与缓存channel。</p><ul><li><p>无缓存channel</p><p>  从无缓存的channel中读取消息会堵塞，直到有goroutine往channel中发送消息；同理，向无缓存的channel中发送消息也会堵塞，直到有goroutine从channel中读取消息。</p></li><li><p>有缓存channel</p><p>  有缓存channel的声明方式为指定make函数的第二个参数，该参数为channel缓存的容量。<br>通过内置len函数可获取chan元素个数，通过cap函数可获取chan的缓存长度</p></li></ul><p><strong>单项channel</strong> :单向channel为只读/只写channel，单向channel，在编译时，可进行检测。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSingal</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span> &lt;- <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义工作逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 chan&lt;- int表示只写channel, &lt;-chan int表示只读channel，此类函数/方法声明可防止channel滥用，在编译时可以检测出。</p><h5 id="1-3-channel创建"><a href="#1-3-channel创建" class="headerlink" title="1.3 channel创建"></a>1.3 channel创建</h5><p>channel使用内置的make函数创建，如下，声明类型为int的channel：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非缓存channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 缓存channel</span></span><br><span class="line">bch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>channel和map类似，make创建了底层数据结构的引用，当赋值或参数传递时，只是拷贝了一个channel的引用，其指向同一channel对象，与其引用类型一样，channel的空值也为nil。使用<code>==</code>可以对类型相同的channel进行比较，只有指向相同对象或同为nil时，结果为true。</p><h5 id="1-4-channel的读写操作"><a href="#1-4-channel的读写操作" class="headerlink" title="1.4 channel的读写操作"></a>1.4 channel的读写操作</h5><p>channel在使用前，需要初始化，否则永远阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">y &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">z := &lt;- ch</span><br></pre></td></tr></table></figure><h5 id="1-5-channel的关闭"><a href="#1-5-channel的关闭" class="headerlink" title="1.5 channel的关闭"></a>1.5 channel的关闭</h5><p>golang提供了内置的close函数，对channel进行关闭操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 关闭channel ch</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于channel的关闭，需要注意以下事项：</p><ul><li>关闭未初始化的channle(nil)会panic</li><li>重复关闭同一channel会panic</li><li>向以关闭channel发送消息会panic</li><li>从已关闭channel读取数据，不会panic，若存在数据，则可以读出未被读取的消息，若已被读出，则获取的数据为零值，可以通过ok-idiom的方式，判断channel是否关闭</li><li>channel的关闭操作，会产生广播消息，所有向channel读取消息的goroutine都会接受到消息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import fmt</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 初始化channel</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    // 发送消息</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    <span class="comment"># 关闭channel</span></span><br><span class="line">    close(ch)</span><br><span class="line">    // 循环读取</span><br><span class="line">    <span class="keyword">for</span> c := range ch &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-6-两类channel"><a href="#1-6-两类channel" class="headerlink" title="1.6 两类channel"></a>1.6 两类channel</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有缓存的channel使用环形数组实现，当缓存未满时，向channel发送消息不会阻塞，当缓存满时，发送操作会阻塞，直到其他goroutine从channel中读取消息；同理，当channel中消息不为空时，读取消息不会阻塞，当channel为空时，读取操作会阻塞，直至其他goroutine向channel发送消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 阻塞，因channel ch为空</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 阻塞，因缓存已满</span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">&lt;- ch</span><br></pre></td></tr></table></figure><hr><h4 id="二、channel的用法"><a href="#二、channel的用法" class="headerlink" title="二、channel的用法"></a>二、channel的用法</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>看下面《effctive go》中的例子：<br>主goroutine会阻塞，直至执行sort的goroutine完成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"># 使用goroutine执行list.Sort(),完毕后，发送信号</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  list.Sort()</span><br><span class="line">  c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 处理其他事务</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// 读取chan消息</span></span><br><span class="line">&lt;-c</span><br></pre></td></tr></table></figure><h5 id="2-2-range遍历"><a href="#2-2-range遍历" class="headerlink" title="2.2 range遍历"></a>2.2 range遍历</h5><p>channel也可以使用range取值，并且会一直从chanel中读取数据，直至goroutine关闭该channel，循环才会结束，如下所示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  i, ok := &lt;- ch</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-配合select使用"><a href="#2-3-配合select使用" class="headerlink" title="2.3 配合select使用"></a>2.3 配合select使用</h5><p>select用法类似IO多路复用，可同时监听多个channel的消息，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- a;</span><br><span class="line">      fmt.Println(<span class="string">"testa"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- b;</span><br><span class="line">      fmt.Println(<span class="string">"testb"</span>)</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">3</span>;</span><br><span class="line">      fmt.Println(<span class="string">"testc"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"testdefault"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select有以下特性：</p><ul><li>select可同时监听多个channel的读/写</li><li>执行select时，若只有一个case通过，则执行该case</li><li>若有多个，则随机执行一个case</li><li>若所有都不满足，则执行default，若无default，则等待</li><li>可使用break跳出select</li></ul><hr><h4 id="三、channel使用场景"><a href="#三、channel使用场景" class="headerlink" title="三、channel使用场景"></a>三、channel使用场景</h4><h5 id="3-1-设置超时时间"><a href="#3-1-设置超时时间" class="headerlink" title="3.1 设置超时时间"></a>3.1 设置超时时间</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化channel，数据类型为struct&#123;&#125;</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 以goroutine方式处理func</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line"> <span class="comment">// 传递ch，控制goroutine</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">1</span> * time.Sencond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">      fmt.Printfln(<span class="string">"任务完成."</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">      fmt.Printfln(<span class="string">"时间已到."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-控制channel"><a href="#3-2-控制channel" class="headerlink" title="3.2 控制channel"></a>3.2 控制channel</h5><p>在某些应用场景，工作goroutine一直处理事务，直到收到退出信号</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- mch:</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">        work()</span><br><span class="line">    <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">        <span class="comment">// 退出前，处理收尾工作</span></span><br><span class="line">        doFinish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="四、channel原理赏析"><a href="#四、channel原理赏析" class="headerlink" title="四、channel原理赏析"></a>四、channel原理赏析</h4><h5 id="4-1-channel结构体"><a href="#4-1-channel结构体" class="headerlink" title="4.1 channel结构体"></a>4.1 channel结构体</h5><p>以下源码基于<code>go 1.13.1</code>，其主要实现在<code>src/runtime/chan.go</code>中，在介绍源码前，需要介绍channel最主要的结构体<code>hchan</code>，其定义如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="keyword">uint</span>            <span class="comment">// 当前队列中剩余元素个数，即len</span></span><br><span class="line">  dataqsiz <span class="keyword">uint</span>            <span class="comment">// 环形队列长度，即可以存放的元素个数，cap</span></span><br><span class="line">  buf      unsafe.Pointer  <span class="comment">// 环形队列指针：队列缓存，头指针，环形数组实现</span></span><br><span class="line">  elemsize <span class="keyword">uint16</span>          <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="keyword">uint32</span>          <span class="comment">// 关闭标志位</span></span><br><span class="line">  elemtype *_type          <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="keyword">uint</span>            <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq           <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq           <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lock mutex              <span class="comment">// 该锁保护hchan所有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sending/receiving等待队列的链表实现</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">  first *sudog</span><br><span class="line">  last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><strong>hchan类型</strong></strong></p><p>一个channel只能传递一种类型的值，类型信息存储在<code>hchan</code>数据结构体中，<code>_type</code>结构体中包含<code>elemtype</code>及<code>elemsize</code>等。</p><ul><li>elemetype代表类型，用于数据传递过程中的赋值</li><li>elemesize代码类型大小，用于在buf中定位元素位置</li></ul><p><strong><strong>hchan环形队列</strong></strong><br>hchan内部实现了一个环形队列作为缓冲区，队列的长度是创建channel时指定的。下图展示了一个可缓存6个元素的channel的示意图：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0QEP1.png" alt="buf"></p><ul><li>dataqsiz指示队列长度为6，即可缓存6个元素</li><li>buf指向队列的内存，队列中还剩余两个元素</li><li>qcount表示队列中还有两个元素</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><p><strong><strong>hchan等待队列</strong></strong><br>从channel读消息，如果channel缓冲区为空或者没有缓存区，当前goroutine会被阻塞。<br>向channel读消息，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会封装成sudog，加入到channel的等待队列中：</p><ul><li>因读消息阻塞的goroutine会被channel向channel写入数据的goroutine唤醒</li><li>因写消息阻塞的goroutine会从channel读消息的goroutine唤醒</li></ul><p><img src="https://s2.ax1x.com/2019/10/03/u0lo7Q.png" alt="waitq"></p><p>  一般情况下，recvq和sendq至少一个为空，只有一个例外，即同一个goroutine使用select语句向channel一边写数据，一个读数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog将*g封装到等待链表中</span></span><br><span class="line"><span class="comment">//（M）sudogs &lt;-&gt; (N) g</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">  <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">  <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">  g *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">  <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">  isSelect <span class="keyword">bool</span></span><br><span class="line">  next     *sudog</span><br><span class="line">  prev     *sudog</span><br><span class="line">  elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">  <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">  <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">  <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">  acquiretime <span class="keyword">int64</span></span><br><span class="line">  releasetime <span class="keyword">int64</span></span><br><span class="line">  ticket      <span class="keyword">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他一样，sudog也实现二级缓存复用结构。</p><p><code>runtime2.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// proceresice new(p)时指向sudogbuf</span></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前m</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果当前p为空</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">    <span class="comment">// 从全局转移一批到当前p</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">      s := sched.sudogcache</span><br><span class="line">      sched.sudogcache = s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="comment">// 如果还为空，则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">      pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从尾部获取，同时调整p的缓存</span></span><br><span class="line">  n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">  s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">  pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">  pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(mp)</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 判断结构体是否为空</span></span><br><span class="line">  <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil elem"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-false isSelect"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil next"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil prev"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil waitlink"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: sudog with non-nil c"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp := getg()</span><br><span class="line">  <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"runtime: releaseSudog with non-nil gp.param"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">  pp := mp.p.ptr()</span><br><span class="line">  <span class="comment">// 如果p已满，则转移到全局</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">    <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">    <span class="keyword">var</span> first, last *sudog</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">      n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">      p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">      pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">        first = p</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = p</span><br><span class="line">      &#125;</span><br><span class="line">      last = p</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    last.next = sched.sudogcache</span><br><span class="line">    sched.sudogcache = first</span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sched.sudogcache 缓存会在垃圾回收执行 clearpools 时被清理，但 P 本地缓存会被保留。</p></blockquote><h5 id="4-2-channel-make实现"><a href="#4-2-channel-make实现" class="headerlink" title="4.2 channel make实现"></a>4.2 channel make实现</h5><p>创建channel的过程实际上是初始化<code>hchan</code>结构，其中类型信息和缓存区长度有<code>makechan</code>传入，buf的大小则与元素大小和缓冲区长度共同决定，创建<code>hchan</code>的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  _type</span><br><span class="line">  elem *_type</span><br><span class="line">  dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">  // 对于chantype暂时不做深究，只需了解上述结构体即可</span><br><span class="line">  elem := t.elem</span><br><span class="line"></span><br><span class="line">  // 数据项的大小是编译时检测，需要小于 64KB</span><br><span class="line">  if elem.size &gt;= 1&lt;&lt;16 &#123;</span><br><span class="line">     throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // maxAlign = 8</span><br><span class="line">  if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">     throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存大小检测</span><br><span class="line">  // 计算要分配的堆内存的大小，并返回是否溢出。</span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">  // 其中maxAlloc在 runtime/malloc.go 217行</span><br><span class="line">  if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">    panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Hchan does not contain pointers interesting for GC</span><br><span class="line">  // when elements stored in buf do not contain pointers.</span><br><span class="line">  // buf points into the same allocation, elemtype is persistent.</span><br><span class="line">  // SudoG&apos;s are referenced from their owning thread so they can&apos;t be collected.</span><br><span class="line">  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="line">  var c *hchan</span><br><span class="line">  switch &#123;</span><br><span class="line">  case mem == 0:</span><br><span class="line">    // Queue or element size is zero.</span><br><span class="line">    // 队列或数据项大小为0</span><br><span class="line">    // 其中mallocgc函数，后续在内存分配进行讲解</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">    // Race detector uses this location for synchronization.</span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  case elem.ptrdata == 0:</span><br><span class="line">    // Elements do not contain pointers.</span><br><span class="line">    // Allocate hchan and buf in one call.</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  default:</span><br><span class="line">    // Elements contain pointers.</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.elemsize = uint16(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = uint(size)</span><br><span class="line"></span><br><span class="line">  if debugChan &#123;</span><br><span class="line">    print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hchan初始化过程，主要关注点就是switch的三类情况，若不含指针，那么buf与hchan为连续空间，当使用make区创建channel时，实际返回的时一个指向channel的指针，因此<br>可以在不同的functio之间直接传递channel对象，而不用通过指向channel的指针，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDMTbD.png" alt="make"></p><p><strong><strong>缓存channel</strong></strong><br>buffered channel底层数据模型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYbJe.md.png" alt="buffered"></p><p>当我们向channel里面写入消息时，会直接将消息写入buf，当环形队列buf存满后，会呈现下图状态：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYLzd.md.png" alt="full"></p><p>当执行recvq.dequeue()时，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBYXQA.md.png" alt="recvq.dequeue"></p><h5 id="channel发送"><a href="#channel发送" class="headerlink" title="channel发送"></a>channel发送</h5><p>向一个channel中发送数据的过程，如下简单所述：</p><ol><li>如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后将G唤醒，结束发送过程</li><li>如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒</li></ol><p>简单流程图如下：<br><img src="https://s2.ax1x.com/2019/10/03/u08ctJ.png" alt="send"></p><blockquote><p>send 有以下几种情况：</p></blockquote><ul><li>有goroutine阻塞在channel recv队列时，此时缓存队列为空，则直接将消息发送给reciver gourotine，只产生一次copy</li><li>当channel环境队列有剩余时间时，将数据放到队列里，等待接收，接收过程总共产生两次复制</li><li>当channel环境队列已满时，将当前goutoutine加入send队列并阻塞</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 若hchan未初始化，且block为false，则永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// gopark 与gounpark对应</span></span><br><span class="line">        <span class="comment">// gopark会让当前goroutine休眠，可通过unlockf唤醒，但传递的unlockf为nil</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">    <span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">    <span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">    <span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">    <span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">    <span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">    <span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">    <span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">    <span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测通过再请求锁，比较锁很费时</span></span><br><span class="line">    <span class="comment">// 是否阻塞 &amp;&amp; 未关闭 &amp;&amp; （ch的数据项长度为0且接受队列为空）|| (ch的数据项长度大于0且此时队列已满)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: 接受队列不为空，跳过缓存队列，直接send</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B: 接受队列未空，且channel缓存未满，则复制到缓存</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受队列未空，且channel缓存已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: 缓存已满，将goroutine加入到send队列</span></span><br><span class="line">    <span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// acquireSudog 该函数获取当前sudog</span></span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// sudog相关赋值</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将sudog加入到send队列</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向channel写入数据主要流程如下：<br><div class="note warning"><ul><li>CASE1：当channel为空或者未初始化，如果block表示阻塞那么向其中发送数据将会永久阻塞；如果block表示非阻塞就会直接return</li><li>CASE2：前置场景，block为非阻塞，且channel没有关闭(已关闭的channel不能写入数据)且(channel为非缓冲队列且receiver等待队列为空)或则( channel为有缓冲队列但是队列已满)，这个时候直接return</li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁</li><li>CASE3：不能向已经关闭的channel send数据，会导致panic</li><li>CASE4：如果channel上的recv队列非空，则跳过channel的缓存队列，直接向消息发送给接收的goroutine<ol><li>调用sendDirect方法，将待写入的消息发送给接收的goroutine</li><li>释放channel的全局锁</li><li>调用goready函数，将接收消息的goroutine设置成就绪状态，等待调度</li></ol></li><li>CASE5：缓存队列未满，则将消息复制到缓存队列上，然后释放全局锁</li><li>CASE6：缓存队列已满且接收消息队列recv为空，则将当前的goroutine加入到send队列<ul><li>获取当前goroutine的sudog，然后入channel的send队列</li><li>将当前goroutine休眠</li></ul></li></ul></div></p><h5 id="channel接受"><a href="#channel接受" class="headerlink" title="channel接受"></a>channel接受</h5><p>从一个channel读数据简单过程如下：</p><ol><li>没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程</li><li>有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程</li><li>如果缓冲区有数据，则从缓冲区读数据，结束读取过程</li><li>将当前goroutine加入recvq，进入睡眠，等待背斜goroutine唤醒</li></ol><p>简单流程图如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/03/u0YekF.png" alt="recvq"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">    <span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil channel接收消息，永久阻塞</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">    <span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">    <span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">    <span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">    <span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">    <span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">    <span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">    <span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">       c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">    t0 = cputicks()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// A: channel已经close且为空，则接收到的消息为空值</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// B: 发送队列不为空</span></span><br><span class="line">  <span class="comment">// 则直接从sender recv消息</span></span><br><span class="line">  <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// C: 缓存队列不为空，直接从队列取消息，移动头索引</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquire(qp)</span><br><span class="line">      racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">      c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// D: 缓存队列为空，将goroutine加入recv队列，并阻塞</span></span><br><span class="line">  <span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  gp := getg()</span><br><span class="line">  mysg := acquireSudog()</span><br><span class="line">  mysg.releasetime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">  <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">  mysg.elem = ep</span><br><span class="line">  mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">  gp.waiting = mysg</span><br><span class="line">  mysg.g = gp</span><br><span class="line">  mysg.isSelect = <span class="literal">false</span></span><br><span class="line">  mysg.c = c</span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  c.recvq.enqueue(mysg)</span><br><span class="line">  goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// someone woke us up</span></span><br><span class="line">  <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">    throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  gp.waiting = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  closed := gp.param == <span class="literal">nil</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  mysg.c = <span class="literal">nil</span></span><br><span class="line">  releaseSudog(mysg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>接收channel的数据的流程如下：</p><ul><li><p>CASE1：前置channel为nil的场景：</p><ul><li>如果block为非阻塞，直接return；</li><li>如果block为阻塞，就调用gopark()阻塞当前goroutine，并抛出异常。</li></ul></li><li><p>前置场景，block为非阻塞，且channel为非缓冲队列且sender等待队列为空 或则 channel为有缓冲队列但是队列里面元素数量为0，且channel未关闭，这个时候直接return；</p></li><li>调用 lock(&amp;c.lock) 锁住channel的全局锁；</li><li>CASE2：channel已经被关闭且channel缓冲中没有数据了，这时直接返回success和空值；</li><li><p>CASE3：sender队列非空，调用func recv(c <em>hchan, sg </em>sudog, ep unsafe.Pointer, unlockf func(), skip int) 函数处理：</p><ul><li>channel是非缓冲channel，直接调用recvDirect函数直接从sender recv元素到ep对象，这样就只用复制一次；</li><li><p>对于sender队列非空情况下， 有缓冲的channel的缓冲队列一定是满的：</p><ol><li>先取channel缓冲队列的对头元素复制给receiver(也就是ep)</li><li>将sender队列的对头元素里面的数据复制到channel缓冲队列刚刚弹出的元素的位置，这样缓冲队列就不用移动数据了</li><li>释放channel的全局锁</li><li>调用goready函数标记当前goroutine处于ready，可以运行的状态</li></ol></li></ul></li><li><p>CASE4：sender队列为空，缓冲队列非空，直接取队列元素，移动头索引</p></li><li>CASE5：sender队列为空、缓冲队列也没有元素且不阻塞协程，直接return (false,false)</li><li>CASE6：sender队列为空且channel的缓存队列为空，将goroutine加入recv队列，并阻塞</li></ul></div><h5 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h5><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。<br>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 关闭closed channel，panic</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">    racerelease(c.raceaddr())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置关闭标志位</span></span><br><span class="line">  c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all readers</span></span><br><span class="line">  <span class="comment">// 唤醒所有receiver</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">      typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">      sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 唤醒所有sender</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">      raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭的主要流程如下所示：</p><div class="note warning"><ul><li>获取全局锁；</li><li>设置channel数据结构chan的关闭标志位；</li><li>获取当前channel上面的读goroutine并链接成链表；</li><li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li><li>释放全局锁；</li><li>唤醒所有的读写goroutine。</li></ul></div><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>下面对channel的逻辑，做一个整体分析：<br>不同goroutine在channel上面读写时，G1往channel中写入数据，G2从channel中读取数据，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/03/u0zM8I.md.png" alt="channel"></p><p>G1作用于底层<code>hchan</code>的流程如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uB5B9g.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后enqueue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>G2读取时作用于底层数据结构流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBzUh9.png" alt="hchan"></p><ol><li>先获取全局锁</li><li>然后dequeue元素(通过移动拷贝的方式)</li><li>释放锁</li></ol><p>当channel写入3个数据之后，队列已满，这时候G1再写入时，G1会暂停等待receiver出现。</p><p><img src="https://s2.ax1x.com/2019/10/04/uBLZTA.png" alt="hchan"></p><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图(goroutine原理，请关注后续章节):</p><p><img src="https://s2.ax1x.com/2019/10/04/uDSMUe.png" alt="scheduler"></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtime检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。调度器完整的处理逻辑如下所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDCHrq.png" alt="scheduler"></p><p>上图流程大致如下：</p><ol><li>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态</li><li>将M和G1绑定关系断开</li><li>heduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G</li></ol><p>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。<br>那么blocked的G1怎么恢复呢？当有一个receiver接收channel数据的时候，会恢复 G1。</p><p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDiF6s.png" alt="hchan"></p><p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行ch&lt;-task4的时候，<br>G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDif3Q.png" alt="hchan"></p><p>此时，<strong>若G1进行一个读取channel操作</strong>，变化如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDkuQJ.png" alt="hchan"></p><p>整个过程如下所述：</p><ol><li>G2调用 t:=&lt;-ch 获取一个元素；</li><li>从channel的buffer里面取出一个元素task1；</li><li>从sender等待队列里面pop一个sudog；</li><li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li><li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li></ol><p>此时将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDAgN6.png" alt="hchan"></p><ol><li>首先G2会调用goready(G1)，唤起scheduler的调度；</li><li>将G1设置成Runable状态；</li><li>G1会加入到局部调度器P的local queue队列，等待运行。</li></ol><h6 id="读取空channel"><a href="#读取空channel" class="headerlink" title="读取空channel"></a>读取空channel</h6><p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDeSDH.png" alt="hchan"></p><p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。<br>这个时候，如果有一个G1执行读取操作，最直观的流程就是：</p><ol><li>将recvq中的task存入buffer</li><li>goready(G2) 唤醒G2</li></ol><p>但是我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲,如下图：</p><p><img src="https://s2.ax1x.com/2019/10/04/uDm9QU.png" alt="hchan"></p><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>针对select相关内容，将会在后续推出</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi" target="_blank" rel="noopener">understanding-channels-doc</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels" target="_blank" rel="noopener">understanding-channels-ppt</a></li><li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">Concurrency is not Parallelism</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u1f2UU.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;channel是Golang提供的goroutine间的通信方式，其为Golang并发模型CSP的关键，Golang鼓励用通讯实现数据共享，如果需要跨进程通信，建议使用分布式方案或者消息队列来解决。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;channel介绍及范例&lt;/li&gt;
&lt;li&gt;channel用法&lt;/li&gt;
&lt;li&gt;channel使用场景&lt;/li&gt;
&lt;li&gt;channel原理赏析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面在进入正题之前，简要介绍一下CSP模型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统并发模型分为Actor模型与CSP模型，其中CSP全称为Communicating Sequential Processess，CSP模型有并发执行体(进程、线程、协程)，和消息通道组成，执行体之间通过消息通道进行通讯，CSP模型关注消息发送的载体，即消息管道，而Actor关注的是内部的状态，那么Golang中执行体对应的是goroutine，消息通道对应的是channel。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
</feed>
