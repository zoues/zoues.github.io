<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Indagate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ustack.io/"/>
  <updated>2020-05-27T14:15:32.484Z</updated>
  <id>https://ustack.io/</id>
  
  <author>
    <name>zouyee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Operators和Sidecars成为软件交付新模式</title>
    <link href="https://ustack.io/2020-05-25-Operators%E5%8F%8ASidecars%E6%88%90%E4%B8%BA%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98%E6%96%B0%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://ustack.io/2020-05-25-Operators及Sidecars成为软件交付新模式.html</id>
    <published>2020-05-25T12:40:08.000Z</published>
    <updated>2020-05-27T14:15:32.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/23/Yxdj1A.md.jpg" alt></p><div class="note info"><p>现如今的开发人员希望可以开发出具备弹性和可扩展的分布式系统。 该系统受益于软件复用和开源模型创新，针对安全性问题能够轻易完成补丁更新并进行低风险的升级。<br>该系统不可能通过带有各种嵌入式语言库的应用程序框架来实现。</p><p>最近，一篇关于“多运行时微服务体系结构”的文章，其中探讨了分布式系统的需求，例如生命周期管理，高级网络，资源绑定，状态抽象以及这些抽象概念多年来的变化。<br>在以Kubernetes为中心的分布式系统的发展过程中，形成了以Kubernetes Operators和sidecar作为分布式系统交付的主要创新机制。</p></div><p>基于Kubernetes构建的软件应用，其架构的发展正朝着Kubernetes Operators和sidecar模型发展。 Kubernetes Operators和sidecar可能会成为主流<br>的软件分发和消费方式，在极端情况下甚至会像我们过去那样取代软件库和框架。Sidecar模型允许以不同语言编写的应用程序组合完成交付，而无需与运行时捆绑。<br>接下来让我们看一下Kubernetes Operators和sidecar的一些具体示例，然后我们将探索这种新的模型如何影响我们后续的开发模式。<br><a id="more"></a></p><hr><h3 id="一、智能化进程外延"><a href="#一、智能化进程外延" class="headerlink" title="一、智能化进程外延"></a>一、智能化进程外延</h3><blockquote><p>在Kubernetes中，sidecar是通过在单个Pod中组织多个容器而实现的核心设计模式之一。 Pod功能可确保将容器与指定节点绑定，并通过网络，文件<br>系统或其他IPC来进行协作。 并且Operator可以将sidecar与平台的其余部分进行自动化管理和集成。 sidecar代表了语言无关性，可扩展的数据平面，为定<br>制应用程序提供了分布式原语。 Operator代表了集中化管理和控制平面。</p></blockquote><p>  让我们看一下基于Sidecar模型的一些流行的开源项目。</p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>Istio，Consul等服务网格使用诸如Envoy之类的透明服务代理为分布式系统提供增强型联网功能。 Envoy具备高安全性、高级流量管理、弹性、深度监控和跟踪特性。<br>不仅如此，它支持越来越多的七层协议产品，例如Redis，MongoDB，MySQL和Kafka。 它增加了响应缓存功能，甚至还支持WebAssembly，这些功能将支<br>持各种自定义插件。 Envoy是透明服务代理如何将高级网络功能添加到分布式系统而不将其涵盖在分布式应用程序组件的运行时的一个典型示例。</p><h4 id="Skupper"><a href="#Skupper" class="headerlink" title="Skupper"></a>Skupper</h4><p>除了典型的服务网格外，还有一些项目（如Skupper）可通过外部代理透传应用程序网络流量。 Skupper通过7层虚拟网络解决了多集群Kubernetes的通信难题，<br>并提供了高级路由和连接功能。 但是，它没有将Skupper嵌入到业务服务运行时中，而是在每个Kubernetes名称空间运行一个实例。</p><h4 id="Cloudstate"><a href="#Cloudstate" class="headerlink" title="Cloudstate"></a>Cloudstate</h4><p>Cloudstate是Sidecar模型的另一个示例，但这一次是为serverless开发模型提供有状态抽象。 它通过GRPC提供有状态原语，用于EventSourcing，CQRS，Pub / Sub，<br>键值存储和其他用例。这次是serverless编程模型涵盖Operators和sidecar的例子。</p><h4 id="Dapr"><a href="#Dapr" class="headerlink" title="Dapr"></a>Dapr</h4><p>Dapr是由Microsoft发起的一个相对较年轻的项目，它还是使用sidecar模型来提供以开发人员为中心的分布式系统原语。 Dapr为状态管理，服务调用和故障处理，<br>资源绑定，发布/订阅，分布式跟踪等提供抽象。 尽管Dapr和Service Mesh提供的功能有些重叠，但两者在本质上却大有不同。 带有Istio的Envoy被注入并在<br>服务中透明运行，其代表一种操作工具。 另一方面，必须从应用程序运行时通过HTTP或gRPC显式调用Dapr，它是面向开发人员的显式工具。 其是一个用于分布<br>式原语的库，可作为sidecar进行分发和使用，该模型对于使用分布式功能的开发人员变得非常有吸引力。</p><h4 id="Camel-K"><a href="#Camel-K" class="headerlink" title="Camel K"></a>Camel K</h4><p>Apache Camel是一个成熟的集成库。 其子项目Camel K大量使用Operators模型来改善开发人员体验并与Kubernetes平台进行深度集成。 虽然Camel K不依赖<br>于sidecar，但通过其CLI和Operators，它能够在不到一秒钟的时间内重用同一应用程序容器并在远程Kubernetes集群中执行任何本地修改代码。</p><p>这些只是通过Operators和sidecar探索各种可能的一些探索项目。 为了减少基于容器的分布式体系结构（如数据平面开发工具包（DPDK））引入的网络开销，需要做更多的<br>工作，该工具包是一种用户空间应用程序，它绕过Linux内核网络堆栈直接访问网络硬件。 Kubernetes项目正在进行一些工作，以创建具有更精细的生命周期保证的<br>sidecar容器。 有一些基于GraalVM实现的Java项目，例如Quarkus，它们减少了资源消耗和应用程序启动时间，这些创新的尝试使得sidecar更具有吸引力。<br>并使更多此类项目的诞生提供了可能。</p><p><img src="https://imgchr.com/i/YxwfUS" alt></p><p>看到围绕更具体用例的项目，例如sidecar上的作业调度程序对长期运行的有状态编排（例如，BPMN引擎）进行的处理。 无状态集成引擎，如Sidecar中的Enterprise Integration Patterns实现；<br>sidecar中的数据抽象和数据联合引擎；sidecar中的OAuth2 / OpenID代理；可扩展的数据库连接池；可用于无人驾驶汽车中的serverless工作负载； 应用程序网络，<br>如辅助工具等。但是，为什么软件供应商和开发人员会切换到这种模式？ </p><p>接下来介绍这种模式带来的优越性。</p><hr><h3 id="二、模式的优势"><a href="#二、模式的优势" class="headerlink" title="二、模式的优势"></a>二、模式的优势</h3><h4 id="控制平面的运行时"><a href="#控制平面的运行时" class="headerlink" title="控制平面的运行时"></a>控制平面的运行时</h4><p>作为软件供应商，可能已经考虑过将软件以API或基于SaaS的解决方案的方式提供给客户，这是最快的软件消费模型。 根据软件的性质，您可能还会将软件作为工具库<br>或运行时框架进行产品分发，也许现在是时候考虑是否将其以operator方式提供。 这种软件的分发机制和体系结构具有一些可执行文件无法提供的特有的好处。</p><ol><li><p>支持多语言<br>通过协议标准或者标准库，为多数编程语言提供开发方案。使用sidecar方式运行并通过HTTP协议对外暴露接口的方式，而无需任何特定的运行时库。即使采用<br>gRPC和Protobuf协议用于处理低延迟和高性能的交互，生成此类客户端也比在应用程序运行时中包含第三方自定义库和实现某些接口来的容易得多。</p></li><li><p>兼容性<br>显式的sidecar体系结构（与透明的sidecar体系结构相反）是一种软件消费方式，其作为一个独立运行时，支持面向开发人员为中心的API。它作为一种通用特性，可<br>以添加到任何应用程序中，无论是单体，微服务，还是基于函数的架构。在Kubernetes上创建辅助工具很简单，并且在其他软件编排平台上也可行。</p></li><li><p>容错性<br>业务逻辑始终是内部定制和开发的。分布式系统原语是众所周知的产品功能，并且已作为平台功能或产品库使用。您可能正在使用来自第三方的开源项目或<br>商业软件来实现消息传递，网络弹性和监视。这些第三方软件的发布周期、关键代码的修复和CVE补丁同样会影响您的软件发布周期。当第三方库作<br>为单独的运行时（sidecar）使用时，升级过程会更简单，因为它位于API服务的后面，并且不与应用程序运行时解藕。软件开发团队与第三方软件之间的解藕变得更易于管理。</p></li><li><p>控制平面<br>当某个功能作为库使用时，它就包含在应用程序的运行时中，您有责任了解它的工作方式，其中包括配置、监控、性能和升级。语言的运行时（例如JVM）和运行时框架<br>（例如Spring Boot或应用程序服务器）决定了如何处理配置、监视和升级方案。<br>当软件功能作为单独的运行时使用（例如，sidecar或独立容器）时，它将以Kubernetes operator的形式提供其控制平面。</p></li></ol><p>由于控制平面了解其管理的软件并具备必要的智能化管理特性，否则它将作为文档和最佳实践进行分发。此外，运营商还与Kubernetes进行了深度集成，提供了平台<br>集成和operator开箱即用的奇妙组合。operator由同一开发人员创建，他们了解容器化功能的内部结构，并且知道如何最佳地操作。operator是容器中的SRE，<br>随着更多operator及其应用市场的兴起，operator的数量及其功能正在稳步增长。</p><hr><h3 id="三、未来的软件发行"><a href="#三、未来的软件发行" class="headerlink" title="三、未来的软件发行"></a>三、未来的软件发行</h3><h4 id="以sidecar方式分发软件并附带管理平面"><a href="#以sidecar方式分发软件并附带管理平面" class="headerlink" title="以sidecar方式分发软件并附带管理平面"></a>以sidecar方式分发软件并附带管理平面</h4><p>假设您是Java框架的软件提供商，我们可以以Maven配置方式进行分发。当然更进一步，我们可以直接以容器镜像方式分发。无论采用何种方式，在当今的云原生世界中，<br>都未达到尽善尽美的地步。用户仍然需要知道如何在零停机状态下对应用程序程序进行热更新，同时需要知道应该备份的内容以及如何配置其监控并设置告警阈值。<br>他们必须知道如何检测复杂故障并解决。他们必须知道如何根据当前的负载配置文件来调整应用程序。</p><p>在处理上述类似的场景时，Kubernetes以operator方式提供管理平面的方案将是最优解。operator包含应用程序和以关联业务特性的配置方式来以管理工作负载的组件。</p><blockquote><p>Sidecars和operators正在成为主流的软件分发和消费方式，在某些情况下甚至会像我们过去那样取代软件库和框架。</p></blockquote><p>假设您提供的软件库作为依赖项包含在使用者应用程序中。可能是上面描述的后端框架的客户端库。例如，如果它是在Java中，那么您可能已经在JEE服务器上运行，<br>前提是Spring启动程序、构建程序、工厂和其他实现都隐藏在Java接口后面，这样你甚至可以把它移植到golang。</p><p>有了Kubernetes的operator和sidecars之后，所有这些都对消费者透明。工厂类被operator取代，唯一的配置接口是自定义资源的YAML文件。然后，operator负责配置软件<br>，以便用户可以将其作为一个显式的sidecar来使用。在所有情况下，您的应用程序都可以通过远程API调用，并与平台功能甚至其他依赖的operator完全集成。</p><h4 id="通过远程API而不是嵌入式库使用的软件"><a href="#通过远程API而不是嵌入式库使用的软件" class="headerlink" title="通过远程API而不是嵌入式库使用的软件"></a>通过远程API而不是嵌入式库使用的软件</h4><p>换种角度来看，sidecar的作用类似于OOP中继承原则的组合，但是在多语言环境中。通过组合来自不同进程的功能，而不是将它们作为依赖项包含在单个应用程序中，这是<br>一种组织应用程序功能的不同方式。当您将软件用作库时，可以实例化一个类，并通过传递一些值来调用其方法。当您将其用作进程外功能时，您将访问本地进程。<br>在此模型中，方法被API取代，进程内方法被HTTP或gRPC调用所取代，并使用CloudEvents之类的通信标准。这是从应用程序服务器到Kubernetes的分布式运行时的转变。<br>这是从特定语言的界面到远程API的转变。从内存调用到HTTP，从值对象到CloudEvents，等等。</p><p>这要求软件提供商分发容器和控制器以对其进行管理。创建能够在本地构建和调试多个运行时服务的IDE。用于代码更新并配置控制平面以快速部署到Kubernetes的CLI。<br>可以决定在自定义应用程序运行时中进行编译的内容，可以从Sidecar输出哪些能力以及从业务流程平台获得哪些功能。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yx0RMR.png" alt></p><p>从长远来看，这将导致标准API的合并，这些标准API用于消耗sidecar中的通用能力。除了特定语言的标准和API，我们将使用多语种API。例如，除了Java数据库连接<br>（JDBC）API，Java缓存API（JCache），Java持久性API（JPA）之外，我们还将使用CloudEvents之类的基于HTTP的多语言API。以Sidecar为中心API，如<br>用于消息传递，缓存，可靠的网络，cron作业和计时器调度，资源绑定（其他API，协议的连接器），幂等性，SAGA等。所有这些功能都将随表格中包含的管理层一起提供<br>，甚至包含自助式用户管理界面。operator是上述特性的关键推动力，因为它们将使分散的架构易于在Kubernetes上进行管控。operator的管理接口由<br>CustomResourceDefinition定义，代表第三方资源面向公众管理的API。</p><p>在交付速度和可操作性的驱动下，这是一种思想上的巨大转变，其转向了一种革命性的软件分发和使用的方式。这是从单一运行时架构到多运行时应用程序架构的转变。这与<br>摩尔定律结束后硬件行业从单核平台向多核平台的转变累屎。这一变化正在慢慢发生：我们已经统一采用标准化容器，我们已经基于Kubernetes确定了事实上的编排标准，<br>随着推出的sidecar，以及operator的广泛应用，以及CloudEvents标准的深入人心，标准化的API和生态系统也会随之出现。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/operators-and-sidecars-are-the-new-model-for-software-delivery/" target="_blank" rel="noopener">software-delivery</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/23/Yxdj1A.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;现如今的开发人员希望可以开发出具备弹性和可扩展的分布式系统。 该系统受益于软件复用和开源模型创新，针对安全性问题能够轻易完成补丁更新并进行低风险的升级。&lt;br&gt;该系统不可能通过带有各种嵌入式语言库的应用程序框架来实现。&lt;/p&gt;
&lt;p&gt;最近，一篇关于“多运行时微服务体系结构”的文章，其中探讨了分布式系统的需求，例如生命周期管理，高级网络，资源绑定，状态抽象以及这些抽象概念多年来的变化。&lt;br&gt;在以Kubernetes为中心的分布式系统的发展过程中，形成了以Kubernetes Operators和sidecar作为分布式系统交付的主要创新机制。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;基于Kubernetes构建的软件应用，其架构的发展正朝着Kubernetes Operators和sidecar模型发展。 Kubernetes Operators和sidecar可能会成为主流&lt;br&gt;的软件分发和消费方式，在极端情况下甚至会像我们过去那样取代软件库和框架。Sidecar模型允许以不同语言编写的应用程序组合完成交付，而无需与运行时捆绑。&lt;br&gt;接下来让我们看一下Kubernetes Operators和sidecar的一些具体示例，然后我们将探索这种新的模型如何影响我们后续的开发模式。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Serverless标准化夯实应用基础架构的未来</title>
    <link href="https://ustack.io/2020-05-16-Serverless%E6%A0%87%E5%87%86%E5%8C%96%E5%A4%AF%E5%AE%9E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>https://ustack.io/2020-05-16-Serverless标准化夯实应用基础架构的未来.html</id>
    <published>2020-05-16T13:40:08.000Z</published>
    <updated>2020-05-17T11:57:11.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>Serverless正在迅猛发展：根据2019度CNCF调查报告，目前有41％的受访者正在使用serverless技术，另有20％的受访者计<br>划在未来12至18个月内使用serverless技术。 serverless技术允许云化应用程序开发团队将代码交付给serverless服务商-以减少<br>开销成本，提高可伸缩性并简化DevOps周期。</p></div><a id="more"></a><hr><h3 id="一、Serverless标准"><a href="#一、Serverless标准" class="headerlink" title="一、Serverless标准"></a>一、Serverless标准</h3><blockquote><p>Serverless已经被认为是应用程序基础架构的下一个发展阶段，但目前仍然有一些障碍需要克服，特别是标准化工作。</p></blockquote><p>长期以来，推进标准化一直是统一计算领域的重要方式。 正如当初的Mesos、Kubernetes以及Swarm的容器编排之争，在争夺霸主地位的过程中，因为Kubernetes致力于标准化的引进，从而异军突起，后发制人，一举赢得容器编排之争，正是因为秉持标准化的理念，Kubernetes得到越来越多的人员的加入，从社区的维护到使用者的参与，再到CNCF的壮大。更久远的事例，就是浏览器之争，因为2001年成功说服Internet Explorer，Netscape和其他浏览器采用World Wide Web Consortium建立的标准。 结果就是今天我们知道和喜欢的互联网：一个开放，协作且通用的平台，可以在线连接世界各地的人们，从而使Web开发人员的生活变得更加轻松。</p><p>如今，serverless的生态系统仍然呈现零散状态，就像早期的互联网一样。 在AWS Lambda，Microsoft Azure Functions，Google Cloud Functions和众多其他平台之间，许多serverless功能都是专有的，这使得将应用程序从一个平台迁移到另一个平台成为一项难题。 平台之间缺乏可移植性和互操作性，这阻碍了serverless的应用，开发人员担心业务与云服务商过于耦合。</p><p>在serverless市场较初期的情况下，如果能够降低业务与服务的耦合下，那么在将来存在更好的选择情况下，开发人员就不会陷入选择serverless提供商的困境。 而且，随着新冠病毒给经济造成的不可弥补的伤害，serverless市场有望为快速整合做好准备，这使得云服务商具备跨平台迁移serverless应用程序的能力比以往任何时候都更为重要。</p><p>缺乏serverless标准化同时也带来了安全挑战。尽管serverless可以通过减少服务器管理来简化运维等成本，但是由于开发人员无法看到他们在无服务器平台上运行的工作负载。这意味着无法察觉诸如数据泄露，配置错误，过度的访问权限等安全威胁。当然，可以让开发人员通过serverless提供商提供的API来观察可能的安全威胁。但是没有标准化的serverless框架，在整个serverless生态系统中就不会存在标准化的安全工具或最佳实践。</p><p>庆幸的是，标准化工作正在推进。位于云原生世界中心的CNCF，已经意识到了”标准化的紧迫性，并指出需要高质量的文档，最佳实践，更重要的是工具和实用程序。通常，有必要将不同的参与者聚集在同一个屋檐下，以通过协作来推动创新”。本着协作的精神，CNCFserverless平台提供商和第三方库开发人员召集到serverless工作组中，以推进标准化。</p><hr><h3 id="二、CloudEvent试水"><a href="#二、CloudEvent试水" class="headerlink" title="二、CloudEvent试水"></a>二、CloudEvent试水</h3><p>serverless工作组的早期推出的CloudEvents标准，它用于事件描述的标准化。serverless工作组经过两年的工作，于2019年10月发布了1.0版。 CloudEvents为Go，JavaScript，Java，C＃，Ruby和Python等语言提供了标准化的SDK，可用于构建事件路由器，跟踪系统和其他工具，从而简化跨平台和环境的事件数据交付。</p><p>Kubernetes已经成为另一个有预期未来的解决方案。容器生态系统已经围绕Kubernetes进行了整合，使其成为统一serverless生态系统的理想平台。在2018年，由Google领导、与Pivotal，IBM，Red Hat和SAP合作推出了Knative开源框架，其用于在Kubernetes之上运行serverless应用程序组件。该平台提供以构建，部署，扩展和运行serverless工作负载的所有API。</p><p>除了互操作性和可移植性之外，Knative还具有安全性优势。 Knative允许您使用已经为Kubernetes开发的安全工具，其中安全策略更加成熟。借助Knative，您可以通过将安全代理嵌入Kubernetes中的serverless工作负载来实现更丰富的可扩展性，而无需使用serverless平台提供的基础架构插件。如果您的团队已经在Kubernetes安全性上进行了投资，则这些安全性投资可以扩展到serverless安全性。</p><p>Knative是否能够成为serverless标准化的赢家还有待观察。截至3月，Knative的采用率达到17％，这意味着其成熟度和增长空间仍然很大。 Knative本身建立在Kubeless的基础上，Kubeless是先前围绕Kubernetes标准化serverless的前期尝试。但是，有迹象表明，谷歌已经在Knative的基础上构建了其下一代，完全托管的无服务器平台Cloud Run，这表明其他早期的serverless平台可能会加速效仿。</p><p>Serverless使开发人员可以心无旁骛的专注于在其代码中构建功能，而不是管理运行这些功能的服务器。从繁重而又至关重要的运维责任中解放出来的有可能为应用程序开发人员释放更多的创新热情和业务价值，但是缺乏标准化的风险会分散serverless生态系统。随着标准化的发展，开源协作的力量便推动了创新。</p><hr><h3 id="三、何为CloudEvent"><a href="#三、何为CloudEvent" class="headerlink" title="三、何为CloudEvent"></a>三、何为CloudEvent</h3><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>CNCF的Serverless工作组最初是由CNCF技术监督委员会创建的，旨在调查serverless技术并为该领域中与CNCF相关的活动提出一些可能的下一步建议。 建议之一是研究创建通用事件格式，以帮助云提供商之间功能的可移植性以及事件流处理的互操作性。 最终，创建了CloudEvents规范。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>起初，制定CloudEvents标准是serverless工作组的一部分工作内容的，而当规范达到其v0.1里程碑时，TOC批准将其作为CNCF一个全新的独立沙箱项目。</p><p>CloudEvents通常用于分布式系统中，以实现服务在开发过程中的解耦，并完成独立部署，并且以后以此连接新的应用程序。</p><p>CloudEvents规范的目标是定义事件系统的互操作性，该系统允许服务生成或使用事件，其中包括独立开发和部署生产者和使用者。生产者可以在消费者收听之前生成事件，并且消费者可以进行相关订阅操作。需要注意的是，此工作产生的规范集中于事件格式的互操作性以及在各种协议（例如HTTP）上发送事件格式的显示方式。规范不关注事件产生者或事件消费者的处理模型。</p><p>CloudEvents的核心是定义了一组元数据，称为属性，以及有关在系统之间传输的事件和这些元数据应如何出现在消息中。该元数据是将请求路由到适当组件并促进该组件对事件进行适当处理所需的最少信息集。尽管这可能意味着事件本身的某些应用程序数据可能会作CloudEvent属性集的一部分，但这也是为了正确传递和处理消息而进行的必要操作。相反，不打算用于此目的的数据应放在事件（数据）本身。</p><p>此外，假定协议层将消息传递到目标系统所需的元数据完全由协议处理，那么就没有必要包含在CloudEvents属性中。除了这些属性的定义之外，还将规范如何以不同的格式（例如JSON）和协议（例如HTTP，AMQP，Kafka）来序列化事件。某些协议本身支持将多个事件批处理到单个API调用中。为了帮助实现互操作性，应由协议决定是否实现批处理以及如何实现批处理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/serverless-needs-standards-to-be-the-future-of-application-infrastructure/" target="_blank" rel="noopener">the-future-of-application-infrastructure</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Serverless正在迅猛发展：根据2019度CNCF调查报告，目前有41％的受访者正在使用serverless技术，另有20％的受访者计&lt;br&gt;划在未来12至18个月内使用serverless技术。 serverless技术允许云化应用程序开发团队将代码交付给serverless服务商-以减少&lt;br&gt;开销成本，提高可伸缩性并简化DevOps周期。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>xDS标准引入gRPC生态</title>
    <link href="https://ustack.io/2020-05-06-xDS%E6%A0%87%E5%87%86%E5%BC%95%E5%85%A5GRPC%E7%94%9F%E6%80%81.html"/>
    <id>https://ustack.io/2020-05-06-xDS标准引入GRPC生态.html</id>
    <published>2020-05-06T12:40:08.000Z</published>
    <updated>2020-05-06T12:45:25.753Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/06/YAWtkd.md.png" alt></p><div class="note info"><p>gRPC小组正在努力扩展当前的gRPCLB功能。其不再使用自定义负载均衡协议，而是采用基于Envoy xDS API的xDS协议。这将允许与支持xDS API的开源控制<br>平面（例如Istio Pilot，go-control-plane和java-control-plane）进行交互。其他优化如下所示：</p><ul><li>更加灵活和先进的负载均衡策略配置功能</li><li>基于LRS（负载报告服务）的负载报告功能等</li></ul></div><p>客户端侧实现的xDS负载均衡插件与当前的gRPCLB协议不兼容。因此，我们可以认为当前的gRPCLB实现已被废弃。我们正在积极致力于新协议的推进。预计在接下来的几<br>个季度中会看到更多的进展，其中包括有关新设计的gRFC。下述将介绍gRPC关于负载均衡的设计。<br><a id="more"></a></p><hr><h3 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h3><blockquote><p>值得注意的是，gRPC中的负载均衡是在每个调用而不是每个连接的基础上进行的。 换句话说，即使所有请求都来自单个客户端，我们仍然希望在所有服务器之间实现负载均衡。</p></blockquote><h4 id="负载均衡方案"><a href="#负载均衡方案" class="headerlink" title="负载均衡方案"></a>负载均衡方案</h4><p>在介绍gRPC之前，我们将探讨一些常用的方法来实现负载平衡。</p><ol><li>代理模式</li></ol><p>该方案使用代理来提供稳定可靠的客户端，其可以将负载报告上报给负载均衡系统。 代理通常需要更多资源以维持运行，因为它们需要保存RPC请求和响应的临时副本。<br>此模型还增加了RPC的延迟。</p><blockquote><p>在高并发应用场景下（例如存储），代理模型效率比较低下。</p></blockquote><ol start="2"><li>客户端动态均衡</li></ol><p>该方案将大多的负载均衡逻辑放置在客户端侧。例如，客户端可能包含许多用于服务器的负载均衡策略（如Round Robin，Random等）。<br>在该方案中，服务器列表将由名称解析系统（如DNS等解析），或者由外部负载均衡器等静态配置，无论如何，客户端负责从列表中选择首选服务器。</p><p>这种方案的缺点之一是以多种语言/版本的客户端维护负载均衡策略。这些策略可能相当复杂。一些算法还需要客户端与服务器之间的通信，因此，除了<br>RPC用于用户请求之外，客户端可能变得更加厚重，以满足获取运行状况或加载信息等需求。</p><blockquote><p>这将使客户端的代码复杂化：新的设计需要隐藏多层负载均衡的复杂性，而将其以简单的服务器列表反馈给客户端。</p></blockquote><ol start="3"><li>外部负载均衡服务</li></ol><p>客户端负载均衡代码保持简洁且可移植，实现选择服务器的通用算法（如Round Robin等）。复杂的负载均衡算法由外部负载均衡器提供。客户端依靠<br>外部负载均衡器提供负载均衡配置以及客户端应向其发送请求的服务器列表。均衡器根据需要更新服务器列表，并且负责处理服务器不可用或运行故障等问题。负载均<br>衡器将做出最终研判，并通知客户端。负载均衡器可以与后端服务器通信以收集负载和健康等信息。</p><hr><h3 id="二、要求"><a href="#二、要求" class="headerlink" title="二、要求"></a>二、要求</h3><h4 id="简洁的API和客户端"><a href="#简洁的API和客户端" class="headerlink" title="简洁的API和客户端"></a>简洁的API和客户端</h4><p>gRPC客户端的负载均衡代码必须保持简洁且可移植性。客户端应仅包含用于选择服务器的简单算法（如Round Robin等）。对于复杂算法，客户端应依靠负载均衡器来提供<br>以及客户端应向其发送请求的服务器列表。均衡器将根据需要更新服务器列表，并且负责处理服务器不可用或运行故障等问题。负载均衡器将做出最终研判，并通知客户。<br>负载均衡器可以与后端服务器通信以收集负载和健康等信息。</p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>负载均衡器可能与实际的服务器后端分离，并且负载均衡器的安全风险仅局限于负载均衡组件。换句话说，与没有负载均衡功能的相比，受到攻击的负载均衡器<br>应该不能让客户端取信（可能是恶意的）后端服务器。</p><hr><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>gRPC中负载均衡的主要机制是外部负载均衡，其中外部负载均衡器为客户端提供服务器的最新列表。</p><p>gRPC客户端支持用于操作内置负载均衡策略的API。 其中只有少数支持（如grpclb策略，该策略支持外部负载均衡），但是不鼓励用户通过添加<br>更多代码来扩展gRPC。 而是，推荐用户在外部负载均衡器中实现新的负载均衡策略。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><blockquote><p>在域名解析和与服务器的连接之间，负载均衡策略适配gRPC客户端工作流。 运作方式如下：</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/06/YAWl6K.md.png" alt></p><p>1.在启动时，gRPC客户端发出域名解析请求，解析服务器名称。该名称将解析为一个或多个IP地址，每个都将指示它是服务器地址还是一个负载均衡器地址及<br>一个服务配置（标明使用的客户端负载均衡策略，如round_robin或grpclb等）。</p><p>2.负载均衡策略</p><blockquote><p>注意：如果解析程序返回的地址中的任何一个是负载均衡器地址，那么客户端将使用<code>grpclb</code>策略，无论服务配置请求什么负载均衡策略。<br>否则，客户端将使用请求的负载均衡策略进行服务配置。如果未请求负载平衡策略通过服务配置，客户端将使用策略选择第一个可用的服务器地址。</p></blockquote><p>3.负载均衡策略为每个服务器实例创建了一个子通道</p><ul><li>对于所有策略（grpclb除外），这意味着解析器返回的每个地址都有一个子通道。 请注意，这些策略会忽略解析器返回的任何均衡器地址。</li><li>对于<code>grpclb</code>策略，工作流程如下：<ol><li>该策略在解析器返回的均衡器地址间开辟一个流通道。它需要均衡器提供服务器地址以用于客户端最初发起请求。<br>注意：在<code>grpclb</code>策略中，在负载均衡策略启动时，如果没有均衡器可以正常通信，那么返回的非负载均衡器地址可以作为后备选项。<br>2.负载均衡器将客户端定向到的gRPC服务器，gRPC服务器根据负载均衡器的配置，可以向其上报负载等信息。<br>3.负载均衡器将服务器列表返回到gRPC<code>grpclb</code>策略的客户端，然后，<code>grpclb</code>策略将为列表中的每个服务器建立子通道。</li></ol></li></ul><p>4.对于每个发送的RPC，负载均衡策略决定RPC应该发送到的哪个子通道（哪个服务器）。</p><ul><li>对于<code>grpclb</code>策略，客户端将把请求发送到服务器。如果服务器列表为空，则呼叫阻塞，直到出现非空。</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/grpc/grpc/blob/618a3f561d4a93f263cca23abad086ed8f4d5e86/doc/load-balancing.md" target="_blank" rel="noopener">load balancing</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/06/YAWtkd.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;gRPC小组正在努力扩展当前的gRPCLB功能。其不再使用自定义负载均衡协议，而是采用基于Envoy xDS API的xDS协议。这将允许与支持xDS API的开源控制&lt;br&gt;平面（例如Istio Pilot，go-control-plane和java-control-plane）进行交互。其他优化如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加灵活和先进的负载均衡策略配置功能&lt;/li&gt;
&lt;li&gt;基于LRS（负载报告服务）的负载报告功能等&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;客户端侧实现的xDS负载均衡插件与当前的gRPCLB协议不兼容。因此，我们可以认为当前的gRPCLB实现已被废弃。我们正在积极致力于新协议的推进。预计在接下来的几&lt;br&gt;个季度中会看到更多的进展，其中包括有关新设计的gRFC。下述将介绍gRPC关于负载均衡的设计。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="grpc" scheme="https://ustack.io/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>下一代云原生网关Gloo之架构赏析</title>
    <link href="https://ustack.io/2020-05-06-%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BD%91%E5%85%B3Gloo:%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html"/>
    <id>https://ustack.io/2020-05-06-下一代云原生网关Gloo:相关概念.html</id>
    <published>2020-05-06T12:40:08.000Z</published>
    <updated>2020-05-21T13:25:30.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/21/YqsrWR.md.png" alt></p><div class="note info"><p>Gloo聚合后端服务并为客户端提供端到端的功能转换，从而允许与后端API分离。客户端向在Gloo上定义的路由发出请求或<a href="https://github.com/solo-io/gloo-sdk-go" target="_blank" rel="noopener">发出事件</a>。 这些路由<br>通过Gloo的配置（由Gloo的API的客户端提供）在上游服务起作用。</p></div><p>Gloo在客户端定义的路由和后端功能之间执行必要的转换，能够<br>通过其可扩展的<a href="https://github.com/solo-io/gloo/blob/master/projects/gloo/pkg/plugins/plugin_interface.go" target="_blank" rel="noopener">插件接口</a>支持各种上游功能。<br><a id="more"></a></p><p>Gloo在所有功能上均提供一流的API管理功能:</p><ul><li>超时</li><li>指标和追踪</li><li>健康检查</li><li>重试</li><li>高级负载平衡</li><li>具有SNI支持的TLS终止</li><li>HTTP标头修改</li></ul><hr><h3 id="一、Gloo组件"><a href="#一、Gloo组件" class="headerlink" title="一、Gloo组件"></a>一、Gloo组件</h3><blockquote><p>从最基本的意义上讲，Gloo是转换引擎，Envoy xDS服务器为Envoy提供高级配置（包括Gloo的自定义Envoy过滤器）。 Gloo遵循基于事件的体系结构，监视各<br>种配置源以进行更新，并立即通过v2 版本的gRPC接口更新Envoy配置。</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/21/YqsrWR.md.png" alt="架构图"></p><h4 id="Config-Watcher"><a href="#Config-Watcher" class="headerlink" title="Config Watcher"></a>Config Watcher</h4><p>在介绍gRPC之前，我们将探讨一些常用的方法来实现负载平衡。</p><h4 id="Secret-Watcher"><a href="#Secret-Watcher" class="headerlink" title="Secret Watcher"></a>Secret Watcher</h4><h4 id="Endpoint-Discovery"><a href="#Endpoint-Discovery" class="headerlink" title="Endpoint Discovery"></a>Endpoint Discovery</h4><h4 id="Translator"><a href="#Translator" class="headerlink" title="Translator"></a>Translator</h4><h4 id="Reporter"><a href="#Reporter" class="headerlink" title="Reporter"></a>Reporter</h4><h4 id="xDS-Server"><a href="#xDS-Server" class="headerlink" title="xDS Server"></a>xDS Server</h4><hr><h3 id="二、Discovery架构"><a href="#二、Discovery架构" class="headerlink" title="二、Discovery架构"></a>二、Discovery架构</h3><p>一组可选的发现服务支持Gloo，它们会自动发现和配置Gloo上游和功能，简化了用户和自助服务的路由。</p><p><img src="../discovery_architecture.png" alt="Discovery架构" title="Discovery Architecture"></p><p>发现服务充当自动化的Gloo客户端，自动使用上游和功能填充存储层以便于用户轻松路由。 发现是可选的，但是启用后，它将尝试发现可用上游和功能。</p><p>当前支持平台:</p><ul><li>Kubernetes Service-Based Upstream Discovery</li><li>AWS Lambda-Based Function Discovery</li><li>Google Cloud Function-Based Function Discovery</li><li>OpenAPI-Based Function Discovery</li><li>Istio-Based Route Rule Discovery (Experimental)</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://docs.solo.io/gloo/latest/introduction/architecture/" target="_blank" rel="noopener">architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/21/YqsrWR.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Gloo聚合后端服务并为客户端提供端到端的功能转换，从而允许与后端API分离。客户端向在Gloo上定义的路由发出请求或&lt;a href=&quot;https://github.com/solo-io/gloo-sdk-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;发出事件&lt;/a&gt;。 这些路由&lt;br&gt;通过Gloo的配置（由Gloo的API的客户端提供）在上游服务起作用。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Gloo在客户端定义的路由和后端功能之间执行必要的转换，能够&lt;br&gt;通过其可扩展的&lt;a href=&quot;https://github.com/solo-io/gloo/blob/master/projects/gloo/pkg/plugins/plugin_interface.go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插件接口&lt;/a&gt;支持各种上游功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes进阶之NT技术小解</title>
    <link href="https://ustack.io/2020-04-20-Kubernetes%E8%BF%9B%E9%98%B6%E4%B9%8BNT%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%A7%A3.html"/>
    <id>https://ustack.io/2020-04-20-Kubernetes进阶之NT技术小解.html</id>
    <published>2020-04-20T12:40:08.000Z</published>
    <updated>2020-04-20T13:41:53.742Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/J1gtsK.md.png" alt></p><div class="note info"><p>&lt;&lt;Kubernetes进阶&gt;&gt;系列将kubernetes系统的设计理念进行深入梳理与分享。<br>在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h3><h4 id="中央处理器（Central-processing-unit）"><a href="#中央处理器（Central-processing-unit）" class="headerlink" title="中央处理器（Central processing unit）"></a>中央处理器（Central processing unit）</h4><p>在我们了解其它概念之前，我们应该首先了解一下什么是CPU，它是做什么的，它的主要组件以及相应的作用都是什么？<br>简单点说，CPU其实就是计算机内部的一个电子电路。根据一些具体的指令它可以执行基本的运算，逻辑，控制和IO操作等。<br>CPU的主要组件包括：</p><ul><li>算术逻辑单元（ALU is short for ‘arithmetic logic unit’），它主要执行一些算术和逻辑操作</li><li>处理器寄存器（processor registers），它主要的作用是给ALU提供操作数并存储ALU操作的结果</li><li>控制器（control unit），通过协调ALU，寄存器和其它组件之间的操作，从主存中取得并执行相应的指令。</li></ul><p>当今大多数地CPU都是微处理器，即它们被包含在单个集成电路芯片（integrated circuit chip）中。一个包含CPU的集成电路可能也包含内存，<br>外围接口和其它的一些计算机组件。这样的集成设备叫做微控制器（microcontrollers）或者芯片上的系统（SoC）。一些计算机采用多核处理器，<br>即单个芯片中包含2个或更多的CPU（也被叫做“cores”）; 在这种情况下，单个芯片有时也被称作”sockets”.</p><p>下图表示的是CPU与主存和IO之间的交互。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1cvxP.md.png" alt="CPU与主存和IO之间的交互"></p><h4 id="多个CPU"><a href="#多个CPU" class="headerlink" title="多个CPU"></a>多个CPU</h4><p>贯穿这个数字计算机的历史，我们一直以来的目标就是想要计算机可以做更多的事情，并且做的更快。因此在hyper-threading 和 multi-core CPUs<br>出现之前，人们想到通过增加CPU的数量来增加计算机的计算机能力和速度，但是这样的方法并没有在个人PC中得到普及，我们只会在一些超级计算机或者一<br>些服务器上会看到这个多个CPU的计算机。因为多个CPU会需要主板有多个CPU socket - 多个CPU被插入到不同的socket中。同时主板也需要额外的硬件<br>去连接这些CPU socket到RAM和一些其它的资源。如果CPU之间需要彼此通信，多个CPU的系统会有很大地开销。</p><h4 id="Hyper-Threading"><a href="#Hyper-Threading" class="headerlink" title="Hyper-Threading"></a>Hyper-Threading</h4><p>由于多个CPU上面存在的缺点，因此它并没有进入普通大众的电脑中，因此消费者电脑的计算始终没有达到并行的状态，电脑的速度也一直没有加快。直到多核<br>处理器和Hyper-Threading技术的出现，才改变了这一点。Hyper-threading这个概念是Intel提出的，这家伟大的公司想把计算机并行计算的能力带入到<br>个人PC中，它第一次进入大众PC的产品是2002年的Pentium 4 HT，最初的这款处理器仅有单个CPU核心，因此它一次只能做一件事情。但是Hyper-threading<br>技术的出现弥补了这个不足。</p><p>Hyperthreading 有时叫做 simultaneous multi-threading，它可以使我们的单核CPU执行多个控制流程。这个技术会涉及到备份一些CPU硬件的一些信息，<br>比如程序计数器和寄存器文件等，而对于比如执行浮点运算的单元它只有一个备份，可以被共享。一个传统的处理器在线程之间切换大约需要20000时钟周期，而一个<br>具有Hyperthreading技术的处理器只需要1个时钟周期，因此这大大减小了线程之间切换的成本。hyperthreading技术的关键点就是：当我们在处理器中执行代<br>码时，很多时候处理器并不会使用到全部的计算能力，部分计算能力会处于空闲状态，而hyperthreading技术会更大程度地“压榨”处理器。举个例子，如果一个线<br>程必须要等到一些数据加载到缓存中以后才能继续执行，此时CPU可以切换到另一个线程去执行，而不用去处于空闲状态，等待当前线程的IO执行完毕。</p><p>Hyper-threading 使操作系统认为处理器的核心数是实际核心数的2倍，因此如果有4个核心的处理器，操作系统会认为处理器有8个核心。这项技术通常会对程序<br>有一个性能的提升，通常提升的范围大约在15%-30%之间，对于一些程序来说它的性能甚至会小于20%, 其实性能是否提升这完全取决于具体的程序。比如，这2个逻<br>辑核心都需要用到处理器的同一个组件，那么一个线程必须要等待。因此，Hyper-threading只是一种“欺骗”手段，对于一些程序来说，它可以更有效地利用CPU的<br>计算能力，但是它的性能远没有真正有2个核心的处理器性能好，因此它不能替代真正有2个核心的处理器。但是同样都是2核的处理器，一个有hyper-threading技<br>术而另一个没有，那么有这项技术的处理器在大部分情况下都要比没有的好。</p><h4 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h4><p>相比于多个处理器而言，多核处理器把多个CPU（核心）集成到单个集成电路芯片（integrated circuit chip）中，因此主板的单个socket也可以适应这样的<br>CPU，不需要去更更改一些硬件结构。一个双核的CPU有2个中央处理单元，因此不像上面我介绍的hyper-threading技术那样，操作系统看到的只是一种假象，这<br>回操作系统看到的是真正的2个核心，所以2个不同的进程可以分别在不同的核心中同时执行，这大大加快了系统的速度。由于2个核心都在一个芯片上，因此它们之间<br>的通信也要更快，系统也会有更小地延迟。</p><p>下图展示了一个Intel Core i7处理器的一个组织结构，这个微处理器芯片中有4个CPU核，每个核中都有它自己的L1和L2缓存。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gVx0.md.png" alt="Intel Core i7处理器的一个组织结构"></p><hr><h3 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在操作系统中，有多线程（multi-threading）的概念，这很好理解，因为线程是进程最小的调度单位，一个进程至少包含一个线程。本文将介绍CPU特有的超线程<br>技术。简单来说就是，多线程比较软，超线程比较硬，二者本质上都是虚拟化。</p><p>超线程(hyper-threading)其实就是同时多线程(simultaneous multi-theading),是一项允许一个CPU执行多个控制流的技术。它的原理很简单，就是把一<br>颗CPU当成两颗来用，将一颗具有超线程功能的物理CPU变成两颗逻辑CPU，而逻辑CPU对操作系统来说，跟物理CPU并没有什么区别。因此，操作系统会把工作线程分<br>派给这两颗（逻辑）CPU上去执行，让（多个或单个）应用程序的多个线程，能够同时在同一颗CPU上被执行。注意：两颗逻辑CPU共享单颗物理CPU的所有执行资源。<br>因此，我们可以认为，超线程技术就是对CPU的虚拟化。</p><p>超线程技术是同时多线程技术的一种实现形式，由Intel公司提出，而该技术背后的概念则是Sun公司的专利。Sun公司虽然倒下了，但它永远是一个伟大的公司。</p><p>纵观计算机的历史，有两个需求是驱动计算机科技进步的持续动力。<br>    第一，人类想让计算机做得更多；<br>    第二，人类想让计算机跑得更快。<br>从这个意义上讲，那些把工程师当做机器的资本家或资本家豢养的打手在榨取程序员的剩余价值的时候，就是不断地追求上述两个需求。超线程技术的发明，就是基于<br>这样的考虑，不榨干处理器的最后一滴油决不罢休。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gmrT.md.png" alt="CPU"></p><p>常规的CPU需要大约两万个时钟周期做不同线程间的切换，而超线程的CPU可以在单个时钟周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理<br>资源。例如：假设一个线程必须等到某些数据被装入到cache中，那么CPU就可以继续去执行另一个线程。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gMa4.md.png" alt="NT"></p><p>超线程允许单个处理器在同一时刻并行地抓取和执行两个独立的代码流。那么超线程是如何工作的？见下图。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1g3GR.md.png" alt="nt工作"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现超线程技术的前提:</p><ul><li>需要CPU支持</li><li>需要主板芯片组支持</li><li>需要BIOS支持</li><li>需要操作系统支持</li><li>需要应用软件支持</li></ul><p>由此可见，超线程技术虽然很酷，但需要方方面面的支持，否则就玩不转。 类似地，如果想最大可能地榨取程序员的剩余价值的话，给程序员提供实现超线程运行的软<br>硬件环境也是必须地，否则一味地让他们拼体力(加班)实在不是个好办法，因为人毕竟不是机器，人只有需要休息好了才可能有创造力，疲惫的人们大多时候是在瞎折<br>腾，往往事倍功半。</p><p>超线程(hyper-threading)本质上就是CPU支持的同时多线程(simultaneous multi-threading)技术，简单理解就是对CPU的虚拟化，一颗物理CPU可以被操<br>作系统当做多颗CPU来使用。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将介绍1.18版本后的kubelet关于CPU的管理技术方案。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener">Central processing unit</a></li><li><a href="http://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">hyper threadingexplained</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/20/J1gtsK.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&amp;lt;&amp;lt;Kubernetes进阶&amp;gt;&amp;gt;系列将kubernetes系统的设计理念进行深入梳理与分享。&lt;br&gt;在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>solo开源Service Mesh Hub</title>
    <link href="https://ustack.io/2020-04-10-servicemesh%E5%B9%B3%E5%8F%B0%E5%A4%A7%E8%A7%82.html"/>
    <id>https://ustack.io/2020-04-10-servicemesh平台大观.html</id>
    <published>2020-04-10T12:40:08.000Z</published>
    <updated>2020-04-14T13:33:23.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/10/G7eWJe.md.png" alt="hub"></p><div class="note info"><p>solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。</p></div><a id="more"></a><hr><h3 id="多集群，多网格管理平面"><a href="#多集群，多网格管理平面" class="headerlink" title="多集群，多网格管理平面"></a>多集群，多网格管理平面</h3><p>Service Mesh Hub的设计旨在丰富管理平面的操作，从单个Kubernetes集群上的单个服务网格到管理跨越多个集群的多个服务网格。 它由管理平面集群上运行的组件组成。</p><p>您可以在Service Mesh Hub中注册一个集群，该集群将处理与其他集群的通信-发现正在运行的服务网格，管理配置，抓取监控指标等等。 用户无需在集群之间切换Kubernetes即可更新服务网格或应用程序的配置，这使运行和扩展操作变得更加简单。</p><hr><h2 id="动态发现"><a href="#动态发现" class="headerlink" title="动态发现"></a>动态发现</h2><p>注册集群后，Service Mesh Hub将支持动态发现。探测器的第一个要务是找到集群上安装的所有服务网格。当发现了服务网格的控制<br>平面后，探测器会将网格资源写入管理平面集群，该集群链接到在集群注册期间写入的Kubernetes集群资源。目前，Service Mesh Hub<br>可以发现和管理Istio和Linkerd网格，并计划提供更多支持。然后，探测器将查找与网格相关联的工作负载，例如已使用该网格的<br>Sidecar代理创建了Pod的部署。它将一个MeshWorkload资源写入代表该工作负载的管理平面集群。最后，探测器还寻找暴露网格服务<br>工作负载的服务，与上述一样，其将MeshService资源写入管理平面集群。<br>此时，管理平面具备了跨多集群，多网格环境的网格，服务和工作负载的完整视图。</p><hr><h2 id="虚拟网格"><a href="#虚拟网格" class="headerlink" title="虚拟网格"></a>虚拟网格</h2><p>为了启用多群集配置，用户将多个网格组合在一起成为一个VirtualMesh的对象。虚拟网格包含一些便于跨集群通信的配置。<br>为了使虚拟网格生效，Service Mesh Hub首先尝试根据用户定义的互信模型建立户型，Service Mesh Hub附带一个代理，<br>可帮助安全地代理跨集群证书签名请求，以最大程度地减少管理证书的操作负担。一旦建立互信关系，Service Mesh Hub将<br>开始联合服务，以便跨集群访问。而在后端，Service Mesh Hub将处理网络（可能通过出口和入口网关，并可能受到用户定<br>义的流量和访问策略的影响），并确保将服务的请求准确路由到正确的目的地。用户可以通过编辑虚拟网格微调哪些服务将代理<br>到哪里。</p><p>从该版本开始，Service Mesh Hub支持使用跨多个群集的多个Istio 1.5+控制平面创建虚拟网格。后续，该团队计划增加<br>对更多网格类型的支持。</p><hr><h2 id="流量和访问策略"><a href="#流量和访问策略" class="headerlink" title="流量和访问策略"></a>流量和访问策略</h2><p>Service Mesh Hub使用户可以将简单的配置对象写入管理平面，为在所管理的任何群集之间制定服务之间的流量和访问策略。<br>它被用于转换基础的网格配置，同时从用户那里抽象出特定于网格类型的对象。TrafficPolicy定义了一组目的源（网格工作<br>负载）和目标（网格服务）之间关系，并用于描述诸如“当A向B发送POST请求，添加标头并将设置超时为10秒”之类的规则。或<br>“在集群C上对该服务的每个请求，增加超时并添加重试”。从该版本开始，流量策略支持超时设定、重试、cors、流量转移、<br>报头处理、故障注入、子集路由、加权目标等功能。请注意，某些网格物体不支持所有这些功能。 Service Mesh Hub将尽其<br>所能将其转换为基础网格配置，或将错误报告给用户。AccessPolicy用于精确控制允许哪些服务进行通信。在虚拟网格上，用<br>户可以指定全局策略来限制访问，并要求用户指定访问策略以实现与服务的通信。</p><p>借助流量和访问策略，Service Mesh Hub为用户提供了一种功能强大的语言，即使在复杂的多集群，多网状应用程序中也可以<br>指示服务应如何通信。</p><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Service Mesh Hub正在解决与多集群网络和配置有关的棘手问题，它附带了一个称为meshctl的命令行工具。 该工具提供了<br>交互式命令，使管理虚拟网格，注册集群、创建流量及访问策略变得更加容易。 它还会带有一个“describe”命令，以帮助您了<br>解您的工作负载和服务如何受到策略的影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/10/G7eWJe.md.png&quot; alt=&quot;hub&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless当打之年</title>
    <link href="https://ustack.io/2020-04-09-Serverless%E5%BD%93%E6%89%93%E4%B9%8B%E5%B9%B4.html"/>
    <id>https://ustack.io/2020-04-09-Serverless当打之年.html</id>
    <published>2020-04-09T12:40:08.000Z</published>
    <updated>2020-04-09T02:40:33.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/09/G4EVSK.md.png" alt="趋势"></p><div class="note info"><p>当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。</p><p>值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：</p></div><a id="more"></a><hr><h3 id="一、初识Serverless"><a href="#一、初识Serverless" class="headerlink" title="一、初识Serverless"></a>一、初识Serverless</h3><p>Serverless的理念是从2016年开始兴起，从其发展趋势来看，它在两三年后，可能对微服务架构的地位构成一定的挑战。</p><p>我们可以知道这么几点：</p><ul><li>开发者专注于业务，摆脱运维的负担</li><li>Serverless按需使用</li><li>Serverless运行时间计费</li><li>Serverless应用严重依赖于特定的云平台、第三方服务</li></ul><p>在一个基于AWS产品开发的Serverless应用里，由以下组件构成：</p><ul><li>API Gateway来处理并发请求，其包括认证、流量管理、授权和访问控制、监控等功能</li><li>计算服务Lambda来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等</li><li>基础设施管理CloudFormation创建和配置 AWS 基础设施部署，诸如所使用的S3存储桶的名称等</li><li>静态存储S3存储前端代码和静态资源</li><li>数据库DynamoDB存储应用的相关数据</li></ul><p>因此，Serverless 并不意味着没有服务器，只是服务器以不同功能的第三方服务的形式存在。<br>在这种情况下，模块的分层演变为不同的服务。在现今的微服务设计中，每一个领域或者子域都是一个服务。而在Serverless应用中，这些领域及子域根据他们的功能，又可能会进一步切分成不同的Serverless函数。</p><hr><h3 id="二、云的征程"><a href="#二、云的征程" class="headerlink" title="二、云的征程"></a>二、云的征程</h3><p>很久之前，我们开发的软件由C/S和MVC的架构，转变为SOA，直到最近几年的微服务架构，更近一点就是Cloud Native（云原生）应用，企业应用从单体架构，到服务化，再到更细粒度的微服务化，应用开发之初就是为了应对业务的特有的高并发、容错等特性，需要很高的性能及可扩展性，人们对软件开发的追求孜孜不倦，希望力求在软件开发的复杂度和效率之间达到一个平衡。但可惜的是，没有银弹！几十年前（1975年）Fred Brooks就在The Mythical Man-Month中就写到了这句话。那么Serverlss会是那颗银弹吗？</p><p>云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚，应用必须运行在服务器上（不论是实体还是虚拟的），并且必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，同时需要保证数据的安全性，当前的云产品能解放我们吗？</p><p>Serverless架构是云的延伸，为了理解serverless，我们有必要回顾一下云计算的发展。</p><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p>2006年AWS推出EC2（Elastic Compute Cloud），作为第一代IaaS（Infrastructure as a Service），用户可以通过AWS快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。</p><p>EC2真正对IT的改变是硬件的虚拟化（更细粒度的虚拟化），而EC2给用户带来了以下五个好处：</p><ul><li>降低劳动力成本：减少了企业本身雇佣IT人员的成本</li><li>降低风险：不用再像自己运维物理机那样，担心各种意外风险，EC2有主机损坏，再申请一个就好了。</li><li>降低基础设施成本：可以按小时、周、月或者年为周期租用EC2。</li><li>扩展性：不必过早的预期基础设施采购，因为通过云厂商可以很快的获取。</li><li>节约时间成本：快速的获取资源开展业务实验。</li></ul><p>有利有弊，我们将在后面讨论。</p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p>PaaS（Platform as a Service）是构建在IaaS之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可，最早的一代是Heroku。Heroko是商业的PaaS，还有一个开源的PaaS——Cloud Foundry，用户可以基于它来构建私有PaaS，如果同时使用公有云和私有云，如果能在两者之间构建一个统一的PaaS，那就是“混合云”了。<br>在PaaS上的卓越贡献者当属docker了，因为docker理念的横空出世，推动了PaaS技术的发展，从mesos、swarm与kubernetes的群雄逐鹿到后来kubernetes一家独大，再到CNCF的成立，这些我们后续再慢慢道来。因为使用容器的轻量、隔离型，推进了应用的容器化日程。管理云上的容器，可以称为是CaaS（Container as a Service），如GCE（Google Container Engine）。也可以基于Kubernetes、Mesos这类开源软件构件自己的CaaS，不论是直接在IaaS构建还是基于PaaS。<br>PaaS是对软件的一个更高的抽象层次，已经接触到应用程序的运行环境本身，可以由开发者自定义，而不必接触更底层的操作系统。</p><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>当然，Serverless不如IaaS和PaaS那么好理解，因为它通常包含了两个方面BaaS（Backend as a Service）和FaaS（Function as a Service）。</p><p><strong><em>BaaS</em></strong></p><p>BaaS（Backend as a Service）后端即服务，一般是一个个的API调用后端或别人已经实现好的程序逻辑，比如身份验证服务Auth0，这些BaaS通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的RDS可以替代我们自己部署的MySQL，还有各种其它数据库、中间价和存储服务等。</p><p><strong><em>FaaS</em></strong></p><p>FaaS（Functions as a Service）函数即服务，FaaS是无服务器计算的额一种形式，当前使用最广泛的是AWS的Lambada。<br>现在当大家讨论Serverless的时候首先想到的就是FaaS。FaaS本质上是一种事件驱动的由消息触发的服务，FaaS服务商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。<br>与传统的服务器端软件的不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而FaaS是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以杀死。</p><p>根据MF网站的无服务器架构定义，FaaS是：</p><ul><li><p>从根本上说，FaaS是关于运行后端代码而无需管理自己的服务器系统或您自己的长期驻留long-lived的服务器应用程序。与容器和PaaS（平台即服务）等其他现代架构趋势进行比较时，第二个子句 - 长期驻留（long-lived）的服务器应用程序是一个关键的区别。（FaaS不是长期驻留的普通API）</p></li><li><p>FaaS产品不需要对特定框架或库进行编码。FaaS函数是语言和环境的常规应用程序。例如，AWS Lambda函数可以在Javascript，Python，Go，任何JVM语言（Java，Clojure，Scala等）或任何.NET语言中实现。但是，Lambda函数还可以执行与其部署工件捆绑在一起的另一个进程，因此您实际上可以使用任何可以编译为Unix进程的语言。</p></li><li><p>部署与传统系统有很大不同，因为我们没有自己运行的服务器应用程序。在FaaS环境中，我们将函数功能的代码上传到FaaS提供商，提供商执行配置资源，实例化VM，管理流程等所需的一切。</p></li><li><p>水平扩展是完全自动的，弹性的，并由提供者管理。如果您的系统需要并行处理100个请求，则提供商将处理该请求而无需您进行任何额外配置。函数的执行是一个“计算容器”，运行是短暂的，FaaS提供者实现容器的创建和销毁完全是由运行时需求驱动。最重要的是，使用FaaS ，供应商可以处理所有底层资源配置和分配 - 用户根本不需要集群或VM管理。(容器+FaaS是Serverless重要的机制，只有容器或FaaS都是片面的，两者分别是静态和动态的)</p></li><li><p>FaaS中的函数通常由提供程序定义的事件类型触发。</p></li><li><p>大多数提供程序还允许触发函数作为对入站HTTP请求的响应; 在AWS中，通常通过使用API网关来实现这一点。函数也可以通过平台提供的API直接调用，无论是在外部还是在同一个云环境中，但这是一种相对不常见的用法。</p></li></ul><hr><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><strong><em>Serverless与FaaS</em></strong></p><p>微服务（MicroService）是软件架构领域业另一个热门的话题。如果说微服务是以专注于单一责任与功能的小型功能块为基础，利用模组化的方式组合出复杂的大型应用程序，那么我们还可以进一步认为Serverless架构可以提供一种更加“代码碎片化”的软件架构范式，我们称之为Function as a Services（FaaS）。而所谓的“函数”（Function）提供的是相比微服务更加细小的程序单元。例如，可以通过微服务代表为某个客户执行所有CRUD操作所需的代码，而FaaS中的“函数”可以代表客户所要执行的每个操作：创建、读取、更新，以及删除。当触发“创建账户”事件后，将通过AWS Lambda函数的方式执行相应的“函数”。从这一层意思来说，我们可以简单地将Serverless架构与FaaS概念等同起来。</p><p><strong><em>FaaS与PaaS的比较</em></strong></p><p>乍看起来，FaaS与PaaS的概念在某些方面有许多相似的地方。人们甚至认为FaaS就是另一种形式的PaaS。但是Intent Media的工程副总裁Mike Roberts有自己的不同看法：“大部分PaaS应用无法针对每个请求启动和停止整个应用程序，而FaaS平台生来就是为了实现这样的目的。”<br>FaaS和PaaS在运维方面最大的差异在于缩放能力。对于大部分PaaS平台，用户依然需要考虑缩放。但是对于FaaS应用，这种问题完全是透明的。就算将PaaS应用设置为自动缩放，依然无法在具体请求的层面上进行缩放，而FaaS应用在成本方面效益就高多了。AWS云架构战略副总裁Adrian Cockcroft曾经针对两者的界定给出了一个简单的方法：“如果你的PaaS能够有效地在20毫秒内启动实例并运行半秒,那么就可以称之为Serverless”。</p><p><strong><em>Serverless 的优势</em></strong></p><p>a、降低运营成本<br>Serverless是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</p><p>b、降低开发成本<br>IaaS和PaaS存在的前提是，服务器和操作系统管理可以商品化。Serverless作为另一种服务的结果是整个应用程序组件被商品化。</p><p>c、扩展能力<br>Serverless架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，您只需支付您所需要的计算能力。</p><p>d、便捷管理<br>Serverless架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</p><p>e、绿色计算<br>按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供5%～15%的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</p><p>f、更快的开发速度<br>由于 Serverless 服务提供者，已经准备好了一系列的基础服务。作为开发人员的我们，只需要关注于如何更好去实现业务，而非技术上的一些限制。服务提供者已经向我们准备，并测试好了这一系列的服务。它们基本上是稳定、可靠的，不会遇上特别大的问题。事实上，当我们拥有足够强大的代码，如使用测试来保证健壮性，那么结合持续集成，我们就可以在 PUSH 代码的时候，直接部署到生产环境。当然，可能不需要这么麻烦，我们只需要添加一个 predeploy 的 hook，在这个 hook 里做一些自动测试的工作，就可以在本地直接发布新的版本。<br>这个过程里，我们并不需要考虑太多的发布事宜。</p><p>g、系统安全性更高<br>依我维护我博客的经验来看，要保持服务器一直运行不是一件容易的事。在不经意的时候，总会发现有 Cracker 在攻击你网站。我们需要防范不同类型的攻击，如在我的服务器里一直有黑客在尝试密码登录，可是我的博客的服务器是要密钥才能登录的。在一次神奇的尝试登录攻击后，我的 SSH 守护进程崩溃了。这意味着，我只能从 EC2 后台重启服务器。有了 Serverless，我不再需要担心有人尝试登录系统，因为我都不知道怎么登录服务器。</p><p>h、适应微服务架构<br>如我们所见在最近几年里看到的那样，微服务并没有大量地替换掉单体应用——毕竟使用新的架构来替换旧的系统，在业务上的价值并不大。因此，对于很多企业来说，并没有这样的强烈需求及紧迫性。活着，才是一件更紧迫的事。而 Serverless 天生就与微服务架构是相辅相成的。一个 Serverless 应用拥有自己的网关、数据库、接口，你可还以使用自己喜欢的语言（受限于服务提供者）来开发服务。换句话来说，在这种情形下，一个 Serverless 可能是一个完美的微服务实例。<br>在可见的一二年里，Serverless 将替换到某些系统中的一些组件、服务。</p><p><strong><em>Serverless的问题</em></strong></p><p>作为一个运行时，才启动的应用来说，Serverless 也存在着一个个我们所需要的问题。</p><p>a、不适合长时间运行应用<br>Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动。这个时候，可以结合 CRON 的方式或者 CloudWatch 来定期唤醒应用。<br>如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。在这种情况下，采用 EC2 这样的云服务器往往是一种更好的选择。因为 EC2 从价格上来说，更加便宜。</p><p>b、完全依赖于第三方服务<br>是的，当你决定使用某个云服务的时候，也就意味着你可能走了一条不归路。在这种情况下，只能将不重要的 API 放在 Serverless 上。当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用 Serverless 架构的时候，我们就和特别的服务供应商绑定了。我们使用了 AWS 家的服务，那么我们再将服务迁到 Google Cloud 上就没有那么容易了。<br>我们需要修改一下系列的底层代码，能采取的应对方案，便是建立隔离层。这意味着，在设计应用的时候，就需要：</p><ul><li>隔离 API 网关</li><li>隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你即支持 Firebase，又支持 DynamoDB</li><li>等等</li></ul><p>这些也将带给我们一些额外的成本，可能带来的问题会比解决的问题多。</p><p>c、冷启动时间<br>如上所说，Serverless 应用存在一个冷启动时间的问题。</p><p>d、缺乏调试和开发工具<br>当使用 Serverless Framework 的时候，遇到了这样的问题：缺乏调试和开发工具。<br>并且，对于日志系统来说，这仍然是一个艰巨的挑战。每次你调试的时候，你需要一遍又一遍地上传代码。而每次上传的时候，你就好像是在部署服务器。然后 Fuck 了，我并不能总是快速地定位出问题在哪。于是，我修改了一下代码，添加了一行 console.log，然后又一次地部署了下代码。问题解决了，挺好的，我删了一下 console.log，然后又一次地部署了下代码。</p><p>e、构建复杂<br>Serverless 很便宜，但是这并不意味着它很简单。</p><p>两者都为我们的计算资源提供了弹性的保障，BaaS其实依然是服务外包，而FaaS使我们更加关注应用程序的逻辑，两者使我们不需要关注应用程序所在的服务器，但实际上服务器依然是客观存在的。<br>当我们将应用程序迁移到容器和虚拟机中时，其实对于应用程序本身的体系结构并没有多少改变，只不过有些流程和规定需要遵守，比如12因素应用守则，但是serverlss对应用程序的体系结构来说就是一次颠覆了，通常我们需要考虑事件驱动模型，更加细化的不熟形式，以及在FaaS组件之外保持状态的需求。</p><hr><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>通过将 Serverless 的理念与当前 Serverless 实现的技术特点相结合，Serverless 架构可以适用于各种业务场景。</p><p>1.Web应用<br>Serverless 架构可以很好地支持各类静态和动态Web应用。如 RESTful API 的各类请求动作（GET、POST、PUT及DELETE等）可以很好地映射成 FaaS 的一个个函数，功能和函数之间能建立良好的对应关系。通过 FaaS 的自动弹性扩展功能，Serverless Web 应用可以很快速地构建出能承载高访问量的站点。</p><p>2.移动互联网<br>Serverless 应用通过 BaaS 对接后端不同的服务而满足业务需求，提高应用开发的效率。前端通过FaaS提供的自动弹性扩展对接移动端的流量，开发者可以更轻松地应对突发的流量增长。在 FaaS 的架构下，应用以函数的形式存在。各个函数逻辑之间相对独立，应用更新变得更容易，使新功能的开发、测试和上线的时间更短。</p><p>3.物联网（Internet of Things，IoT）<br>物联网（Internet of Things，IoT）应用需要对接各种不同的数量庞大的设备。不同的设备需要持续采集并传送数据至服务端。Serverless 架构可以帮助物联网应用对接不同的数据输入源。</p><p>4.多媒体处理<br>视频和图片网站需要对用户上传的图片和视频信息进行加工和转换。但是这种多媒体转换的工作并不是无时无刻都在进行的，只有在一些特定事件发生时才需要被执行，比如用户上传或编辑图片和视频时。通过 Serverless 的事件驱动机制，用户可以在特定事件发生时触发处理逻辑，从而节省了空闲时段计算资源的开销，最终降低了运维的成本。</p><p>5.数据及事件流处理<br>Serverless 可以用于对一些持续不断的事件流和数据流进行实时分析和处理，对事件和数据进行实时的过滤、转换和分析，进而触发下一步的处理。比如，对各类系统的日志或社交媒体信息进行实时分析，针对符合特定特征的关键信息进行记录和告警。</p><p>6.系统集成<br>Serverless 应用的函数式架构非常适合用于实现系统集成。用户无须像过去一样为了某些简单的集成逻辑而开发和运维一个完整的应用，用户可以更专注于所需的集成逻辑，只编写和集成相关的代码逻辑，而不是一个完整的应用。函数应用的分散式的架构，使得集成逻辑的新增和变更更加灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/09/G4EVSK.md.png&quot; alt=&quot;趋势&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。&lt;/p&gt;
&lt;p&gt;值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>五分钟初识Gloo</title>
    <link href="https://ustack.io/2020-04-09-%E4%BA%94%E5%88%86%E9%92%9F%E5%88%9D%E8%AF%86Gloo.html"/>
    <id>https://ustack.io/2020-04-09-五分钟初识Gloo.html</id>
    <published>2020-04-09T12:40:08.000Z</published>
    <updated>2020-05-17T10:06:11.283Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/17/Ygqhod.md.png" alt="架构"></p><div class="note info"><p>Gloo是一种基于Kubernetes原生设计的功能丰富的Ingress Controller，致力于成为下一代API网关标杆产品。 Gloo在函数级路由等方面表现优异；对旧式应<br>用、微服务和serverless提供支持； 它具备高效的发现能力，且功能多样； 并与领先的开源项目（如Envoy、KNative等）紧密集成。 Gloo的独特设计旨在支持<br>异构应用程序，与多种技术，体系结构，协议和云中共存。</p></div><a id="more"></a><hr><h3 id="一、何为Gloo"><a href="#一、何为Gloo" class="headerlink" title="一、何为Gloo"></a>一、何为Gloo</h3><ul><li><p>*Kubernetes ingress controller**: 当部署在Kubernetes上时，Gloo可以充当功能丰富的入口控制器，并且当部署到AWS EKS等公共云时，可以简化路由功能。</p></li><li><p><strong>异构应用</strong>: Gloo创建的应用程序路由到实现为微服务，无服务器功能和旧式应用程序的后端。 此功能可以帮助用户逐渐从旧代码迁移到微服务、无服务器架构。<br>用户在保持其原有代码逻辑前提下，使用云原生技术添加新功能； 组织中的不同团队可以选择不同架构及其他场景。</p></li><li><p><strong>服务网格Ingress</strong>: 服务网格技术解决了跨云网络的服务到服务通信问题。 可以使用服务网格解决诸如服务标识，七层网络遥测信息收集，服务弹性，服务之<br>间的流量路由以及策略执行（例如配额，速率限制等）之类的问题。 为了使服务网格正常运行，它需要一种使流量进入网格的方法。 将流量从边缘传输到集群内部的<br>问题与服务到服务的问题有所不同。 前端网关应当提供缓存，安全性和流量管理，Oauth和最终用户身份验证/授权，用户速率限制，Web应用程序防火墙等。 Gloo<br>解决了以上问题，兼容所有服务网格技术，包括Istio，Linkerd，Consul Connect和AWS App Mesh。</p></li></ul><hr><h3 id="二、Gloo特色"><a href="#二、Gloo特色" class="headerlink" title="二、Gloo特色"></a>二、Gloo特色</h3><ul><li><p><strong>功能级路由允许集成旧版应用程序，微服务和无服务器</strong>：Gloo可以路由<br>直接向<em>functions</em>请求，可以是：无服务器功能调用（例如Lambda，Google Cloud Function，OpenFaaS函数等）；<br>微服务或旧服务上的API调用（例如REST API调用，OpenAPI操作，XML / SOAP请求等）；<br>或发布到邮件队列（例如，NATS，AMQP等）。 这种独特的功能使Gloo成为唯一的API网关<br>支持混合应用程序，以及不将用户绑定到特定范例的唯一应用程序。</p></li><li><p><strong>Gloo包含经过审查的开源项目，以提供广泛的功能</strong>：Gloo通过与顶级开源项目（包括gRPC，GraphQL，OpenTracing，NATS等）集成来支持高质量功能。<br>Gloo的体系结构允许在将来流行的开源项目出现时快速集成它们。</p></li><li><p><strong>全自动发现使用户可以快速移动</strong>：Gloo在启动时会创建所有可用目的地的目录，并不断对其进行更新。 这使开发人员无需承担“记账”的责任，并确保新功能<br>在准备就绪后立即可用。 Gloo跨IaaS，PaaS和FaaS提供程序以及Swagger，gRPC和GraphQL发现。</p></li><li><p><strong>Gloo与用户环境紧密集成</strong>：通过Gloo，用户可以自由选择自己喜欢的调度工具（例如K8S，Nomad，OpenShift等），持久性（K8s，Consul等）和安全性<br>（K8s, Vault）。</p></li></ul><h4 id="路由特性"><a href="#路由特性" class="headerlink" title="路由特性"></a>路由特性</h4><ul><li><p><strong>动态负载均衡</strong>:跨多个上游服务负载均衡流量。</p></li><li><p><strong>健康检查</strong>: 主动和被动监视上游服务。</p></li><li><p><strong>OpenTracing标准</strong>: 使用支持良好的OpenTracing标准监视请求。</p></li><li><p><strong>监控</strong>: 支持Prometheus、Statsd方式监控。</p></li><li><p><strong>SSL</strong>: 高度可定制的选项，用于向上游服务添加SSL加密，并完全支持SNI。</p></li><li><p><strong>转换</strong>: 添加，删除或处理HTTP请求和响应。</p></li></ul><h4 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h4><p>Gloo可以轻松应对管理入口流量进入应用程序架构（不单单是Kubernetes）的挑战。在Kubernetes，AWS Lambda，VM，Terraform，EC2，Consul<br>等架构/平台中运行时，可以动态发现后端服务。Gloo同时也被选为KNative项目的首选ingress项目，其主要有以下特性。</p><ul><li>解决云原生和混合云的挑战：微服务使应用程序的API更加复杂。 Gloo实现了API网关模式，通过实现管理平面来提升业务的可操作性。</li><li>构建Envoy代理：Gloo是Envoy Proxy的控制平面，使开发人员和操作员可以通过以声明性格式的xDS gRPC API动态更新Envoy配置。</li><li>服务网格的基石：Gloo将服务网格功能添加到集群入口。 Gloo允许您以迭代的方式渐进式使用高级功能，并与诸如Flagger的系统进<br>行金丝雀自动化发布，同时以本地化方式插入服务网格实现（如Istio，Linkerd或Consul）。</li><li>针对应用程序的集成：Gloo可以将请求直接路由到Function、微服务或遗留服务上的API，或发布到消息队列。这种独特的功能使Gloo成为支持混合应用程序的唯一<br>API网关，而不会将用户束缚于特定的技术方案。</li><li>强大的社区特性：Gloo通过与顶级开源项目（如gRPC，GraphQL，OpenTracing，NATS等）集成来支持高级别功能。 Gloo的技术架构允许在未来流行的开源项目<br>出现时快速集成。</li><li>全自动发现能力：Gloo动态发现能力，跨IaaS，PaaS和FaaS</li><li>与现有工具集成：使用Gloo，用户可以自由选择自己喜欢的调度工具（例如K8S，Nomad，OpenShift等），持久化（K8S，Consul等）和安全特性（K8，Vault）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/17/Ygqhod.md.png&quot; alt=&quot;架构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Gloo是一种基于Kubernetes原生设计的功能丰富的Ingress Controller，致力于成为下一代API网关标杆产品。 Gloo在函数级路由等方面表现优异；对旧式应&lt;br&gt;用、微服务和serverless提供支持； 它具备高效的发现能力，且功能多样； 并与领先的开源项目（如Envoy、KNative等）紧密集成。 Gloo的独特设计旨在支持&lt;br&gt;异构应用程序，与多种技术，体系结构，协议和云中共存。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18 福履将之</title>
    <link href="https://ustack.io/2020-03-25-Kubernetes%201.18%20%E7%A6%8F%E5%B1%A5%E5%B0%86%E4%B9%8B.html"/>
    <id>https://ustack.io/2020-03-25-Kubernetes 1.18 福履将之.html</id>
    <published>2020-03-25T12:40:08.000Z</published>
    <updated>2020-03-25T10:32:17.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt="k8s"></p><div class="note info"><p>Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？</p><p>有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。</p><p>我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。</p></div><p>此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！</p><p>以下为Kubernetes 1.18中新功能的详细列表。</p><a id="more"></a><hr><h3 id="一、版本维护"><a href="#一、版本维护" class="headerlink" title="一、版本维护"></a>一、版本维护</h3><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、Kubernetes-1-18-主要变更"><a href="#二、Kubernetes-1-18-主要变更" class="headerlink" title="二、Kubernetes 1.18 主要变更"></a>二、Kubernetes 1.18 主要变更</h3><h4 id="核心变更"><a href="#核心变更" class="headerlink" title="核心变更"></a>核心变更</h4><ol><li>＃1393 为服务帐户提供OIDC的支持</li></ol><p>维护阶段：Alpha<br>SIG-Group：auth</p><p>Kubernetes服务帐户（KSA）可以使用令牌（JSON Web令牌或JWT）对Kubernetes API进行身份验证，例如使用kubectl –token &lt;the_token_string&gt;。需要注意的是，Kubernetes API是唯一可以验证这些令牌的服务。</p><p>由于无法（也不应该）从公共网络访问Kubernetes API服务器，因此某些工作负载必须使用单独的系统进行身份验证。比如跨群集进行身份验证时，从群集内部到其他地方进行身份验证。</p><p>此增强功能旨在让KSA令牌更实用，从而使群集外部的服务可以将它们用作常规身份验证方法，而不会使API Server过载。为此，API服务器提供了一个OpenID Connect（OIDC）相关文档，其中包含令牌公共密钥以及其他数据。现有的OIDC身份验证者可以使用这些密钥来验证KSA令牌等。</p><p>可以使用ServiceAccountIssuerDiscovery功能门启用OIDC发现，但需要进行一些配置才能使用。</p><ol start="2"><li>＃853 HPA的扩展速度可配</li></ol><p>维护阶段：Alpha<br>SIG-Group：autoscaling</p><p>HPA可以自动扩展Pod的数量，以满足调整工作负载的需求。 到目前为止，您只能为整个集群定义全局缩放速度。 但是，并非所有应用场景的使用资源情况都一样，因此您可能更需要的是针对特殊群体的扩展效率的个性化方案。</p><p>现在，可以将这些需求添加到HPA配置中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line"><span class="attr">   scaleDown:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Percent</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">   scaleUp:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Pods</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p>在此示例中，pod可以每15秒加倍。 缩容时，每分钟可以减少四个pod。 检查文档中的完整语法。</p><ol start="3"><li>＃1513 CertificateSigningRequest API</li></ol><p>维护阶段：Beta<br>SIG-Group：auth</p><p>每个Kubernetes集群都有一个根证书颁发机构，该CA用于保护核心组件之间的通信，这些组件由Certificates API处理，它开始用于为非核心用途提供证书。</p><p>此增强功能旨在适应新的应用场景，从而改善签名过程及其安全性。</p><p>注册机构的数字，即批准者，确保实际的请求者已经提交了证书签名请求（CSR）； 同时他们还确保请求者具有提交该请求的适当权限。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKbd0.md.png" alt="CertificateSigningRequest-API"></p><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ol><li>＃1451 运行多个调度配置文件</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>并非Kubernetes集群中的所有工作负载都相同。您很可能希望将Web服务器分布在尽可能多的节点上，同时您可能希望在同一节点中捆绑尽可能多的对延迟敏感的资源。这就是为什么您需要在同一集群中配置多个调度程序，并指定每个Pod使用哪个调度程序的原因。</p><p>但是，这可能会导致竞争状况，因为每个调度程序在给定时刻可能具有不同的集群资源数据。</p><p>此增强功能使您可以运行一个具有不同配置的调度程序，每个配置都有其自己的调度名称。 Pod会继续使用schedulerName来定义要使用的配置文件，但是它将由相同的调度程序来完成工作，从而避免出现竞争情况。</p><ol start="2"><li>＃895 topologySpreadConstraints</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：scheduling</p><p>使用topologySpreadConstraints，您可以定义规则以在整个多区域群集中均匀分布pod，因此高可用性将正确运行，并且资源利用率将得到提高。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃1258添加可配置的默认Even Pod传播规则</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>为了利用均匀的pod扩散优势，每个pod都需要有自己的扩散规则，这可能是一项繁琐的任务。</p><p>通过此增强功能，您可以定义全局defaultConstraints，这些默认defaultConstraints将在群集级别应用到所有未定义其自己的topologySpreadConstraints的Pod。</p><ol start="4"><li>＃166基于污点驱逐</li></ol><p>维护阶段：GA<br>SIG-Group：scheduling</p><p>在Kubernetes 1.13中，基于污点的驱逐的功能，在从alpha阶段变为beta阶段后，默认启用此功能（–feature-gates中的TaintBasedEvictions = true），NodeController（或kubelet）会自动添加污点，并且基于Ready NodeCondition禁用了从节点逐出pod的逻辑。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ol><li>＃1539扩展HugePages功能</li></ol><p>维护阶段：GA<br>SIG-Group：node</p><p>HugePages是一种保留具有预定义大小的大内存块的机制，由于硬件优化，这些块可以更快地访问。这对于处理内存中的大的数据集或对内存访问延迟敏感的应用程序（例如数据库或虚拟机）特别有用。</p><p>在Kubernetes 1.18中，此功能添加了两个增强配置。</p><p>首先，现在允许Pod请求不同大小的HugePage。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        hugepages-2Mi:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">        hugepages-1Gi:</span> <span class="number">2</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>其次，已经实现了HugePages的容器隔离，以解决Pod可能使用比请求更多的内存，最终导致资源匮乏的问题。</p><ol start="2"><li>＃688 Pod Overhead：帐户资源绑定到Pod沙箱，但不包含特定的容器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>除了请求的资源之外，您的Pod还需要额外的资源来维护其运行时环境。</p><p>启用PodOverhead功能后，Kubernetes将在调度Pod时考虑到此开销。此开销与pod使用的RuntimeClass相关联。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃693节点拓扑管理器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>机器学习，科学计算和金融服务是计算密集型且要求超低延迟的系统的场景。这些类型的工作负载受益于隔离到一个CPU内核的进程，而不是在内核之间切换或与其他进程共享。</p><p>节点拓扑管理器是一个kubelet组件，可集中协调硬件资源分配。当前方法将此任务划分为几个组件（CPU管理器，设备管理器，CNI），这有时会导致分配未优化。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃950为慢启动的pod添加pod-startup、liveness-probe</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>探针使Kubernetes可以监视应用程序的状态。如果Pod启动所需的时间太长，这些探针可能会认为Pod已死，从而导致重新启动循环。此功能使您可以定义一个启动探针，该探针将推迟所有其他探针，直到容器完成其启动。例如，“在给定的HTTP端点可用之前，请勿测试活动性”。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="网路"><a href="#网路" class="headerlink" title="网路"></a>网路</h4><ol><li>＃752 EndpointSlice API</li></ol><p>维护阶段：Beta重大更新<br>SIG-Group：network</p><p>新的EndpointSlice API将把端点分为几个Endpoint Slice资源。这解决了当前API中与大型Endpoints对象有关的许多问题。该新API还旨在支持其他将来的功能，例如每个吊舱有多个IP。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="2"><li>＃508 IPv6支持添加</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>早在Kubernetes 1.9上就引入了对仅IPv6群集的支持。此功能已由社区进行了广泛的测试，现在正逐步升级为Beta。</p><ol start="3"><li>＃1024 节点本地DNS缓存到GA</li></ol><p>阶段：毕业至稳定<br>功能组：网络</p><p>NodeLocal DNSCache通过在群集节点上作为Daemonset运行dns缓存代理来提高群集DNS性能，从而避免了iptables DNAT规则和连接跟踪。本地缓存代理将查询dns服务以获取集群主机名的未命中缓存（默认为cluster.local后缀）。</p><p>您可以阅读其Kubernetes增强建议（KEP）文档中的设计说明，以了解有关此Beta功能的更多信息。</p><p>在1.15版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1453 ingress功能增强</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>Ingress资源将外部HTTP和HTTPS路由公开为服务，集群中的其他服务可以访问这些服务。</p><p>该API对象包含在Kubernetes 1.1中，成为事实上的稳定功能。此增强功能消除了Ingress实施之间的不一致之处。</p><p>例如，您现在可以定义一个pathType来显式声明将路径视为前缀还是完全匹配。如果Ingress中的多个路径与请求匹配，则最长的匹配路径将优先。</p><p>另外，不建议使用kubernetes.io/ingress.class注释。现在应该使用新的ingressClassName字段和IngressClass资源。</p><ol start="5"><li>＃1507将AppProtocol添加到服务和端点</li></ol><p>维护阶段：GA<br>SIG-Group：network</p><p>EndpointSlice API在Kubernetes 1.17中添加了一个新的AppProtocol字段，以允许为每个端口指定应用程序协议。此增强功能将该字段带入ServicePort和EndpointPort资源中，替换了可能引起不良用户体验的非标准注释。</p><h4 id="API相关"><a href="#API相关" class="headerlink" title="API相关"></a>API相关</h4><ol><li>＃1040 API服务器请求的优先级和公平性</li></ol><p>维护阶段：Alpha<br>SIG-Group：api-machinery</p><p>在高负载期间，Kubernetes API服务器需要负责管理和维护任务。现有的–max-requests-inflight和–max-mutating-requests-inflight命令行标志可以限制传入的请求，但它们的粒度过于粗糙，并且在流量繁忙时会过滤掉重要的请求。</p><p>APIPriorityAndFairness功能门可在apiserver中启用新的请求处理流程。您可以使用FlowSchema对象定义不同类型的请求，并使用RequestPriority对象为它们设定资源优先级。</p><p>例如，垃圾收集器是低优先级服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">FlowSchema</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  matchingPriority:</span> <span class="number">900</span></span><br><span class="line"><span class="attr">  requestPriority:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">  flowDistinguisher:</span></span><br><span class="line"><span class="attr">    source:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  match:</span></span><br><span class="line"><span class="attr">  - and:</span></span><br><span class="line"><span class="attr">    - equals:</span></span><br><span class="line"><span class="attr">      field:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">system:controller:garbage-collector</span></span><br></pre></td></tr></table></figure><p>因此，您可以为其分配很少的资源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>但是，自我维护请求具有更高的优先级：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-high</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">  handSize:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>您可以在增强建议中找到更多示例。</p><ol start="2"><li>＃1601 client-go签名相关重构，以标准化选项和上下文处理</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>在client-go上已经完成了一些代码重构，许多文件都使用该库来连接到Kubernetes API，以保持方法签名的一致性。</p><p>这包括向一些方法中添加上下文对象，该对象在API边界和进程之间承载请求范围的值。访问此对象可简化一些功能的实现，例如在超时和取消后释放调用线程，或添加对分布式跟踪的支持。</p><ol start="3"><li>＃576 APIServer DryRun</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>ryRun运行模式使您可以模拟真实的API请求，并查看请求是否成功（准入控制器链，验证，合并冲突等）和在不实际修改状态的情况下会发生什么。该请求的响应主体应尽可能接近非空运行响应。此核心功能将启用其他用户级别的功能，例如kubectl diff子命令。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1281 API服务器网络代理KEP到Beta</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：api-machinery</p><p>有些用户（大多数是云提供商）更喜欢将其群集API Server隔离在单独的控制网络中，而不是在集群网络中。实现此功能的一种方法是保持与其他集群组件的连通性，同时使用API Server网络代理。</p><p>具有此额外的层可以启用其他功能，例如元数据审核日志记录和传出API服务器连接的验证。</p><p>在Kubernetes 1.18中，API Server代理允许在服务，节点，webhooks和Pods之外的单独网络中分离API。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKOiT.md.png" alt="Kubernetes-1.18-enhancement-1281-API-Server-Network-Proxy.png"></p><p>此增强功能涵盖了解决一些已知问题并让该代理支持一般性的工作，例如从Kubernetes API服务器中删除SSH隧道代码，以及改善控制网络与集群网络的隔离。</p><h4 id="Windows变更"><a href="#Windows变更" class="headerlink" title="Windows变更"></a>Windows变更</h4><ol><li>＃1001在Windows上支持CRI-ContainerD</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>ContainerD是与Kubernetes兼容的OCI兼容运行时。与Docker相反，ContainerD在Windows Server 2019中包括对主机容器服务（HCS v2）的支持，该服务可更好地控制容器的管理方式并可以改善Kubernetes API的兼容性。</p><p>此增强功能引入了Windows中作为容器运行时接口（CRI）的ContainerD 1.3支持。在此增强页面中查看更多详细信息。</p><ol start="2"><li>＃1301在Windows上实现RuntimeClass</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>使用RuntimeClass，您可以定义集群中存在的不同类型的节点，然后使用runtimeClassName指定可以将Pod部署在哪些节点中。此功能在Kubernetes 1.12上引入，并在Kubernetes 1.14上进行了重大更改。</p><p>此增强功能将此功能扩展到Windows节点，这在异构集群包含Windows Pod时，对部署在Windows节点上非常有用。这是定义RuntimeClass的方法，以将pod限制为Windows Server 1903版（10.0.18362）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">node.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RuntimeClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">windows-1903</span></span><br><span class="line"><span class="attr">handler:</span> <span class="string">'docker'</span></span><br><span class="line"><span class="attr">scheduling:</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line">    <span class="string">kubernetes.io/os:</span> <span class="string">'windows'</span></span><br><span class="line">    <span class="string">kubernetes.io/arch:</span> <span class="string">'amd64'</span></span><br><span class="line">    <span class="string">node.kubernetes.io/windows-build:</span> <span class="string">'10.0.18362'</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">windows</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Equal</span></span><br><span class="line"><span class="attr">    value:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>然后，您需要在pod中使用runtimeClassName，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  runtimeClassName:</span> <span class="string">windows-1903</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>检查增强页面以获取更多详细信息。</p><ol start="3"><li>＃689为Windows工作负载支持GMSA</li></ol><p>维护阶段：GA<br>SIG-Group：windows</p><p>这将使操作员可以在部署时选择GMSA，并使用它运行容器以连接到现有应用程序（例如数据库或API服务器），而无需更改组织内部对身份验证和授权的管理方式。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1043 Windows版RunAsUserName</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：windows</p><p>现在，Kubernetes支持组托管服务帐户，我们可以使用Windows的runAsUserName特定属性来定义哪个用户将运行容器的入口点。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="5"><li>＃995 Windows版Kubeadm</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：cluster-lifecycle</p><p>Kubernetes 1.14中引入了对Windows节点的支持，但是没有一种简单的方法可以将Windows节点加入集群。</p><p>从Kubernetes 1.16开始，具有部分功能的Windows用户可以使用kubeadm join。它将缺少一些功能，例如kubeadm init或kubeadm join –control-plane。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol><li>＃695跳过卷所有权更改</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>在将卷绑定安装到容器内之前，其所有文件权限都将更改为提供的fsGroup值。这最终会导致非常大的卷上的缓慢过程，还会破坏一些对权限敏感的应用程序，例如数据库。</p><p>已添加新的FSGroupChangePolicy字段以控制此行为。如果设置为始终，它将保持当前行为。但是，当设置为OnRootMismatch时，仅当顶级目录与预期的fsGroup值不匹配时，它才会更改卷权限。</p><ol start="2"><li>＃1412不可变的Secrets和ConfigMap</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>新的不可变字段已添加到Secrets和ConfigMaps中。设置为true时，将拒绝对资源密钥所做的任何更改。这样可以保护集群数据，避免意外或错误更新从而破坏应用程序。</p><p>由于它们不变，因此Kubelet不需要定期检查其更新，这可以提高可伸缩性和性能。</p><p>启用ImmutableEmphemeralVolumes功能门之后，您可以执行以下操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是，一旦将资源标记为不可变，就无法还原此更改。您只能删除并重新创建密钥，并且需要重新创建使用已删除密钥的Pod。</p><ol start="3"><li>＃1495通用数据填充器</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>这项增强功能为用户创建预先填充的卷奠定了基础。例如，使用操作系统映像预填充用于虚拟机的磁盘，或启用数据备份和还原。</p><p>为此，将取消对持久卷的DataSource字段的当前验证，从而允许将任意对象设置为值。有关如何填充卷的实现详细信息委托给专用控制器。</p><ol start="4"><li>＃770</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>这种内部优化将简化为不需要附加/分离操作的容器存储接口（CSI）驱动程序（例如NFS或临时机密卷）创建VolumeAttachment对象的操作。</p><p>对于这些驱动程序，Kubernetes Attach/Detach控制器始终创建VolumeAttachment对象，并一直等到它们被报告为“已绑定”。对CSI卷插件进行了更改，以跳过此步骤。</p><ol start="5"><li>＃351使用永久卷源的BlockVolume</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>BlockVolume在Kubernetes 1.18中达到了常规可用性。您可以仅将volumeMode的值设置为block即可访问原始块设备。使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的高性能应用程序（如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="6"><li>＃565 CSI块存储支持</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的应用程序（例如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="7"><li>＃603在CSI调用中传递Pod信息</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>CSI存储驱动程序可以选择接收关于在NodePublish请求中请求卷的Pod的信息，例如Pod名称和名称空间。</p><p>CSI驱动程序可以使用此信息来授权或审核卷的使用，或生成针对Pod定制的卷内容。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="8"><li>＃989扩展允许的PVC数据源</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用此功能，可以“克隆”现有的持久卷。克隆会导致从现有卷中调配新的重复卷。</p><p>在1.15版本的Kubernetes新增功能中阅读更多内容。</p><hr><h3 id="Kubernetes-1-18-其他更新"><a href="#Kubernetes-1-18-其他更新" class="headerlink" title="Kubernetes 1.18 其他更新"></a>Kubernetes 1.18 其他更新</h3><ol><li>＃1441 kubectl调试</li></ol><p>维护阶段：Alpha<br>SIG-Group：功能组：cli</p><p>添加了新的kubectl debug命令以扩展调试功能。</p><p>此命令允许在正在运行的Pod中创建临时容器，使用修改后的PodSpec重新启动Pod，以及启动并附加到主机名称空间中的特权容器。</p><ol start="2"><li>＃1020将kubectl软件包代码移至暂存</li></ol><p>维护阶段：GA<br>SIG-Group：功能组：cli</p><p>kubectl代码的这种内部重组是将kubectl二进制文件移到其自己的存储库中的第一步。这有助于将kubectl与kubernetes代码库分离，并使树外项目更易于重用其代码。</p><ol start="3"><li>＃1333禁用没有Beta REST API或功能</li></ol><p>维护阶段：Beta<br>SIG-Group：architecture</p><p>此增强功能收集了所做的工作，以确保Kubernetes组件和Kubernetes一致性都不依赖于Beta REST API或功能。最终目标是确保各个发行版之间的一致性，因为启用非GA功能不需要使用非官方发行版（例如k3s，Rancher或Openshift）。</p><ol start="4"><li>＃491 Kubectl Diff</li></ol><p>维护阶段：GA<br>SIG-Group：cli</p><p>kubectl diff将为您预览kubectl将对您的集群进行哪些更改。尽管易于描述，但此功能对于群集操作员的日常工作确实非常方便。请注意，您需要在API服务器上启用dry run功能，此命令才能起作用。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃670支持vSphere Cloud Provider</li></ol><p>维护阶段：GA<br>SIG-Group：cloud-provider</p><p>提供对vSphere云提供商的支持。这涉及到经过测试的云控制器管理器版本，该版本具有与kube-controller-manager奇偶校验的功能。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.18.md" target="_blank" rel="noopener">kubernetes 1.18</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt=&quot;k8s&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？&lt;/p&gt;
&lt;p&gt;有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。&lt;/p&gt;
&lt;p&gt;我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！&lt;/p&gt;
&lt;p&gt;以下为Kubernetes 1.18中新功能的详细列表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18之Ingress API优化</title>
    <link href="https://ustack.io/2020-03-25-Kubernetes%201.18%E4%B9%8BIngress%20API%E4%BC%98%E5%8C%96.html"/>
    <id>https://ustack.io/2020-03-25-Kubernetes 1.18之Ingress API优化.html</id>
    <published>2020-03-25T12:40:08.000Z</published>
    <updated>2020-04-09T02:42:00.833Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>Kubernetes中的Ingress API对外提供简单而功能强劲的方法来管理与kubernetes集群内工作负载通信的入网流量。 在Kubernetes 1.18版本中，我们对Ingress API进行了以下3项重大改进：</p><ul><li>新增pathType字段，可以指定应该匹配哪种Ingress路径</li><li>新增IngressClass资源，可以指定控制器应如何实现Ingress</li><li>支持主机名的通配符</li></ul></div><a id="more"></a><h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>新增的pathType字段，可以指定应该匹配哪种Ingress路径。 当前支持三种类型：</p><ul><li>ImplementationSpecific（默认）: 使用此路径类型，匹配方式取决于实现IngressClass的控制器</li><li>完全匹配: 与URL完全匹配且区分大小写</li><li>前缀: 以/分隔的URL路径前缀进行匹配。 匹配区分大小写，并且在逐个路径的基础上进行匹配</li></ul><h3 id="Ingress配置增强"><a href="#Ingress配置增强" class="headerlink" title="Ingress配置增强"></a>Ingress配置增强</h3><p>Ingress资源在设计时秉承简易性设计准则，从而提供了一组简易字段以满足绝大多数应用场景。 但随着时间的推移，以及使用场景的拓宽，开始依赖各种的自定义注释来进行进一步的配置。 因此新的Ingress资源提供了一种替换注释的方案。</p><p>在Ingress规范中添加了一个新的ingressClassName字段，该字段用于决定应用于该Ingress的具体IngressClass。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  controller:</span> <span class="string">example.com/ingress-controller</span></span><br><span class="line"><span class="attr">  parameters:</span></span><br><span class="line"><span class="attr">    apiGroup:</span> <span class="string">k8s.example.com/v1alpha</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">IngressParameters</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">external-lb</span></span><br></pre></td></tr></table></figure><h3 id="弃用Ingress注释"><a href="#弃用Ingress注释" class="headerlink" title="弃用Ingress注释"></a>弃用Ingress注释</h3><p>在Kubernetes 1.18发布（即添加IngressClass资源）之前，通常会在Ingress上使用kubernetes.io/ingress.class注释来指定某类Ingress。尽管从未正式定义此注释，但Ingress控制器已广泛支持此注释，现在正式弃用该字段。</p><h3 id="设置默认的IngressClass"><a href="#设置默认的IngressClass" class="headerlink" title="设置默认的IngressClass"></a>设置默认的IngressClass</h3><p>可以在集群中将特定的IngressClass标记为默认值。在IngressClass资源上将注释<code>ingressclass.kubernetes.io/is-default-class</code>设置为true，就能够确保为未指定ingressClassName的新Ingress关联此默认IngressClass。</p><h2 id="支持主机名通配符"><a href="#支持主机名通配符" class="headerlink" title="支持主机名通配符"></a>支持主机名通配符</h2><p>许多Ingress提供程序都支持通配符主机名匹配，例如<code>* .foo.com</code>和<code>app1.foo.com</code>匹配，但是直到现在，规范都假定主机的FQDN完全匹配。当前，主机可以是精确匹配项（例如<code>foo.bar.com</code>）或通配符（例如<code>* .foo.com</code>）。精确匹配要求http主机头与主机设置匹配。通配符匹配要求http主机标头等于通配符规则的后缀。</p><table><thead><tr><th>Host</th><th>Host header</th><th>Match</th></tr></thead><tbody><tr><td>*.foo.com</td><td>*.foo.com</td><td>Matches based on shared suffix</td></tr><tr><td>*.foo.com</td><td>*.foo.com</td><td>No match, wildcard only covers a single DNS label</td></tr><tr><td>*.foo.com</td><td>foo.com</td><td>No match, wildcard only covers a single DNS label</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这些新的Ingress功能可实现更多可配置性。 下面是一个同时使用pathType，ingressClassName和主机名通配符的Ingress示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ingressClassName:</span> <span class="string">external-lb</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">*.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/example</span></span><br><span class="line"><span class="attr">        pathType:</span> <span class="string">Prefix</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">example-service</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Ingress-Controller支持"><a href="#Ingress-Controller支持" class="headerlink" title="Ingress Controller支持"></a>Ingress Controller支持</h3><p>由于这些功能是Kubernetes 1.18中的新增特性，因此每个Ingress控制器都需要一些时间来开发以完成对这些新功能的支持。首选查看Ingress控制器的相关文档，以了解它们何时将支持此新功能。</p><h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><p>在Kubernetes 1.19版本发布时，Ingress API有望从Beta变为GA。它将继续为用户管理Kubernetes工作负载的入网流量提供一种简单的方法。该API在保持简单和轻巧特性的同时希望为更复杂的用户场景提供更灵活的配置方案。</p><p>目前正在开发一套高度可配置的API，这些API在未来将成为Ingress的可选方案。这些API被称为新的“Service APIs”。当然其无意替代任何现有的API，而只是为复杂的用例提供了一种更灵活的配置方案。有关更多信息，请查看GitHub上的Service APIs。</p><p>原文链接：<a href="https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/" target="_blank" rel="noopener">Improvements to the Ingress API in Kubernetes 1.18</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes中的Ingress API对外提供简单而功能强劲的方法来管理与kubernetes集群内工作负载通信的入网流量。 在Kubernetes 1.18版本中，我们对Ingress API进行了以下3项重大改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增pathType字段，可以指定应该匹配哪种Ingress路径&lt;/li&gt;
&lt;li&gt;新增IngressClass资源，可以指定控制器应如何实现Ingress&lt;/li&gt;
&lt;li&gt;支持主机名的通配符&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>CNCF在中国 2020</title>
    <link href="https://ustack.io/2020-03-24-CNCF%E5%9C%A8%E4%B8%AD%E5%9B%BD%202019.html"/>
    <id>https://ustack.io/2020-03-24-CNCF在中国 2019.html</id>
    <published>2020-03-24T15:01:21.000Z</published>
    <updated>2020-03-25T10:11:35.094Z</updated>
    
    <content type="html"><![CDATA[  <div class="note info"><p>在开发Android项目的时候，使用的是<code>Gradle</code>构建工具，喜欢它的灵活和方便，在转向Java后端开发的时候更多时候使用的是<code>Maven</code>构建工具，然而看着漫天的尖括号，心里实在是难受。虽然只是一个构建工具，本着折腾的心，我还是更认可和看好<code>Gradle</code>。然而很多时候你的队友并没有习惯去使用或者快速熟悉<code>Gradle</code>构建工具，那么这个时候就需要将<code>Gradle</code>项目转换为Maven项目了，或者将Maven项目转换为<code>Gradle</code>项目了。</p></div><a id="more"></a><h3 id="安装Gradle／Maven"><a href="#安装Gradle／Maven" class="headerlink" title="安装Gradle／Maven"></a>安装Gradle／Maven</h3><p>首先是安装构建工具，这个没啥好说的。</p><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>打开Powershell或者Cmder执行以下命令完成安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco install gradle</span><br><span class="line">choco install maven</span><br></pre></td></tr></table></figure><p><code>choco</code>为windows下的一款包管理工具，可以方便安装管理配置一些常见的软件包，如果你没有安装<code>choco</code>的话，请移步：<a href="https://chocolatey.org/" target="_blank" rel="noopener">https://chocolatey.org/</a></p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>打开Terminal，执行以下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br><span class="line">brew install maven</span><br></pre></td></tr></table></figure><h3 id="Maven-to-Gradle"><a href="#Maven-to-Gradle" class="headerlink" title="Maven to Gradle"></a>Maven to Gradle</h3><p>需要特别说明的是，<code>Gradle</code>对<code>Maven</code>的支持是比较完善的，因此，转换也是非常的简单，在<code>pom.xml</code>文件所在的目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle init     # 根据pom.xml内容生成对应的gradle配置</span><br><span class="line">gradle build    # 开启gradle构建</span><br></pre></td></tr></table></figure><hr><h3 id="Gradle-to-Maven"><a href="#Gradle-to-Maven" class="headerlink" title="Gradle to Maven"></a>Gradle to Maven</h3><p><code>Gradle</code>项目转<code>Maven</code>项目需要借助一个Gradle插件，在项目的<code>module</code>的<code>build.gradle</code>文件中加入以下配置即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br></pre></td></tr></table></figure><p>通过双击<code>Idea</code>的Gradle Tasks GUI:</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5qcx3csoj20j20ee0ua.jpg" alt></p><p>或者执行命令来完成转换:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle install</span><br></pre></td></tr></table></figure><p>完成之后，将会在当前Module项目的<code>build</code>目录下的<code>poms</code>文件夹下生成<code>pom-default.xml</code>，将其拷贝到项目的根目录下即可。</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5pn78lbhj20ik0g4jsk.jpg" alt></p><ul><li>参考文档：<a href="https://guides.gradle.org/migrating-from-maven/" target="_blank" rel="noopener">https://guides.gradle.org/migrating-from-maven/</a></li></ul><hr><p>通过实际测试，这样的生成的<code>pom-default.xml</code>文件是不能用于直接<code>maven</code>构建的，因为生成的<code>pom-default.xml</code>文件中的<code>groupId</code>还需要我们手动指定下。这样显然是不清真的，于是我们可以在<code>build.gradle</code>文件中将其事先定义好，这样生成的pom文件就不用我们再手动更改了：</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5pvzyw2xj20ni0dign1.jpg" alt></p><p>然而这样我们还是觉得麻烦，毕竟需要手动复制到项目根目录，再重新命名。我们还可以通过Hook Gradle中Maven插件的<code>install</code>Task来完成自动的复制和命名,编辑<code>build.gradle</code>:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task convert2Maven &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        file(<span class="string">"$buildDir/poms/pom-default.xml"</span>).renameTo(file(<span class="string">"$rootDir/pom.xml"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">install.dependsOn(convert2Maven)</span><br></pre></td></tr></table></figure><p>此时，再执行<code>gradle install</code>这个task就可以看到gradle已经自动为我们在项目的根目录下生成好了<code>pom.xml</code>文件啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在开发Android项目的时候，使用的是&lt;code&gt;Gradle&lt;/code&gt;构建工具，喜欢它的灵活和方便，在转向Java后端开发的时候更多时候使用的是&lt;code&gt;Maven&lt;/code&gt;构建工具，然而看着漫天的尖括号，心里实在是难受。虽然只是一个构建工具，本着折腾的心，我还是更认可和看好&lt;code&gt;Gradle&lt;/code&gt;。然而很多时候你的队友并没有习惯去使用或者快速熟悉&lt;code&gt;Gradle&lt;/code&gt;构建工具，那么这个时候就需要将&lt;code&gt;Gradle&lt;/code&gt;项目转换为Maven项目了，或者将Maven项目转换为&lt;code&gt;Gradle&lt;/code&gt;项目了。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="CloudNative" scheme="https://ustack.io/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之接口</title>
    <link href="https://ustack.io/2019-12-02-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://ustack.io/2019-12-02-Golang漫谈之接口.html</id>
    <published>2019-12-02T12:40:08.000Z</published>
    <updated>2019-12-01T13:14:29.137Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>什么是interface，简单的说，interface是一组method的组合，下面这篇文章主要给大家深度解析了关于golang中的interface接口，该文章主要介绍，以下内容:</p><ul><li>接口介绍及范例</li><li>接口详情</li><li>接口与反射</li><li>接口源码</li></ul><a id="more"></a><hr><h4 id="一、接口介绍及范例"><a href="#一、接口介绍及范例" class="headerlink" title="一、接口介绍及范例"></a>一、接口介绍及范例</h4><p>如果说gorountine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道亮丽的风景，那么接口是Go语言整个类型系列的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度。Go语言在编程哲学上是变革派，而不是改良派。这不是因为Go语言有gorountine和channel，而更重要的是因为Go语言的类型系统，更是因为Go语言的接口。Go语言的编程哲学因为有接口而趋于完美。C++,Java 使用”侵入式”接口，主要表现在实现类需要明确声明自己实现了某个接口。这种强制性的接口继承方式是面向对象编程思想发展过程中一个遭受相当多质疑的特性。Go语言采用的是“非侵入式接口”,Go语言的接口有其独到之处：只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方，所谓类型T的公开方法完全满足接口I的要求，也即是类型T实现了接口I所规定的一组成员。这种做法的学名叫做Structural Typing，有人也把它看作是一种静态的Duck Typing。</p><p>在 Golang 中，interface 是一组 method 的集合，是 duck-type programming 的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。下面是一种 interface 的典型用法，定义函数的时候参数定义成 interface，调用函数的时候就可以做到非常的灵活。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line"> Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err os.Error)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Writer 是包裹了基础 Write 方法的接口。</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123; </span><br><span class="line"> Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err os.Error)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure><p>有一个事情是一定要明确的，不论 r 保存了什么值，r 的类型总是 io.Reader ,Go 是静态类型，而 r 的静态类型是 io.Reader。接口类型的一个极端重要的例子是空接口interface{},它表示空的方法集合，由于任何值都有零个或者多个方法，所以任何值都可以满足它。也有人说 Go 的接口是动态类型的，不过这是一种误解。 它们是静态类型的：接口类型的变量总是有着相同的静态类型，这个值总是满足空接口，只是存储在接口变量中的值运行时可能被改变。对于所有这些都必须严谨的对待，因为反射和接口密切相关。</p><h5 id="1-1、范型"><a href="#1-1、范型" class="headerlink" title="1.1、范型"></a>1.1、范型</h5><p>严格来说，在 Golang 中并不支持泛型编程。在 C++ 等高级语言中使用泛型编程非常的简单，所以泛型编程一直是 Golang 诟病最多的地方。但是使用 interface 我们可以实现泛型编程，我这里简单说一下，具体可以参考我前面给出来的那篇文章。比如我们现在要写一个泛型算法，形参定义采用 interface 就可以了，以标准库的 sort 为例。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.</span></span><br><span class="line">    n := data.Len()</span><br><span class="line">    maxDepth := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := n; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">        maxDepth++</span><br><span class="line">    &#125;</span><br><span class="line">    maxDepth *= <span class="number">2</span></span><br><span class="line">    quickSort(data, <span class="number">0</span>, n, maxDepth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sort 函数的形参是一个 interface，包含了三个方法：Len()，Less(i,j int)，Swap(i, j int)。使用的时候不管数组的元素类型是什么类型（int, float, string…），只要我们实现了这三个方法就可以使用 Sort 函数，这样就实现了“泛型编程”。有一点比较麻烦的是，我们需要将数组自定义一下。下面是一个例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByAge implements sort.Interface for []Person based on</span></span><br><span class="line"><span class="comment">// the Age field.</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person <span class="comment">//自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []Person&#123;</span><br><span class="line">        &#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(people)</span><br><span class="line">    sort.Sort(ByAge(people))</span><br><span class="line">    fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们设计函数的时候，下面是一个比较好的准则。</p><blockquote><p>Return concrete types, receive interfaces as parameter. — Robustness Principle applied to Go</p></blockquote><p>话说这么说，但是当我们翻阅 Golang 源码的时候，有些函数的返回值也是 interface。</p><h5 id="1-2、隐藏"><a href="#1-2、隐藏" class="headerlink" title="1.2、隐藏"></a>1.2、隐藏</h5><p>隐藏具体实现，这个很好理解。比如我设计一个函数给你返回一个 interface，那么你只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。Francesc 举了个 context 的例子。 context 最先由 google 提供，现在已经纳入了标准库，而且在原有 context 的基础上增加了：cancelCtx，timerCtx，valueCtx。语言的表达有时候略显苍白无力，看一下 context 包的代码吧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明上 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;</span><br><span class="line">        Context: parent,</span><br><span class="line">        done:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context     <span class="comment">//注意一下这个地方</span></span><br><span class="line"></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithCancel"</span>, c.Context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span>    //返回 <span class="title">cancelCtx</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span> //返回 <span class="title">timerCtx</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span>    //返回 <span class="title">valueCtx</span></span></span><br></pre></td></tr></table></figure><h5 id="1-3、hook"><a href="#1-3、hook" class="headerlink" title="1.3、hook"></a>1.3、hook</h5><p>通过 interface，我们可以通过类似这种方式实现 dynamic dispatch或者方便测试。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> header <span class="keyword">struct</span> &#123;</span><br><span class="line">    rt  http.RoundTripper</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h header)</span> <span class="title">RoundTrip</span><span class="params">(r *http.Request)</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> h.v &#123;</span><br><span class="line">        r.Header.Set(k,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.rt.RoundTrip(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="二、接口详情"><a href="#二、接口详情" class="headerlink" title="二、接口详情"></a>二、接口详情</h4><p>在类型中有一个重要的类别就是接口类型，表达了固定的一个方法集合。一个接口变量可以存储任意实际值（非接口），只要这个值实现了接口的方法。interface在内存上实际由两个成员组成，如下图，tab指向虚表，data则指向实际引用的数据。虚表描绘了实际的类型信息及该接口所需要的方法集。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line"> String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> b Binary = <span class="number">32</span></span><br><span class="line"> s := Stringer(b)</span><br><span class="line"> fmt.Print(s.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/01/QmkOoj.md.png" alt="接口"></p><p>观察itable的结构，首先是描述type信息的一些元数据，然后是满足Stringger接口的函数指针列表（注意，这里不是实际类型Binary的函数指针集哦）。因此我们如果通过接口进行函数调用，实际的操作其实就是s.tab-&gt;fun<a href="s.data">0</a> 。我们来看golang的实现方式，同C++一样，golang也为每种类型创建了一个方法集，不同的是接口的虚表是在运行时专门生成的.例如，当例子中当首次遇见s := Stringer(b)这样的语句时，golang会生成Stringer接口对应于Binary类型的虚表，并将其缓存。</p><p>首先我们很清楚go是没有严格意义上的继承的，go的接口不存在继承关系，只要实现了接口定义的方法都可以成为接口类型，这给go的虚表初始化带来很大的麻烦，到底有多少类型实现了这个接口，一个类型到底实现了多少接口这让编译器很confused。举个例子，某个类型有m个方法，某接口有n个方法，则很容易知道这种判定的时间复杂度为O(mXn)，不过可以使用预先排序的方式进行优化，实际的时间复杂度为O(m+n)这样看来其实还行那为什么要在运行时生成虚表呢，这不是会拖慢程序的运行速度吗，注意我们这里是某个类型，某个接口，是1对1的关系，如果有n个类型，n个接口呢，编译器难道要把之间所有的关系都理清吗？退一步说就算编译器任劳任怨把这事干了，可是你在写过程中你本来就不想实现那个接口，而你无意中给这个类型实现的方法中包含了某些接口的方法，你根本不需要这个接口(况且go的接口机制会导致很多这种无意义的接口实现)，你欺负编译器就行了，这也太欺负人了吧。如果我们放到运行时呢，我们只要在需要接口的去分析一下类型是否实现了接口的所有方法就行了很简单的一件事。</p><h5 id="2-1、空接口"><a href="#2-1、空接口" class="headerlink" title="2.1、空接口"></a>2.1、空接口</h5><p>接口类型的一个极端重要的例子是空接口：interface{} ,它表示空的方法集合，由于任何值都有零个或者多个方法，所以任何值都可以满足它。 注意，[]T不能直接赋值给[]interface{}</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t := []int&#123;1, 2, 3, 4&#125; wrong</span></span><br><span class="line"><span class="comment">//var s []interface&#123;&#125; = t</span></span><br><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">//right</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(t))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> t &#123;</span><br><span class="line"> s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"> fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，我们可以使用type switch语句查询接口变量的真实数据类型，语法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">  <span class="keyword">return</span> str <span class="comment">//type of str is string</span></span><br><span class="line"><span class="keyword">case</span> Stringer: <span class="comment">//type of str is Stringer</span></span><br><span class="line">  <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用“comma, ok”的习惯用法来安全地测试值是否为一个字符串：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、接口赋值"><a href="#2-2、接口赋值" class="headerlink" title="2.2、接口赋值"></a>2.2、接口赋值</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> LesssAdder <span class="keyword">interface</span> &#123;</span><br><span class="line">  Less(b Integer) <span class="keyword">bool</span></span><br><span class="line">  Add(b Integer)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span> <span class="title">Less</span><span class="params">(b Integer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span></span> &#123;</span><br><span class="line">  *a += b</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> b LesssAdder = &amp;a</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//var c LesssAdder = a</span></span><br><span class="line">  <span class="comment">//Error:Integer does not implement LesssAdder  </span></span><br><span class="line">  <span class="comment">//(Add method has pointer receiver)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go语言可以根据下面的函数:<br><code>func (a Integer) Less(b Integer) bool</code></p><p>自动生成一个新的Less()方法:<br><code>func (a *Integer) Less(b Integer) bool</code></p><p>这样，类型<em>Integer就既存在Less()方法，也存在Add()方法，满足LessAdder接口。 而根据<br>`func (a </em>Integer) Add(b Integer)`</p><p>这个函数无法生成以下成员方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span></span> &#123;</span><br><span class="line">  （&amp;a).Add(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为(&amp;a).Add()改变的只是函数参数a,对外部实际要操作的对象并无影响(值传递)，这不符合用户的预期。所以Go语言不会自动为其生成该函数。因此类型Integer只存在Less()方法，缺少Add()方法，不满足LessAddr接口。（可以这样去理解：指针类型的对象函数是可读可写的，非指针类型的对象函数是只读的）将一个接口赋值给另外一个接口 在Go语言中，只要两个接口拥有相同的方法列表(次序不同不要紧),那么它们就等同的，可以相互赋值。 如果A接口的方法列表时接口B的方法列表的子集，那么接口B可以赋值给接口A，但是反过来是不行的，无法通过编译。</p><h5 id="2-3、接口查询"><a href="#2-3、接口查询" class="headerlink" title="2.3、接口查询"></a>2.3、接口查询</h5><p>接口查询是否成功，要在运行期才能够确定。他不像接口的赋值，编译器只需要通过静态类型检查即可判断赋值是否可行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file1 Writer = ...</span><br><span class="line"><span class="keyword">if</span> file5,ok := file1.(two.IStream);ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句检查file1接口指向的对象实例是否实现了two.IStream接口，如果实现了，则执行特定的代码。<br>在Go语言中，你可以询问它指向的对象是否是某个类型，比如，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file1 Writer = ...</span><br><span class="line"><span class="keyword">if</span> file6,ok := file1.(*File);ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句判断file1接口指向的对象实例是否是*File类型，如果是则执行特定的代码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> I <span class="keyword">interface</span>&#123;&#125; = slice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res, ok := I.([]<span class="keyword">int</span>)；ok &#123;</span><br><span class="line">  fmt.Println(res) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句判断接口I所指向的对象是否是[]int类型，如果是的话输出切片中的元素。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(array <span class="keyword">interface</span>&#123;&#125;, traveser Traveser)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> array == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"nil pointer"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> length <span class="keyword">int</span> <span class="comment">//数组的长度</span></span><br><span class="line">  <span class="keyword">switch</span> array.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">int</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">int</span>))</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">string</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">string</span>))</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">float32</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">float32</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"error type"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"len is zero."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  traveser(array)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用.(type)方法可以利用switch来判断接口存储的类型。</p><hr><h4 id="三、接口与反射"><a href="#三、接口与反射" class="headerlink" title="三、接口与反射"></a>三、接口与反射</h4><hr><h4 id="四、接口源码"><a href="#四、接口源码" class="headerlink" title="四、接口源码"></a>四、接口源码</h4><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/27652856" target="_blank" rel="noopener">understanding-go-interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;什么是interface，简单的说，interface是一组method的组合，下面这篇文章主要给大家深度解析了关于golang中的interface接口，该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口介绍及范例&lt;/li&gt;
&lt;li&gt;接口详情&lt;/li&gt;
&lt;li&gt;接口与反射&lt;/li&gt;
&lt;li&gt;接口源码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Linux线程通信之eventfd</title>
    <link href="https://ustack.io/2019-12-02-Linux%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8Beventfd.html"/>
    <id>https://ustack.io/2019-12-02-Linux 线程通信之eventfd.html</id>
    <published>2019-12-02T12:40:08.000Z</published>
    <updated>2019-12-01T13:41:22.140Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及到eventfd相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>先介绍eventfd：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eventfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> initval, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>使用这个函数来创建一个事件对象，linux线程间通信为了提高效率，大多使用异步通信，采用事件监听和回调函数的方式来实现高效的任务处理方式（虽然会将逻辑变得复杂）。<br>linux内核会为这个事件对象维护一个64位的计数器(uint64_t).并在初始化时用传进去的initval来初始化这个计数器，然后返回一个文件描述符来代表这个事件对象。</p><p>第二个参数是描述这个事件对象的属性，可以设置为EFD_NONBLOCK , EFD_CLOEXEC；前面的是设置对象为非阻塞状态，如果没有设置为非阻塞状态，read系统调用来读这个计数器，且计数器的值为0时，就会一直阻塞在read系统调用上，反之如果设置了该标志位，就会返回EAGAIN错误。后面的EFD_CLOEXEC功能是在程序调用exec()函数族加载其他程序时自动关闭当前已有的文件描述符（具体为什么暂不解释）。</p><p>通过此函数得到的对象既然是一个计数器，我们就可以对它进行读和写：<br>使用write将缓冲区写入的8字节整形值加到内核计数器上。<br>使用read将内核计数的8字节值读取到缓冲区中，并把计数器重设为0，如果buffer的长度小于8字节则read会失败，错误码设为EINVAl。</p><p>再介绍epoll，忍不住的可以直接向下翻<br>epoll是对select,poll这种IO多路转接方式的改进<br>接口:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> intsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>工作模式：</p><ul><li>水平触发：缺省的工作方式，并且同时支持block和no-blocksocket，在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表</li><li>边缘触发：高速工作方式，只支持no-blocksocket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了</li></ul><blockquote><p>用途：使用epoll_wait对某个文件描述符进行事件监听，监听到事件后会返回相关的结构体，得到其中有事件到来的fd，使用对应的回调函数(手动实现fd到回调函数的映射)来处理该fd上的事件：读数据或者写数据之类的。</p></blockquote><p>下面进入使用场景：</p><p>原始做法：(会有bug，下面分析)<br>初始化：先生成一个eventfd，初始化计数器为0，此eventfd可以通过一些方法在下面两个线程间共享<br>线程A：处理一些来自外部的请求，每处理完一个请求后会向eventfd的计数器中写入处理的结果，是一个整型值，然后接着处理下一个请求。<br>线程B：对eventfd进行Epoll监听，回调函数的功能是对eventfd的计数器读数据出来并将结果进行分发。</p><p>用例1：外部单个客户端每隔1秒向线程A发送一个请求。</p><p>用例1结果：线程A正确处理请求，并将结果写入eventfd中，线程B及时从eventfd中读取出请求处理结果，并正确分发给其他线程。</p><p>用例2：外部单个客户端连续向线程A发送多个请求。</p><p>用例2结果：线程A正确处理请求，并正确地将结果写入eventfd中，但在一定概率的情况下，线程B从eventfd中读到的结果不是线程A一次写入的结果，而是多次写入的结果。因此不能正确的分发请求。线程B中epoll捕捉到的事件次数小于线程A写入产生的事件数量。</p><p>用例3：外部多个客户端同时向线程A发送一个请求</p><p>用例3结果：线程A正确处理请求，并正确的将结果写入eventfd中，在很大的概率情况下，线程B中eventfd中读到的结果不是线程A一次写入的结果，而是多次写入的结果。因此，也不能正确的分发请求。线程B中epoll捕捉到的事件次数小于线程A写入产生的事件数量。</p><p>BUG分析：在这个场景中，线程A和线程B分别相当于生产者和消费者，只从原始生产者消费者模型上看并没有问题，满足数据为空时读不到数据，数据满时写不进数据(read,write的功能)，但是在当前场景中，加了一个特别的要求：每次写入的数据应该可以被独立识别而不是累加，每次写入的事件也应该被epoll独立的捕捉到。因此，需要对事件和数据各自进行序列化上的拆分。</p><p>改进做法：<br>初始化：先生成一个eventfd，初始化计数器为1，再生成一个空队列Q和互斥锁，此eventfd，队列Q和互斥锁可以通过一些方法在下面两个线程间共享，</p><p>线程A：处理一些来自外部的请求，每处理完一个请求后会从eventfd的计数器read数据，加1之后再write，将处理结果写入到队列末尾，然后接着处理下一个请求。</p><p>线程B：对eventfd进行Epoll监听，回调函数的功能是对eventfd的计数器read数据出来然后判断，如果大于1就自减1然后从队列头部取出数据，并将结果进行分发<br>，最后再写入新的计数器数据。如果等于1那么就直接返回，代表没有新的数据到来。</p><p>用例1,2,3在此环境下均可正常跑通。</p><p>回过头来分析原始做法的fatal error在哪：</p><p>作为生产者的线程A没有向线程B解释自己向eventfd中写入了多少个数据，产生了多少次事件。</p><p>作为消费者的线程B一次read就把eventfd中所有的数据当做一个数据读了出来，却没有相关依据来对读出来的数据做拆分。</p><p>作为通信工具的eventfd只能将数据进行累加，起到计数器的作用而不能存储实际数据。</p><p>作为消息监听的epoll在水平触发模式下只能通知是否有事件而不能通知有多少事件，在边缘触发下不能保留每次事件的产生都能及时被消费者捕获到。</p><p>因此，改进做法是将事件的多少通过计数器来表达，将实际传输的数据通过FIFO队列来传达。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及到eventfd相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="linux" scheme="https://ustack.io/tags/linux/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes调度系统初探</title>
    <link href="https://ustack.io/2019-11-26-Kubernetes%20%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2.html"/>
    <id>https://ustack.io/2019-11-26-Kubernetes 调度系统初探.html</id>
    <published>2019-11-26T04:40:08.000Z</published>
    <updated>2019-11-26T02:10:41.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg" alt></p><div class="note default"><p>Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。</p><p>本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：</p><ul><li>Kubernetes version: <code>v1.10</code></li><li>System: <code>CentOS Linux 7</code></li><li>Kernel: <code>Linux 3.10.0</code></li></ul></div><p>Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。</p><a id="more"></a><hr><blockquote><p>在后续安装部署中，将不使用kube-apiserver的HTTP非安全端口，所有组件都启用TLS双向认证通信。因此TLS证书配置是在安装配置Kubernetes系统中最容易出错和难于排查问题的一步，所以请务必耐心仔细。</p></blockquote><p>在开始前，为了模拟集群节点，我们假定需要在以下三台Linux主机上部署Kubernetes:</p><ul><li><code>10.138.148.161</code>：作为<code>master</code>节点</li><li><code>10.138.196.180</code>：作为<code>Node</code>节点</li><li><code>10.138.212.68</code>：作为<code>Node</code>节点</li></ul><div class="note danger"><p>同一台主机上可以同时部署master和Node节点相关组件，即同时作为控制节点和工作节点，不过这么做可能导致master节点负载过高而失去响应进而导致整个集群出现无法预知的问题。</p></div><hr><h3 id="安装CFSSL证书生成工具"><a href="#安装CFSSL证书生成工具" class="headerlink" title="安装CFSSL证书生成工具"></a>安装<code>CFSSL</code>证书生成工具</h3><div class="note info"><p>我们将使用<code>Cloudflare</code>的PKI工具集<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">cloudflare/cfssl</a>来生成集群所需要的各种<code>TLS</code>证书。</p></div><p>执行以下命令直接下载二进制文件进行安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O cfssl </span><br><span class="line">chmod +x cfssl </span><br><span class="line">sudo mv cfssl /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O cfssljson </span><br><span class="line">chmod +x cfssljson </span><br><span class="line">sudo mv cfssljson /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O cfssl-certinfo </span><br><span class="line">chmod +x cfssl-certinfo </span><br><span class="line">sudo mv cfssl-certinfo /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h3 id="创建CA根证书（Certificate-Authority）"><a href="#创建CA根证书（Certificate-Authority）" class="headerlink" title="创建CA根证书（Certificate Authority）"></a>创建CA根证书（Certificate Authority）</h3><p>CA（Certificate Authority）是自签名的根证书，用来签名后续创建的其它 TLS 证书；<br>确认<code>CFSSL</code>工具安装成功之后，我们先通过<code>CFSSL</code>工具来创建模版配置json文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfssl <span class="built_in">print</span>-defaults config &gt; config.json</span><br><span class="line">cfssl <span class="built_in">print</span>-defaults csr &gt; csr.json</span><br></pre></td></tr></table></figure><h4 id="创建CA配置文件"><a href="#创建CA配置文件" class="headerlink" title="创建CA配置文件"></a>创建CA配置文件</h4><p>这将生成两个模版json文件，后续<code>CFSSL</code>将读取json文件内容并生成对应的<code>pem</code>文件。我们先复制<code>config.json</code>为<code>ca-config.json</code>文件并做如下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"signing"</span>: &#123;</span><br><span class="line">        <span class="attr">"default"</span>: &#123;</span><br><span class="line">            <span class="attr">"expiry"</span>: <span class="string">"99999h"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">            <span class="attr">"kubernetes"</span>: &#123;</span><br><span class="line">                <span class="attr">"expiry"</span>: <span class="string">"99999h"</span>,</span><br><span class="line">                <span class="attr">"usages"</span>: [</span><br><span class="line">                    <span class="string">"signing"</span>,</span><br><span class="line">                    <span class="string">"key encipherment"</span>,</span><br><span class="line">                    <span class="string">"server auth"</span>,</span><br><span class="line">                    <span class="string">"client auth"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>profiles</code>：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个特定的profile。</p><p><code>signing</code>：表示该证书可用于签名(签发)其它证书，生成的 ca.pem 证书中 CA=TRUE。</p><p><code>server auth</code>：表示`client可以用该 CA（生成的ca.pem） 对server提供的证书进行验证。</p><p><code>client auth</code>：表示server可以用该CA(生成的ca.pem）对client提供的证书进行验证。</p></div><h4 id="创建CA证书签名请求"><a href="#创建CA证书签名请求" class="headerlink" title="创建CA证书签名请求"></a>创建CA证书签名请求</h4><p>我们复制<code>csr.json</code>为<code>ca-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code>(<code>Common Name</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户名；</p><p><code>O</code>(<code>Organtzation</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户所属的用户组；</p></div><h4 id="生成CA证书和私钥"><a href="#生成CA证书和私钥" class="headerlink" title="生成CA证书和私钥"></a>生成CA证书和私钥</h4><p>执行以下命令来生成CA证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls ca*</span><br><span class="line">ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>这样，我们就生成了CA证书和私钥了，因为我们需要双向<code>TLS</code>认证，所以需要拷贝<code>ca-key.pem</code>和<code>ca.pem</code>到所有要部署的机器的<code>/etc/kubernetes/ssl</code>目录下备用。</p><h3 id="创建kubernetes组件认证授权证书"><a href="#创建kubernetes组件认证授权证书" class="headerlink" title="创建kubernetes组件认证授权证书"></a>创建kubernetes组件认证授权证书</h3><p>因为我们准备部署的kubernetes组件是使用<code>TLS</code>双向认证的，包括<code>kube-apiserver</code>不打算使用HTTP端口，因此，我们需要生成以下的证书以供后续组件部署的时候备用：</p><div class="note info"><ul><li><code>etcd</code>证书：etcd集群之间通信加密使用的<code>TLS</code>证书。</li><li><code>kube-apiserver</code>证书：配置<code>kube-apiserver</code>组件的证书。</li><li><code>kube-controller-manager</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kube-scheduler</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kubelet</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li><li><code>kube-proxy</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li></ul></div><p>下面我们将逐个创建对应的<code>TLS</code>证书，并做相应的简短说明：</p><h4 id="创建etcd证书："><a href="#创建etcd证书：" class="headerlink" title="创建etcd证书："></a>创建<code>etcd</code>证书：</h4><p>首选我们创建<code>etcd</code>证书签名请求(CSR)，拷贝<code>csr.json</code>为<code>etcd-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"etcd"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">        <span class="string">"master"</span>,</span><br><span class="line">        <span class="string">"node1"</span>,</span><br><span class="line">        <span class="string">"node2"</span></span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger"><p>此处需要指定<code>host</code>字段的值，该值为所有需要部署etcd节点的<code>ip 域名 或者 hostname</code>，etcd需要使用<code>Subject Alternative Name（SAN）</code>来校验集群以及防止滥用。如果你不清楚应该使用哪个ip，默认情况下使用<code>ip a</code>查看<code>eth0</code>即可。此处指定的<code>ip</code>与后续指定的<code>etcd的systemd</code>配置<code>initial-cluster</code>相关。</p><p>相关阅读: <a href="https://github.com/coreos/etcd/issues/2056" target="_blank" rel="noopener">Option to accept TLS client certificates even if they lack correct Subject Alternative Names</a></p></div><p>生成<code>etcd</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line">ls etcd*</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem etcd.pem</span><br></pre></td></tr></table></figure><p>将生成的<code>etch-key.pem</code>和<code>etcd.pem</code>拷贝到所有需要部署<code>etcd</code>集群的服务器<code>/etc/etcd/ssl</code>目录下备用。</p><h4 id="创建kube-apiserver证书"><a href="#创建kube-apiserver证书" class="headerlink" title="创建kube-apiserver证书"></a>创建<code>kube-apiserver</code>证书</h4><p>创建<code>kube-apiserver</code>证书签名请求配置文件，拷贝<code>csr.json</code>为<code>kubernetes-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">      <span class="string">"10.254.0.1"</span>,</span><br><span class="line">      <span class="string">"kubernetes"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster.local"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"key"</span>: &#123;</span><br><span class="line">        <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>此处指定了<code>host</code>字段来表示授权使用该证书的<code>ip或域名</code>列表，因此上述配置文件指定了要部署的kubernetes三台服务器ip（实际上只需要指定打算部署master节点的ip即可）以及<code>kube-apiserver</code>注册的名为<code>kubernetes</code>服务的服务ip（一般默认为后续配置<code>kube-apiserve</code>组件的时候指定的<code>—service-cluster-ip-range</code>网段的第一个ip。）如果你不清楚怎么操作，可以留空<code>host</code>字段。</p><p>如果你指定了<code>host</code>字段，这里如果有 <code>VIP</code> 的，也是需要填写的。</p></div><p>生成<code>kube-apiserver</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare apiserver</span><br><span class="line">ls apiserver*</span><br><span class="line">apiserver.csr  apiserver-key.pem  apiserver.pem</span><br></pre></td></tr></table></figure><p>我们将该证书拷贝到需要部署到<code>master</code>节点上的<code>/etc/kubernetes/ssl</code>上备用。</p><div class="note info"><p>因为我们master节点的组件之间的通信使用<code>非HTTP</code>的安全端口，所以同样也需要<code>TLS</code>认证授权，因此我们也需要配置<code>kube-controller-manager</code>和<code>kube-scheduler</code>的证书来供这两个组件访问<code>kube-apiserver</code>.如果你的集群master节点组件使用HTTP非安全端口通信，那么可以不需要配置这两个证书。</p></div><h4 id="创建kube-controller-manager证书"><a href="#创建kube-controller-manager证书" class="headerlink" title="创建kube-controller-manager证书"></a>创建<code>kube-controller-manager</code>证书</h4><p>复制<code>car.json</code>为<code>kube-controller-manager-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-controller-manager"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的配置中，<code>kube-apiserver</code>将提取<code>CN</code>作为客户端组件(kube-controller-manager)的用户名(system:kube-controller-manager)，<code>kube-apiserver</code>预定义的RBAC使用ClusterRoleBinding <code>system:kube-controller-manager</code>将<code>用户system:kube-controller-manager</code>与<code>ClusterRole system:kube-controller-manager</code>绑定。</p><p>生成<code>kube-controller-manager</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare controller-manager</span><br><span class="line">ls controller-manager*</span><br><span class="line">controller-manager.csr  controller-manager-key.pem  controller-manager.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-controller-manager</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><h4 id="创建kube-scheduler-证书"><a href="#创建kube-scheduler-证书" class="headerlink" title="创建kube-scheduler`证书"></a>创建kube-scheduler`证书</h4><p>与<code>kube-controller-manager</code>一样，<code>kube-scheduler</code>同样也需要<code>TLS</code>证书来访问<code>kube-apiserver</code>。此处不再赘述。直接上<code>kube-scheduler-csr.json</code>文件内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-scheduler"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code></code>kube-scheduler <code>将提取</code>CN作为客户端的用户名<code>,这里是</code>system:kube-scheduler<code>。 kube-apiserver 预定义的 RBAC 使用的 ClusterRoleBindings</code>system:kube-scheduler <code>将</code>用户system:kube-scheduler <code>与</code>ClusterRole system:kube-scheduler `绑定。</p><p>生成<code>kube-scheduler</code>证书以及私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare scheduler</span><br><span class="line">ls scheduler*</span><br><span class="line">scheduler.csr  scheduler-key.pem  scheduler.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-scheduler</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><p>至此，<code>master</code>节点上的证书生成就全部完成了，接下来是生成<code>worker</code>节点的证书，需要注意的是：生成<code>worker</code>证书是可选的，如果你使用<code>TLS Bootstarpping</code>那么你可以跳过以下步骤<code>worker</code>证书生成工作。直接转到部署的实际操作环节。关于<code>TLS</code>证书和<code>TLS Bootstarpping</code>认证方式的区别，后续考虑单独写一遍文章展开来讲。</p><hr><h4 id="创建kubelet证书"><a href="#创建kubelet证书" class="headerlink" title="创建kubelet证书"></a>创建<code>kubelet</code>证书</h4><p>拷贝<code>car.json</code>为<code>kubelet-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:node:node"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"system:nodes"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>O</code>为用户组，kubernetes RBAC定义了ClusterRoleBinding将Group system:nodes和CLusterRole system:node关联起来。</p><p>注意:在<code>kubernetes v1.8+</code>以上版本，将不会自动创建<code>binding</code>,因此我们后续需要手动创建绑定关系。</p></div><p>生成<code>kubelet</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubelet-csr.json | cfssljson -bare kubelet</span><br><span class="line">ls kubelet*</span><br><span class="line">kubelet.csr  kubelet-csr.json  kubelet-key.pem  kubelet.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和秘钥拷贝到所有需要部署的worker节点上的<code>/etc/kubernetes/ssl</code>下备用。</p><h4 id="创建kube-proxy证书"><a href="#创建kube-proxy证书" class="headerlink" title="创建kube-proxy证书"></a>创建<code>kube-proxy</code>证书</h4><p>拷贝<code>car.json</code>为<code>kube-proxy-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-proxy"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code> 指定该证书的 User为 system:kube-proxy。Kubernetes RBAC定义了ClusterRoleBinding将<code>system:kube-proxy用户</code>与<code>system:node-proxier 角色</code>绑定。system:node-proxier具有kube-proxy组件访问ApiServer的相关权限。</p></div><p>生成<code>kube-proxy</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">ls kube-proxy*</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和私钥拷贝到所有需要部署<code>worker</code>节点的<code>/etc/kubernetes/ssl</code>下备用。</p><p>在完成证书分发之后，这样我们的证书相关的生成工作就完成了。接下来开始配置各个组件。</p><p>参考资料：</p><ul><li><a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">Using RBAC Authorization</a></li><li><a href="https://wiki.shileizcc.com/display/KUB/Kubernetes+HA+Cluster+Build" target="_blank" rel="noopener">Kubernetes HA Cluster Build</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-centos.html" target="_blank" rel="noopener">在CentOS上部署kubernetes集群</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。&lt;/p&gt;
&lt;p&gt;本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes version: &lt;code&gt;v1.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System: &lt;code&gt;CentOS Linux 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kernel: &lt;code&gt;Linux 3.10.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes GO" scheme="https://ustack.io/categories/Kubernetes-GO/"/>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之cond</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bcond.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之cond.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:53:55.777Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Cond在client-go等库中广泛使用，该文对此做知识铺垫。<br>Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Cond在client-go等库中广泛使用，该文对此做知识铺垫。&lt;br&gt;Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之信号处理</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之信号处理.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:57:02.570Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之heap</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bheap.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之heap.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:36:51.986Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.</p><p>[</p></div><p>heap是Golang内置的标准库封装，该文章主要介绍，以下内容:</p><ul><li>heap介绍及范例</li><li>heap解析</li></ul><a id="more"></a><hr><h4 id="一、heap介绍及范例"><a href="#一、heap介绍及范例" class="headerlink" title="一、heap介绍及范例"></a>一、heap介绍及范例</h4><blockquote><p>堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p></blockquote><p>堆的常用方法：</p><ul><li><p>构建优先队列</p></li><li><p>支持堆排序</p></li><li><p>快速找出一个集合中的最小值（或者最大值）</p></li></ul><h5 id="1-1-堆属性"><a href="#1-1-堆属性" class="headerlink" title="1.1 堆属性"></a>1.1 堆属性</h5><p>堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。</p><p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHIrTS.png" alt="heap1"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。10比7和2都大。7比5和1都大。</p><p>根据这一属性，那么最大堆总是将其中的最大值存放在树的根节点。而对于最小堆，根节点中的元素总是树中的最小值。堆属性非常的有用，因为堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素。</p><blockquote><p>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p></blockquote><h5 id="1-2-堆和普通树的区别"><a href="#1-2-堆和普通树的区别" class="headerlink" title="1.2 堆和普通树的区别"></a>1.2 堆和普通树的区别</h5><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p><ul><li><p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p></li><li><p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。</p></li><li><p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p></li><li><p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p></li></ul><p><strong><em>来自数组的树</em></strong></p><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间山都是很高效的。我们准备将上面的例子中的树这样存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 7, 2, 5, 1 ]</span><br></pre></td></tr></table></figure><p>就这多！我们除了一个简单的数组以外，不需要任何额外的空间。</p><p>如果我们不允许使用指针，那么我们怎么知道哪一个节点是父节点，哪一个节点是它的子节点呢？问得好！节点在数组中的位置index 和它的父节点已经子节点的索引之间有一个映射关系。</p><p>如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent(i) = floor((i - 1)/2)</span><br><span class="line">left(i)   = 2i + 1</span><br><span class="line">right(i)  = 2i + 2</span><br></pre></td></tr></table></figure><p>注意 right(i) 就是简单的 left(i) + 1。左右节点总是处于相邻的位置。</p><p>我们将写公式放到前面的例子中验证一下。</p><table><thead><tr><th>Node</th><th>Array index (i)</th><th>Parent index</th><th>Left child</th><th>Right child</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>-1</td><td>1</td><td>2</td></tr><tr><td>7</td><td>1</td><td>0</td><td>3</td><td>4</td></tr><tr><td>2</td><td>2</td><td>0</td><td>5</td><td>6</td></tr><tr><td>5</td><td>3</td><td>1</td><td>7</td><td>8</td></tr><tr><td>1</td><td>4</td><td>1</td><td>9</td><td>10</td></tr></tbody></table><blockquote><p>根节点(10)没有父节点，因为 -1 不是一个有效的数组索引。同样，节点 (2)，(5)和(1) 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。</p></blockquote><p>在最大堆中，父节点的值总是要大于（或者等于）其子节点的值。这意味下面的公式对数组中任意一个索引i都成立：<code>array[parent(i)] &gt;= array[i]</code></p><p>可以用上面的例子来验证一下这个堆属性。</p><p>如你所见，这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要O(1)的时间。</p><p>理解数组索引和节点位置之间的关系非常重要。这里有一个更大的堆，它有15个节点被分成了4层:</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoCfH.png" alt="树"></p><p>图片中的数字不是节点的值，而是存储这个节点的数组索引！这里是数组索引和树的层级之间的关系：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoUNF.png" alt="数组"></p><p>由上图可以看到，数组中父节点总是在子节点的前面。注意这个方案与一些限制。你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoh3d.png" alt="一般树"></p><p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHovgs.png" alt="heapshap"></p><blockquote><p>注意：你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</p></blockquote><p>假设我们有这样一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 14, 25, 33, 81, 82, 99 ]</span><br></pre></td></tr></table></figure><p>这是一个有效的堆吗？答案是 yes ！一个从低到高有序排列的数组是以有效的最小堆，我们可以将这个堆画出来：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTMVK.png" alt="sortedArray"></p><p>堆属性适用于每一个节点，因为父节点总是比它的字节点小。（你也可以验证一下：一个从高到低有序排列的数组是一个有效的最大堆）</p><blockquote><p>注意：并不是每一个最小堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</p></blockquote><h5 id="1-3-堆的用途"><a href="#1-3-堆的用途" class="headerlink" title="1.3 堆的用途"></a>1.3 堆的用途</h5><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p><ul><li>shiftUp(): 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。</li><li>shiftDown(): 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。</li></ul><p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 O(log n)。</p><p>基于这两个原始操作还有一些其他的操作：</p><ul><li>insert(value): 在堆的尾部添加一个新的元素，然后使用 shiftUp 来修复对。</li><li>remove(): 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 shiftDown 方法来修复堆。</li><li>removeAtIndex(index): 和 remove() 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。当它与子节点比较位置不时无序时使用 shiftDown()，如果与父节点比较发现无序则使用 shiftUp()。</li><li><p>replace(index, value)：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 shiftUp() 来修复堆属性。<br>上面所有的操作的时间复杂度都是 O(log n)，因为 shiftUp 和 shiftDown 都很费时。还有少数一些操作需要更多的时间：</p></li><li><p>search(value):堆不是为快速搜索而建立的，但是 replace() 和 removeAtIndex() 操作需要找到节点在数组中的index，所以你需要先找到这个index。时间复杂度：O(n)。</p></li><li>buildHeap(array):通过反复调用 insert() 方法将一个（无序）数组转换成一个堆。如果你足够聪明，你可以在 O(n) 时间内完成。</li><li>堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度：O(n lg n)。</li></ul><p>堆还有一个 peek() 方法，不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。时间复杂度 O(1) 。</p><blockquote><p>注意：到目前为止，堆的常用操作还是使用 insert() 插入一个新的元素，和通过 remove()移除最大或者最小值。两者的时间复杂度都是O(log n)。其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p></blockquote><p><strong><em>插入</em></strong></p><p>我们通过一个插入例子来看看插入操作的细节。我们将数字16插入到这个堆中：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTgrq.png" alt="heap1"></p><p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。<br>第一股是将新的元素插入到数组的尾部。数组变成：<br><code>[ 10, 7, 2, 5, 1, 16 ]</code><br>相应的树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTHMR.png" alt="Insert1"></p><p>16 被添加最后一行的第一个空位。<br>不行的是，现在堆属性不满足，因为2在16的上面，我们需要将大的数字在上面（这是一个最大堆）<br>为了恢复堆属性，我们需要交换16和2。</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7SRH.png" alt="Insert2"></p><p>现在还没有完成，因为 10 也比 16 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 shift-up，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。<br>最后我们得到的堆：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH73wV.png" alt="Insert3"></p><p>现在每一个父节点都比它的子节点大。</p><p><strong><em>删除根节点</em></strong></p><p>我们将这个树中的 (10) 删除：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7Tk8.png" alt="Heap1"></p><p>现在顶部有一个空的节点，怎么处理？</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHsun.png" alt="Remove1"></p><p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHqUK.png" alt="Remove2"></p><p>现在来看怎么 shift-down (1)。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 7 和 2。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 7 和 1，现在树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbiUf.png" alt="Remove3"></p><p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbmKs.png" alt="Remove4"></p><p><strong><em>删除任一节点</em></strong></p><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。</p><p>但是，删除任意节点也很有用。这是 remove() 的通用版本，它可能会使用到 shiftDown 和 shiftUp。</p><p>我们还是用前面的例子，删除 (7):</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbG24.png" alt="Heap1"></p><p>对应的数组是:<code>[ 10, 7, 2, 5, 1 ]</code></p><p>你知道，移除一个元素会破坏最大堆或者最小堆属性。我们需要将删除的元素和最后一个元素交换：<br><code>[ 10, 1, 2, 5, 7 ]</code></p><p>最后一个元素就是我们需要返回的元素；然后调用 removeLast() 来将它删除。 (1) 比它的子节点小，所以需要 shiftDown() 来修复。</p><p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 (5) 会发生什么：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbyxH.png" alt="Remove5"></p><p>现在 (5) 和 (8) 交换了。因为 (8) 比它的父节点大，我们需要 shiftUp()。</p><hr><h4 id="二、heap解析"><a href="#二、heap解析" class="headerlink" title="二、heap解析"></a>二、heap解析</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>heap包对任意实现了heap接口的类型提供堆操作。（小根）堆是具有“每个节点都是以其为根的子树中最小值”属性的树。树的最小元素在根部，为index 0.<br>heap是常用的实现优先队列的方法。要创建一个优先队列，实现一个具有使用（负的）优先级作为比较的依据的Less方法的Heap接口，如此一来可用Push添加项目而用Pop取出队列最高优先级的项目。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：</p><ul><li>Len() int</li><li>Less(i, j int) bool  </li><li>Swap(i, j int)</li></ul><p>再加上堆接口定义的两个方法：</p><ul><li>Push(x interface{})</li><li>Pop() interface{}。</li></ul><p>故只要实现了这五个方法，变定义了一个堆。</p><p>任何实现了本接口的类型都可以用于构建最小堆。最小堆可以通过heap.Init建立，数据是递增顺序或者空的话也是最小堆。最小堆的约束条件是：</p><p><code>!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()</code></p><p>注意接口的Push和Pop方法是供heap包调用的，请使用heap.Push和heap.Pop来向一个堆添加或者删除元素。</p><ul><li>func Fix(h Interface, i int)  //  在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Init(h Interface)  //初始化一个堆。一个堆在使用任何堆操作之前应先初始化。Init函数对于堆的约束性是幂等的（多次执行无意义），并可能在任何时候堆的约束性被破坏时被调用。本函数复杂度为O(n)，其中n等于h.Len()。</li><li>func Pop(h Interface) interface{}  //删除并返回堆h中的最小元素（不影响约束性）。复杂度O(log(n))，其中n等于h.Len()。该函数等价于Remove(h, 0)。</li><li>func Push(h Interface, x interface{})  //向堆h中插入元素x，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Remove(h Interface, i int) interface{}  //删除堆中的第i个元素，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li></ul><p>利用heap创建一个优先级队列:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line">  <span class="comment">// not just its contents.</span></span><br><span class="line">  *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *h</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  x := old[n<span class="number">-1</span>]</span><br><span class="line">  *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  heap.Init(h)</span><br><span class="line">  heap.Push(h, <span class="number">3</span>)</span><br><span class="line">  heap.Fix(h, <span class="number">3</span>)</span><br><span class="line">  fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用heap创建一个优先级队列</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates a priority queue built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">  priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">  <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">  index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">  <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">  pq[i].index = i</span><br><span class="line">  pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  n := <span class="built_in">len</span>(*pq)</span><br><span class="line">  item := x.(*Item)</span><br><span class="line">  item.index = n</span><br><span class="line">  *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *pq</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  item := old[n<span class="number">-1</span>]</span><br><span class="line">  item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">  *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  item.value = value</span><br><span class="line">  item.priority = priority</span><br><span class="line">  heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Some items and their priorities.</span></span><br><span class="line">  items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"banana"</span>: <span class="number">3</span>, <span class="string">"apple"</span>: <span class="number">2</span>, <span class="string">"pear"</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">  <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">  pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">    pq[i] = &amp;Item&#123;</span><br><span class="line">      value:    value,</span><br><span class="line">      priority: priority,</span><br><span class="line">      index:    i,</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">  item := &amp;Item&#123;</span><br><span class="line">    value:    <span class="string">"orange"</span>,</span><br><span class="line">    priority: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  heap.Push(&amp;pq, item)</span><br><span class="line">  pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">  <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">    fmt.Printf(<span class="string">"%.2d:%s \n"</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类,实现相关接口后,交由heap.Init()去构建堆.</p><ul><li>从堆中Pop()后,数据就被从heap中移除了.</li><li>升降序由Less()来决定.</li><li>自定义类也可以直接用Sort来排序,因为实现了相关接口.</li></ul><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>heap在kubernetes scheduler相关内容涉及，将会在后续推出。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;heap是Golang内置的标准库封装，该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heap介绍及范例&lt;/li&gt;
&lt;li&gt;heap解析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>算法之Manacher</title>
    <link href="https://ustack.io/2019-11-22-%E7%AE%97%E6%B3%95%E4%B9%8BManacher.html"/>
    <id>https://ustack.io/2019-11-22-算法之Manacher.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-12-09T13:13:29.709Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Cond在client-go等库中广泛使用，该文对此做知识铺垫。<br>Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="noopener">Manacher算法</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Cond在client-go等库中广泛使用，该文对此做知识铺垫。&lt;br&gt;Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ustack.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>容器那些事</title>
    <link href="https://ustack.io/2019-11-21-container%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-21-container相关概念梳理.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2020-04-20T13:39:25.520Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续<br>对于kubelet相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><h4 id="container与docker"><a href="#container与docker" class="headerlink" title="container与docker"></a>container与docker</h4><p>container的概念早于docker，其源于LXC技术，当然在此需要感谢docker社区对于容器技术的贡献，因为docker的出现，container的概念深入人心，容器<br>的特性类似sandbox，进程受到资源的限制，并且彼此间隔离，当然容器区别与虚拟机的技术，主要区别在于内核的是否共享，上述的论断可能不太精确，因此后期如<br>gvisor技术，其通过隔离层实现系统调用。通俗来说容器技术主要指资源限制的cgroup、用于隔离的namespace以及共享内核。</p><p>11月13日，Mirantis收购Docker的消息引爆开源届。</p><h4 id="OCI标准"><a href="#OCI标准" class="headerlink" title="OCI标准"></a>OCI标准</h4><p>Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。<br>所谓container runtime，主要负责的是容器的生命周期的管理。oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义。<br>其中<code>runc</code>，是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。</p><p>为了兼容oci标准，docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。</p><h4 id="container-engine"><a href="#container-engine" class="headerlink" title="container engine"></a>container engine</h4><p>容器引擎，或者说容器平台，不仅包含对于容器的生命周期的管理，还包括了对于容器生态的管理，比如对于镜像等。现在的docker、rkt以及阿里推出的pouch均可属于此范畴。<br>docker，随着docker的发展，docker就不再局限于容器的管理，还囊括了存储(volume)、网络(net)等的管理，因此后来的docker是一个容器的管理平台。而runtime逐渐插件化，如下图的runc与kata runtime。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTc92D.jpg" alt="docker runtime plugin"></p><hr><h3 id="Kubernetes相关"><a href="#Kubernetes相关" class="headerlink" title="Kubernetes相关"></a>Kubernetes相关</h3><p>kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。</p><p>在k8s 1.5版本之后，kubernetes推出了自己的运行时接口CRI(container runtime interface)。cri接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。</p><p>与oci不同，cri与kubernetes的概念更加贴合，并紧密绑定。cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为PodSandbox。在cri开始之初，主要是支持docker和rkt两种。其中kubelet是通过cri接口，调用dockershim，并进一步调用docker api实现的。</p><p>如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。</p><p>在之后的社区发展中，kubelet支持docker及remote两种类型，其中docker即内置的dockershim以满足CRI接口，remote方式同样需要满足CRI接口规范。</p><blockquote><p>下图为各runtime与kubelet的通信</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/22/MTc1qs.jpg" alt="kubelet CRI"></p><p>其中的CRI-O插件实现kubelet CRI接口，并能够兼容OCI标准，作为一种可替换docker的轻量级运行时方案，其允许kubelet允许任一符合OCI标准的runtime来运行Pod。<br>下图为CRI-O与OCI接口通信图示。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTgdtP.jpg" alt="CRI-O通信"></p><p>CRI-O插件主要有以下功能：</p><ul><li>镜像服务</li><li>runtime服务</li><li>CNI</li><li>OCI 生成器</li></ul><p>最后，kubelet与CRI-O的交互流程如下：</p><ol><li>kubelet通过list接口获悉启动POD，其中POD是kubernetes的一个概念，由一个或多个共享IPC，NET和PID名称空间并位于同一cgroup中的容器组成。</li><li>kubelet将请求下发到kubernetes CRI-O服务，即kubelet启动时的remote配置（容器运行时接口），以启动新的POD。</li><li>CRI-O使用containers/image库从镜像仓库拉取镜像。</li><li>下载后的镜像解压存储到为容器创建rootfs，即存储在COW文件系统中。</li><li>在rootfs创建后，CRI-O会生成OCI运行时规范json文件，该文件描述了如何使用OCI Generate工具运行容器。</li><li>CRI-O使用该配置启动OCI兼容的运行时，以运行容器进程。默认的OCI运行时是runc。</li><li>每个容器都由单独的通用程序进行监控。 conmon进程保留了容器进程的PID1。它处理容器的日志记录并记录容器过程的退出代码。</li><li>通过CNI设置Pod的网络，因此任何CNI插件均可与CRI-O一起使用。</li></ol><p>下图为CRI的功能图。<br><img src="https://s2.ax1x.com/2019/11/22/MTWv90.md.png" alt="CRI-O功能"></p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将推出kubernetes runtimeclass文章</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://medium.com/kata-containers/why-kata-containers-doesnt-replace-kubernetes-75e484679727" target="_blank" rel="noopener">why-kata-containers-doesnt-replace-kubernetes</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">CRI-O</a></li><li><a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noopener">runtime-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续&lt;br&gt;对于kubelet相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="linux" scheme="https://ustack.io/tags/linux/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes展望与思考</title>
    <link href="https://ustack.io/2019-11-21-Kubernetes%201.17%20%E5%B1%95%E6%9C%9B%E4%B8%8E%E6%80%9D%E8%80%83.html"/>
    <id>https://ustack.io/2019-11-21-Kubernetes 1.17 展望与思考.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T06:50:31.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt></p><div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a>当前changlog，</p></div><p>距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。</p><a id="more"></a><hr><h3 id="一、1-16版本回顾"><a href="#一、1-16版本回顾" class="headerlink" title="一、1.16版本回顾"></a>一、1.16版本回顾</h3><blockquote><p>9月18日，Kubernetes 1.16正式发布，其包含31项增强功能，其中8项增强功能已经GA，另有8项增强功能处于beta阶段，15项处于alpha阶段，该版本有以下亮点:</p></blockquote><ul><li><p>自定义资源(CRD)</p><p>  CRD作为Kubernetes的可扩展机制之一得到广泛使用，其自1.7版本发布以来就一直处于beta阶段。Kubernetes 1.16版本，也标志着CRD迎来了GA版本。</p></li><li><p>存储卷扩展</p><p>  新版本当中包含一系列与存储卷以及卷修改相关的功能。CSI规范中的存储卷大小调整能力提升为beta阶段，允许用户对CSI规范下的存储卷插件进行大小调整。</p></li><li><p>拓扑管理[alpha]</p><p>  Kubelet中旨在协调资源分配决策，从而提供优化效果更好的资源分配能力</p></li><li><p>双栈[alpha]</p><p>  IPv4/IPv6双栈可以将IPv4与IPv6地址分配给各Pod与服务<br>  a. Pod 的多个 IPv4/IPv6 地址分配<br>  b. 集群之间本地双栈通信</p></li></ul><p>下述表单为kubernetes维护时限</p><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、1-17-版本动态"><a href="#二、1-17-版本动态" class="headerlink" title="二、1.17 版本动态"></a>二、1.17 版本动态</h3><pre><code>社区1.17版本的代码freeze时间节点为11月18日，正式发布在12月9日左右，社区在调度、存储等方面进行大量优化，一些PR的进展如下：</code></pre><h4 id="一般更新"><a href="#一般更新" class="headerlink" title="一般更新"></a>一般更新</h4><ol><li>klog升级至v1.0.0</li><li><p>更新SIG图谱，详见community#4129</p><ul><li><p>将特定cloud provider修改为公有云SIG子项目</p></li><li><p>移除容器认证工作组</p></li><li><p>新增Usability SIG等</p></li></ul></li><li>推迟NodeRestriction admission插件研发时间至1.19</li><li>解决kubectl flag <code>--certificate-authority</code>重写问题</li><li>kubeadm不再移除/etc/cni/net.d目录</li><li>etcd server版本升级至3.3.17</li><li>kubeadm配置版本从v1beta1升级至v1beta2</li><li><p>golang性能优化</p><ul><li><p>encoding/json中的sync.Pool使用scanner</p></li><li><p>golang抢占调度，详见golang#24543，里程碑设定于Go 1.14版本</p></li><li><p>优化complie、link</p></li></ul></li><li><p>统一CRI于docker shim字节流长度，限定readiness/liveness字节流输出长度10kb</p></li><li>为相关组件新增readyz及livez接口</li><li>限制kubelet静态pod文件最大长度为10MB，防范Dos</li><li>增加PVC存储需求为负数的校验</li><li>移除firewalld监控，优化iptables处理</li><li><p>云服务商相关：</p><ul><li><p>openstack中doSafeMakeDir时可能带来的fd泄露</p></li><li><p>openstack LB删除故障处理，详见kubernetes#82264</p></li><li><p>azure控制器新增操作技术相关指标</p></li><li><p>升级azure sdk client至v33.1.0，优化API调用</p></li></ul></li><li><p>metrics-server版本升级至0.3.5</p></li><li>hyperkube镜像将不再与kubernetes一同发行</li></ol><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li><p>解决API-Server处理JSON/YAML时面临DoS安全风险（CVE-2019-11253），详情可参看issue#83253</p></li><li><p>net/textproto 头部字段兼容性处理导致CVE-2019-16276</p></li><li><p>非常规构建JSON安全风险问题，详见kubernetes#81158</p></li></ul><h4 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h4><ol><li><p>升级Go 1.13.3</p><ul><li><p>解决当http2握手时的写错误，transport永久缓存断链，详见go#34978</p></li><li><p>Go页分配器未优化导致apiserver延迟及内存趋高等问题，解决详见go#34978、go#35112，此问题的讨论过程详见go#32828</p></li><li><p>解决go mod在k8s模块的使用，更新heketi模块，详见kuberneets#82506</p></li></ul></li><li><p>升级etcd client 3.3.17：详见kubernetes#83801</p><ul><li><p>解决客户端无法正确解析IPv6</p></li><li><p>etcd集群故障时无法证书检查时dns不匹配</p></li></ul></li><li><p>apiserver故障</p><ul><li>当CRD资源定义中包含x-kubernetes-int-or-string字段，导致apiextensions panic：详见kubernetes#83787</li></ul></li><li><p>存储故障</p><ul><li>kubelet重启时清理raw bolck，详见kubernetes#83451</li></ul></li></ol><h4 id="特性维护"><a href="#特性维护" class="headerlink" title="特性维护"></a>特性维护</h4><ol><li><p>调度优化</p><ul><li><p>新增pre-filter插件以更新pod状态</p></li><li><p>将内置调度算法插件化：framwork等</p></li><li><p>TaintNodesByCondition特性1.17正式GA，移除节点状态相关predicate算法：内存、磁盘、PID、状态，以TaintNodesByCondition替换</p></li><li><p>新增调度队列操作pod的相关指标</p></li><li><p>新增调度相关延迟及请求相关指标</p></li><li><p>将调度插件中节点计算分范围从【0，10】调整为【0，100】，其不会影响第三方及RequestedToCapacityRatio算法</p></li></ul></li><li><p>优化EndpointSlice特性</p><ul><li>通过使用string对比替换IP，在kube-proxy启用EndpointSlice时，显著提升性能～50%，详见kubernetes#83035</li></ul></li><li><p>apiserver增强</p><ul><li>新增认证功能延迟的监控指标</li><li>移除apiserver loopback客户端QPS限制，其将影响apiserver性能，详见kuberneets#80465</li><li>提供开启/关闭 REST API及特性配置：–runtime-config=api/beta=false –feature-gates=AllBeta=false</li><li>解决kube-apiserver goroutine泄露，详见kubernetes#83333</li><li>WatchBookmark特性1.17正式GA</li></ul></li><li><p>dns优化</p><ul><li>kube-dns降权运行，详见kubernetes#82347</li></ul></li><li><p>存储优化：</p><p> a. CSI raw block特性</p><ul><li>拆分NodeStage / NodePublish</li><li><p>修改重启kubelet时的volume重建逻辑</p><p>b. VolumeSubpathEnvExpansion特性正式GA</p></li></ul></li><li><p>控制器优化</p><ul><li><p>优化ReplicaSet处理逻辑：创建/删除时考虑pod相关性，详见kubernetes#80004</p></li><li><p>Pod Disruption Budged对象处理优化，详见kubernetes#83951</p></li></ul></li></ol><hr><h3 id="三、CNCF相关"><a href="#三、CNCF相关" class="headerlink" title="三、CNCF相关"></a>三、CNCF相关</h3><ol><li><p>Jaeger项目顺利毕业</p><p> 相关介绍：Jaeger由Uber开源的端到端分布式追踪平台，用于监控与排查应用故障。</p></li><li><p>Vitess项目顺利毕业</p><p> 相关介绍：Vitess最初在2010年由YouTube创建的一个内部解决方案，用于MySQL集群扩展 ，近期发布4.0版本。</p></li><li><p>CNCF发布2019/2020赞助企划书及KubeCon相关日程</p><p> 会议：2020年KubeCon + CloudNativeCon + 中国开源峰会<br> 日程：中国上海|2020年7月28日-30日<br> 人数：4000多名参会者</p></li></ol><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kubernetes 1.17&lt;/a&gt;当前changlog，&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
</feed>
