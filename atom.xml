<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Indagate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ustack.io/"/>
  <updated>2020-04-20T13:35:55.790Z</updated>
  <id>https://ustack.io/</id>
  
  <author>
    <name>zouyee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux hugepages原理概念</title>
    <link href="https://ustack.io/2020-04-20-Kubernetes%E8%BF%9B%E9%98%B6%E4%B9%8BNT%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%A7%A3.html"/>
    <id>https://ustack.io/2020-04-20-Kubernetes进阶之NT技术小解.html</id>
    <published>2020-04-20T12:40:08.000Z</published>
    <updated>2020-04-20T13:35:55.790Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/J1gtsK.md.png" alt></p><div class="note info"><p>&lt;&lt;Kubernetes进阶&gt;&gt;系列将kubernetes系统的设计理念进行深入梳理与分享。<br>在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h3><h4 id="中央处理器（Central-processing-unit）"><a href="#中央处理器（Central-processing-unit）" class="headerlink" title="中央处理器（Central processing unit）"></a>中央处理器（Central processing unit）</h4><p>在我们了解其它概念之前，我们应该首先了解一下什么是CPU，它是做什么的，它的主要组件以及相应的作用都是什么？<br>简单点说，CPU其实就是计算机内部的一个电子电路。根据一些具体的指令它可以执行基本的运算，逻辑，控制和IO操作等。<br>CPU的主要组件包括：</p><ul><li>算术逻辑单元（ALU is short for ‘arithmetic logic unit’），它主要执行一些算术和逻辑操作</li><li>处理器寄存器（processor registers），它主要的作用是给ALU提供操作数并存储ALU操作的结果</li><li>控制器（control unit），通过协调ALU，寄存器和其它组件之间的操作，从主存中取得并执行相应的指令。</li></ul><p>当今大多数地CPU都是微处理器，即它们被包含在单个集成电路芯片（integrated circuit chip）中。一个包含CPU的集成电路可能也包含内存，<br>外围接口和其它的一些计算机组件。这样的集成设备叫做微控制器（microcontrollers）或者芯片上的系统（SoC）。一些计算机采用多核处理器，<br>即单个芯片中包含2个或更多的CPU（也被叫做“cores”）; 在这种情况下，单个芯片有时也被称作”sockets”.</p><p>下图表示的是CPU与主存和IO之间的交互。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1cvxP.md.png" alt="CPU与主存和IO之间的交互"></p><h4 id="多个CPU"><a href="#多个CPU" class="headerlink" title="多个CPU"></a>多个CPU</h4><p>贯穿这个数字计算机的历史，我们一直以来的目标就是想要计算机可以做更多的事情，并且做的更快。因此在hyper-threading 和 multi-core CPUs<br>出现之前，人们想到通过增加CPU的数量来增加计算机的计算机能力和速度，但是这样的方法并没有在个人PC中得到普及，我们只会在一些超级计算机或者一<br>些服务器上会看到这个多个CPU的计算机。因为多个CPU会需要主板有多个CPU socket - 多个CPU被插入到不同的socket中。同时主板也需要额外的硬件<br>去连接这些CPU socket到RAM和一些其它的资源。如果CPU之间需要彼此通信，多个CPU的系统会有很大地开销。</p><h4 id="Hyper-Threading"><a href="#Hyper-Threading" class="headerlink" title="Hyper-Threading"></a>Hyper-Threading</h4><p>由于多个CPU上面存在的缺点，因此它并没有进入普通大众的电脑中，因此消费者电脑的计算始终没有达到并行的状态，电脑的速度也一直没有加快。直到多核<br>处理器和Hyper-Threading技术的出现，才改变了这一点。Hyper-threading这个概念是Intel提出的，这家伟大的公司想把计算机并行计算的能力带入到<br>个人PC中，它第一次进入大众PC的产品是2002年的Pentium 4 HT，最初的这款处理器仅有单个CPU核心，因此它一次只能做一件事情。但是Hyper-threading<br>技术的出现弥补了这个不足。</p><p>Hyperthreading 有时叫做 simultaneous multi-threading，它可以使我们的单核CPU执行多个控制流程。这个技术会涉及到备份一些CPU硬件的一些信息，<br>比如程序计数器和寄存器文件等，而对于比如执行浮点运算的单元它只有一个备份，可以被共享。一个传统的处理器在线程之间切换大约需要20000时钟周期，而一个<br>具有Hyperthreading技术的处理器只需要1个时钟周期，因此这大大减小了线程之间切换的成本。hyperthreading技术的关键点就是：当我们在处理器中执行代<br>码时，很多时候处理器并不会使用到全部的计算能力，部分计算能力会处于空闲状态，而hyperthreading技术会更大程度地“压榨”处理器。举个例子，如果一个线<br>程必须要等到一些数据加载到缓存中以后才能继续执行，此时CPU可以切换到另一个线程去执行，而不用去处于空闲状态，等待当前线程的IO执行完毕。</p><p>Hyper-threading 使操作系统认为处理器的核心数是实际核心数的2倍，因此如果有4个核心的处理器，操作系统会认为处理器有8个核心。这项技术通常会对程序<br>有一个性能的提升，通常提升的范围大约在15%-30%之间，对于一些程序来说它的性能甚至会小于20%, 其实性能是否提升这完全取决于具体的程序。比如，这2个逻<br>辑核心都需要用到处理器的同一个组件，那么一个线程必须要等待。因此，Hyper-threading只是一种“欺骗”手段，对于一些程序来说，它可以更有效地利用CPU的<br>计算能力，但是它的性能远没有真正有2个核心的处理器性能好，因此它不能替代真正有2个核心的处理器。但是同样都是2核的处理器，一个有hyper-threading技<br>术而另一个没有，那么有这项技术的处理器在大部分情况下都要比没有的好。</p><h4 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h4><p>相比于多个处理器而言，多核处理器把多个CPU（核心）集成到单个集成电路芯片（integrated circuit chip）中，因此主板的单个socket也可以适应这样的<br>CPU，不需要去更更改一些硬件结构。一个双核的CPU有2个中央处理单元，因此不像上面我介绍的hyper-threading技术那样，操作系统看到的只是一种假象，这<br>回操作系统看到的是真正的2个核心，所以2个不同的进程可以分别在不同的核心中同时执行，这大大加快了系统的速度。由于2个核心都在一个芯片上，因此它们之间<br>的通信也要更快，系统也会有更小地延迟。</p><p>下图展示了一个Intel Core i7处理器的一个组织结构，这个微处理器芯片中有4个CPU核，每个核中都有它自己的L1和L2缓存。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gVx0.md.png" alt="Intel Core i7处理器的一个组织结构"></p><hr><h3 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在操作系统中，有多线程（multi-threading）的概念，这很好理解，因为线程是进程最小的调度单位，一个进程至少包含一个线程。本文将介绍CPU特有的超线程<br>技术。简单来说就是，多线程比较软，超线程比较硬，二者本质上都是虚拟化。</p><p>超线程(hyper-threading)其实就是同时多线程(simultaneous multi-theading),是一项允许一个CPU执行多个控制流的技术。它的原理很简单，就是把一<br>颗CPU当成两颗来用，将一颗具有超线程功能的物理CPU变成两颗逻辑CPU，而逻辑CPU对操作系统来说，跟物理CPU并没有什么区别。因此，操作系统会把工作线程分<br>派给这两颗（逻辑）CPU上去执行，让（多个或单个）应用程序的多个线程，能够同时在同一颗CPU上被执行。注意：两颗逻辑CPU共享单颗物理CPU的所有执行资源。<br>因此，我们可以认为，超线程技术就是对CPU的虚拟化。</p><p>超线程技术是同时多线程技术的一种实现形式，由Intel公司提出，而该技术背后的概念则是Sun公司的专利。Sun公司虽然倒下了，但它永远是一个伟大的公司。</p><p>纵观计算机的历史，有两个需求是驱动计算机科技进步的持续动力。<br>    第一，人类想让计算机做得更多；<br>    第二，人类想让计算机跑得更快。<br>从这个意义上讲，那些把工程师当做机器的资本家或资本家豢养的打手在榨取程序员的剩余价值的时候，就是不断地追求上述两个需求。超线程技术的发明，就是基于<br>这样的考虑，不榨干处理器的最后一滴油决不罢休。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gmrT.md.png" alt="CPU"></p><p>常规的CPU需要大约两万个时钟周期做不同线程间的切换，而超线程的CPU可以在单个时钟周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理<br>资源。例如：假设一个线程必须等到某些数据被装入到cache中，那么CPU就可以继续去执行另一个线程。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gMa4.md.png" alt="NT"></p><p>超线程允许单个处理器在同一时刻并行地抓取和执行两个独立的代码流。那么超线程是如何工作的？见下图。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1g3GR.md.png" alt="nt工作"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现超线程技术的前提:</p><ul><li>需要CPU支持</li><li>需要主板芯片组支持</li><li>需要BIOS支持</li><li>需要操作系统支持</li><li>需要应用软件支持</li></ul><p>由此可见，超线程技术虽然很酷，但需要方方面面的支持，否则就玩不转。 类似地，如果想最大可能地榨取程序员的剩余价值的话，给程序员提供实现超线程运行的软<br>硬件环境也是必须地，否则一味地让他们拼体力(加班)实在不是个好办法，因为人毕竟不是机器，人只有需要休息好了才可能有创造力，疲惫的人们大多时候是在瞎折<br>腾，往往事倍功半。</p><p>超线程(hyper-threading)本质上就是CPU支持的同时多线程(simultaneous multi-threading)技术，简单理解就是对CPU的虚拟化，一颗物理CPU可以被操<br>作系统当做多颗CPU来使用。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将介绍1.18版本后的kubelet关于CPU的管理技术方案。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener">Central processing unit</a></li><li><a href="http://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">hyper threadingexplained</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/20/J1gtsK.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&amp;lt;&amp;lt;Kubernetes进阶&amp;gt;&amp;gt;系列将kubernetes系统的设计理念进行深入梳理与分享。&lt;br&gt;在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>solo开源Service Mesh Hub</title>
    <link href="https://ustack.io/2020-04-10-servicemesh%E5%B9%B3%E5%8F%B0%E5%A4%A7%E8%A7%82.html"/>
    <id>https://ustack.io/2020-04-10-servicemesh平台大观.html</id>
    <published>2020-04-10T12:40:08.000Z</published>
    <updated>2020-04-14T13:33:23.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/10/G7eWJe.md.png" alt="hub"></p><div class="note info"><p>solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。</p></div><a id="more"></a><hr><h3 id="多集群，多网格管理平面"><a href="#多集群，多网格管理平面" class="headerlink" title="多集群，多网格管理平面"></a>多集群，多网格管理平面</h3><p>Service Mesh Hub的设计旨在丰富管理平面的操作，从单个Kubernetes集群上的单个服务网格到管理跨越多个集群的多个服务网格。 它由管理平面集群上运行的组件组成。</p><p>您可以在Service Mesh Hub中注册一个集群，该集群将处理与其他集群的通信-发现正在运行的服务网格，管理配置，抓取监控指标等等。 用户无需在集群之间切换Kubernetes即可更新服务网格或应用程序的配置，这使运行和扩展操作变得更加简单。</p><hr><h2 id="动态发现"><a href="#动态发现" class="headerlink" title="动态发现"></a>动态发现</h2><p>注册集群后，Service Mesh Hub将支持动态发现。探测器的第一个要务是找到集群上安装的所有服务网格。当发现了服务网格的控制<br>平面后，探测器会将网格资源写入管理平面集群，该集群链接到在集群注册期间写入的Kubernetes集群资源。目前，Service Mesh Hub<br>可以发现和管理Istio和Linkerd网格，并计划提供更多支持。然后，探测器将查找与网格相关联的工作负载，例如已使用该网格的<br>Sidecar代理创建了Pod的部署。它将一个MeshWorkload资源写入代表该工作负载的管理平面集群。最后，探测器还寻找暴露网格服务<br>工作负载的服务，与上述一样，其将MeshService资源写入管理平面集群。<br>此时，管理平面具备了跨多集群，多网格环境的网格，服务和工作负载的完整视图。</p><hr><h2 id="虚拟网格"><a href="#虚拟网格" class="headerlink" title="虚拟网格"></a>虚拟网格</h2><p>为了启用多群集配置，用户将多个网格组合在一起成为一个VirtualMesh的对象。虚拟网格包含一些便于跨集群通信的配置。<br>为了使虚拟网格生效，Service Mesh Hub首先尝试根据用户定义的互信模型建立户型，Service Mesh Hub附带一个代理，<br>可帮助安全地代理跨集群证书签名请求，以最大程度地减少管理证书的操作负担。一旦建立互信关系，Service Mesh Hub将<br>开始联合服务，以便跨集群访问。而在后端，Service Mesh Hub将处理网络（可能通过出口和入口网关，并可能受到用户定<br>义的流量和访问策略的影响），并确保将服务的请求准确路由到正确的目的地。用户可以通过编辑虚拟网格微调哪些服务将代理<br>到哪里。</p><p>从该版本开始，Service Mesh Hub支持使用跨多个群集的多个Istio 1.5+控制平面创建虚拟网格。后续，该团队计划增加<br>对更多网格类型的支持。</p><hr><h2 id="流量和访问策略"><a href="#流量和访问策略" class="headerlink" title="流量和访问策略"></a>流量和访问策略</h2><p>Service Mesh Hub使用户可以将简单的配置对象写入管理平面，为在所管理的任何群集之间制定服务之间的流量和访问策略。<br>它被用于转换基础的网格配置，同时从用户那里抽象出特定于网格类型的对象。TrafficPolicy定义了一组目的源（网格工作<br>负载）和目标（网格服务）之间关系，并用于描述诸如“当A向B发送POST请求，添加标头并将设置超时为10秒”之类的规则。或<br>“在集群C上对该服务的每个请求，增加超时并添加重试”。从该版本开始，流量策略支持超时设定、重试、cors、流量转移、<br>报头处理、故障注入、子集路由、加权目标等功能。请注意，某些网格物体不支持所有这些功能。 Service Mesh Hub将尽其<br>所能将其转换为基础网格配置，或将错误报告给用户。AccessPolicy用于精确控制允许哪些服务进行通信。在虚拟网格上，用<br>户可以指定全局策略来限制访问，并要求用户指定访问策略以实现与服务的通信。</p><p>借助流量和访问策略，Service Mesh Hub为用户提供了一种功能强大的语言，即使在复杂的多集群，多网状应用程序中也可以<br>指示服务应如何通信。</p><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Service Mesh Hub正在解决与多集群网络和配置有关的棘手问题，它附带了一个称为meshctl的命令行工具。 该工具提供了<br>交互式命令，使管理虚拟网格，注册集群、创建流量及访问策略变得更加容易。 它还会带有一个“describe”命令，以帮助您了<br>解您的工作负载和服务如何受到策略的影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/10/G7eWJe.md.png&quot; alt=&quot;hub&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless当打之年</title>
    <link href="https://ustack.io/2020-04-09-Serverless%E5%BD%93%E6%89%93%E4%B9%8B%E5%B9%B4.html"/>
    <id>https://ustack.io/2020-04-09-Serverless当打之年.html</id>
    <published>2020-04-09T12:40:08.000Z</published>
    <updated>2020-04-09T02:40:33.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/09/G4EVSK.md.png" alt="趋势"></p><div class="note info"><p>当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。</p><p>值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：</p></div><a id="more"></a><hr><h3 id="一、初识Serverless"><a href="#一、初识Serverless" class="headerlink" title="一、初识Serverless"></a>一、初识Serverless</h3><p>Serverless的理念是从2016年开始兴起，从其发展趋势来看，它在两三年后，可能对微服务架构的地位构成一定的挑战。</p><p>我们可以知道这么几点：</p><ul><li>开发者专注于业务，摆脱运维的负担</li><li>Serverless按需使用</li><li>Serverless运行时间计费</li><li>Serverless应用严重依赖于特定的云平台、第三方服务</li></ul><p>在一个基于AWS产品开发的Serverless应用里，由以下组件构成：</p><ul><li>API Gateway来处理并发请求，其包括认证、流量管理、授权和访问控制、监控等功能</li><li>计算服务Lambda来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等</li><li>基础设施管理CloudFormation创建和配置 AWS 基础设施部署，诸如所使用的S3存储桶的名称等</li><li>静态存储S3存储前端代码和静态资源</li><li>数据库DynamoDB存储应用的相关数据</li></ul><p>因此，Serverless 并不意味着没有服务器，只是服务器以不同功能的第三方服务的形式存在。<br>在这种情况下，模块的分层演变为不同的服务。在现今的微服务设计中，每一个领域或者子域都是一个服务。而在Serverless应用中，这些领域及子域根据他们的功能，又可能会进一步切分成不同的Serverless函数。</p><hr><h3 id="二、云的征程"><a href="#二、云的征程" class="headerlink" title="二、云的征程"></a>二、云的征程</h3><p>很久之前，我们开发的软件由C/S和MVC的架构，转变为SOA，直到最近几年的微服务架构，更近一点就是Cloud Native（云原生）应用，企业应用从单体架构，到服务化，再到更细粒度的微服务化，应用开发之初就是为了应对业务的特有的高并发、容错等特性，需要很高的性能及可扩展性，人们对软件开发的追求孜孜不倦，希望力求在软件开发的复杂度和效率之间达到一个平衡。但可惜的是，没有银弹！几十年前（1975年）Fred Brooks就在The Mythical Man-Month中就写到了这句话。那么Serverlss会是那颗银弹吗？</p><p>云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚，应用必须运行在服务器上（不论是实体还是虚拟的），并且必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，同时需要保证数据的安全性，当前的云产品能解放我们吗？</p><p>Serverless架构是云的延伸，为了理解serverless，我们有必要回顾一下云计算的发展。</p><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p>2006年AWS推出EC2（Elastic Compute Cloud），作为第一代IaaS（Infrastructure as a Service），用户可以通过AWS快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。</p><p>EC2真正对IT的改变是硬件的虚拟化（更细粒度的虚拟化），而EC2给用户带来了以下五个好处：</p><ul><li>降低劳动力成本：减少了企业本身雇佣IT人员的成本</li><li>降低风险：不用再像自己运维物理机那样，担心各种意外风险，EC2有主机损坏，再申请一个就好了。</li><li>降低基础设施成本：可以按小时、周、月或者年为周期租用EC2。</li><li>扩展性：不必过早的预期基础设施采购，因为通过云厂商可以很快的获取。</li><li>节约时间成本：快速的获取资源开展业务实验。</li></ul><p>有利有弊，我们将在后面讨论。</p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p>PaaS（Platform as a Service）是构建在IaaS之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可，最早的一代是Heroku。Heroko是商业的PaaS，还有一个开源的PaaS——Cloud Foundry，用户可以基于它来构建私有PaaS，如果同时使用公有云和私有云，如果能在两者之间构建一个统一的PaaS，那就是“混合云”了。<br>在PaaS上的卓越贡献者当属docker了，因为docker理念的横空出世，推动了PaaS技术的发展，从mesos、swarm与kubernetes的群雄逐鹿到后来kubernetes一家独大，再到CNCF的成立，这些我们后续再慢慢道来。因为使用容器的轻量、隔离型，推进了应用的容器化日程。管理云上的容器，可以称为是CaaS（Container as a Service），如GCE（Google Container Engine）。也可以基于Kubernetes、Mesos这类开源软件构件自己的CaaS，不论是直接在IaaS构建还是基于PaaS。<br>PaaS是对软件的一个更高的抽象层次，已经接触到应用程序的运行环境本身，可以由开发者自定义，而不必接触更底层的操作系统。</p><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>当然，Serverless不如IaaS和PaaS那么好理解，因为它通常包含了两个方面BaaS（Backend as a Service）和FaaS（Function as a Service）。</p><p><strong><em>BaaS</em></strong></p><p>BaaS（Backend as a Service）后端即服务，一般是一个个的API调用后端或别人已经实现好的程序逻辑，比如身份验证服务Auth0，这些BaaS通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的RDS可以替代我们自己部署的MySQL，还有各种其它数据库、中间价和存储服务等。</p><p><strong><em>FaaS</em></strong></p><p>FaaS（Functions as a Service）函数即服务，FaaS是无服务器计算的额一种形式，当前使用最广泛的是AWS的Lambada。<br>现在当大家讨论Serverless的时候首先想到的就是FaaS。FaaS本质上是一种事件驱动的由消息触发的服务，FaaS服务商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。<br>与传统的服务器端软件的不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而FaaS是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以杀死。</p><p>根据MF网站的无服务器架构定义，FaaS是：</p><ul><li><p>从根本上说，FaaS是关于运行后端代码而无需管理自己的服务器系统或您自己的长期驻留long-lived的服务器应用程序。与容器和PaaS（平台即服务）等其他现代架构趋势进行比较时，第二个子句 - 长期驻留（long-lived）的服务器应用程序是一个关键的区别。（FaaS不是长期驻留的普通API）</p></li><li><p>FaaS产品不需要对特定框架或库进行编码。FaaS函数是语言和环境的常规应用程序。例如，AWS Lambda函数可以在Javascript，Python，Go，任何JVM语言（Java，Clojure，Scala等）或任何.NET语言中实现。但是，Lambda函数还可以执行与其部署工件捆绑在一起的另一个进程，因此您实际上可以使用任何可以编译为Unix进程的语言。</p></li><li><p>部署与传统系统有很大不同，因为我们没有自己运行的服务器应用程序。在FaaS环境中，我们将函数功能的代码上传到FaaS提供商，提供商执行配置资源，实例化VM，管理流程等所需的一切。</p></li><li><p>水平扩展是完全自动的，弹性的，并由提供者管理。如果您的系统需要并行处理100个请求，则提供商将处理该请求而无需您进行任何额外配置。函数的执行是一个“计算容器”，运行是短暂的，FaaS提供者实现容器的创建和销毁完全是由运行时需求驱动。最重要的是，使用FaaS ，供应商可以处理所有底层资源配置和分配 - 用户根本不需要集群或VM管理。(容器+FaaS是Serverless重要的机制，只有容器或FaaS都是片面的，两者分别是静态和动态的)</p></li><li><p>FaaS中的函数通常由提供程序定义的事件类型触发。</p></li><li><p>大多数提供程序还允许触发函数作为对入站HTTP请求的响应; 在AWS中，通常通过使用API网关来实现这一点。函数也可以通过平台提供的API直接调用，无论是在外部还是在同一个云环境中，但这是一种相对不常见的用法。</p></li></ul><hr><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><strong><em>Serverless与FaaS</em></strong></p><p>微服务（MicroService）是软件架构领域业另一个热门的话题。如果说微服务是以专注于单一责任与功能的小型功能块为基础，利用模组化的方式组合出复杂的大型应用程序，那么我们还可以进一步认为Serverless架构可以提供一种更加“代码碎片化”的软件架构范式，我们称之为Function as a Services（FaaS）。而所谓的“函数”（Function）提供的是相比微服务更加细小的程序单元。例如，可以通过微服务代表为某个客户执行所有CRUD操作所需的代码，而FaaS中的“函数”可以代表客户所要执行的每个操作：创建、读取、更新，以及删除。当触发“创建账户”事件后，将通过AWS Lambda函数的方式执行相应的“函数”。从这一层意思来说，我们可以简单地将Serverless架构与FaaS概念等同起来。</p><p><strong><em>FaaS与PaaS的比较</em></strong></p><p>乍看起来，FaaS与PaaS的概念在某些方面有许多相似的地方。人们甚至认为FaaS就是另一种形式的PaaS。但是Intent Media的工程副总裁Mike Roberts有自己的不同看法：“大部分PaaS应用无法针对每个请求启动和停止整个应用程序，而FaaS平台生来就是为了实现这样的目的。”<br>FaaS和PaaS在运维方面最大的差异在于缩放能力。对于大部分PaaS平台，用户依然需要考虑缩放。但是对于FaaS应用，这种问题完全是透明的。就算将PaaS应用设置为自动缩放，依然无法在具体请求的层面上进行缩放，而FaaS应用在成本方面效益就高多了。AWS云架构战略副总裁Adrian Cockcroft曾经针对两者的界定给出了一个简单的方法：“如果你的PaaS能够有效地在20毫秒内启动实例并运行半秒,那么就可以称之为Serverless”。</p><p><strong><em>Serverless 的优势</em></strong></p><p>a、降低运营成本<br>Serverless是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</p><p>b、降低开发成本<br>IaaS和PaaS存在的前提是，服务器和操作系统管理可以商品化。Serverless作为另一种服务的结果是整个应用程序组件被商品化。</p><p>c、扩展能力<br>Serverless架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，您只需支付您所需要的计算能力。</p><p>d、便捷管理<br>Serverless架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</p><p>e、绿色计算<br>按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供5%～15%的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</p><p>f、更快的开发速度<br>由于 Serverless 服务提供者，已经准备好了一系列的基础服务。作为开发人员的我们，只需要关注于如何更好去实现业务，而非技术上的一些限制。服务提供者已经向我们准备，并测试好了这一系列的服务。它们基本上是稳定、可靠的，不会遇上特别大的问题。事实上，当我们拥有足够强大的代码，如使用测试来保证健壮性，那么结合持续集成，我们就可以在 PUSH 代码的时候，直接部署到生产环境。当然，可能不需要这么麻烦，我们只需要添加一个 predeploy 的 hook，在这个 hook 里做一些自动测试的工作，就可以在本地直接发布新的版本。<br>这个过程里，我们并不需要考虑太多的发布事宜。</p><p>g、系统安全性更高<br>依我维护我博客的经验来看，要保持服务器一直运行不是一件容易的事。在不经意的时候，总会发现有 Cracker 在攻击你网站。我们需要防范不同类型的攻击，如在我的服务器里一直有黑客在尝试密码登录，可是我的博客的服务器是要密钥才能登录的。在一次神奇的尝试登录攻击后，我的 SSH 守护进程崩溃了。这意味着，我只能从 EC2 后台重启服务器。有了 Serverless，我不再需要担心有人尝试登录系统，因为我都不知道怎么登录服务器。</p><p>h、适应微服务架构<br>如我们所见在最近几年里看到的那样，微服务并没有大量地替换掉单体应用——毕竟使用新的架构来替换旧的系统，在业务上的价值并不大。因此，对于很多企业来说，并没有这样的强烈需求及紧迫性。活着，才是一件更紧迫的事。而 Serverless 天生就与微服务架构是相辅相成的。一个 Serverless 应用拥有自己的网关、数据库、接口，你可还以使用自己喜欢的语言（受限于服务提供者）来开发服务。换句话来说，在这种情形下，一个 Serverless 可能是一个完美的微服务实例。<br>在可见的一二年里，Serverless 将替换到某些系统中的一些组件、服务。</p><p><strong><em>Serverless的问题</em></strong></p><p>作为一个运行时，才启动的应用来说，Serverless 也存在着一个个我们所需要的问题。</p><p>a、不适合长时间运行应用<br>Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动。这个时候，可以结合 CRON 的方式或者 CloudWatch 来定期唤醒应用。<br>如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。在这种情况下，采用 EC2 这样的云服务器往往是一种更好的选择。因为 EC2 从价格上来说，更加便宜。</p><p>b、完全依赖于第三方服务<br>是的，当你决定使用某个云服务的时候，也就意味着你可能走了一条不归路。在这种情况下，只能将不重要的 API 放在 Serverless 上。当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用 Serverless 架构的时候，我们就和特别的服务供应商绑定了。我们使用了 AWS 家的服务，那么我们再将服务迁到 Google Cloud 上就没有那么容易了。<br>我们需要修改一下系列的底层代码，能采取的应对方案，便是建立隔离层。这意味着，在设计应用的时候，就需要：</p><ul><li>隔离 API 网关</li><li>隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你即支持 Firebase，又支持 DynamoDB</li><li>等等</li></ul><p>这些也将带给我们一些额外的成本，可能带来的问题会比解决的问题多。</p><p>c、冷启动时间<br>如上所说，Serverless 应用存在一个冷启动时间的问题。</p><p>d、缺乏调试和开发工具<br>当使用 Serverless Framework 的时候，遇到了这样的问题：缺乏调试和开发工具。<br>并且，对于日志系统来说，这仍然是一个艰巨的挑战。每次你调试的时候，你需要一遍又一遍地上传代码。而每次上传的时候，你就好像是在部署服务器。然后 Fuck 了，我并不能总是快速地定位出问题在哪。于是，我修改了一下代码，添加了一行 console.log，然后又一次地部署了下代码。问题解决了，挺好的，我删了一下 console.log，然后又一次地部署了下代码。</p><p>e、构建复杂<br>Serverless 很便宜，但是这并不意味着它很简单。</p><p>两者都为我们的计算资源提供了弹性的保障，BaaS其实依然是服务外包，而FaaS使我们更加关注应用程序的逻辑，两者使我们不需要关注应用程序所在的服务器，但实际上服务器依然是客观存在的。<br>当我们将应用程序迁移到容器和虚拟机中时，其实对于应用程序本身的体系结构并没有多少改变，只不过有些流程和规定需要遵守，比如12因素应用守则，但是serverlss对应用程序的体系结构来说就是一次颠覆了，通常我们需要考虑事件驱动模型，更加细化的不熟形式，以及在FaaS组件之外保持状态的需求。</p><hr><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>通过将 Serverless 的理念与当前 Serverless 实现的技术特点相结合，Serverless 架构可以适用于各种业务场景。</p><p>1.Web应用<br>Serverless 架构可以很好地支持各类静态和动态Web应用。如 RESTful API 的各类请求动作（GET、POST、PUT及DELETE等）可以很好地映射成 FaaS 的一个个函数，功能和函数之间能建立良好的对应关系。通过 FaaS 的自动弹性扩展功能，Serverless Web 应用可以很快速地构建出能承载高访问量的站点。</p><p>2.移动互联网<br>Serverless 应用通过 BaaS 对接后端不同的服务而满足业务需求，提高应用开发的效率。前端通过FaaS提供的自动弹性扩展对接移动端的流量，开发者可以更轻松地应对突发的流量增长。在 FaaS 的架构下，应用以函数的形式存在。各个函数逻辑之间相对独立，应用更新变得更容易，使新功能的开发、测试和上线的时间更短。</p><p>3.物联网（Internet of Things，IoT）<br>物联网（Internet of Things，IoT）应用需要对接各种不同的数量庞大的设备。不同的设备需要持续采集并传送数据至服务端。Serverless 架构可以帮助物联网应用对接不同的数据输入源。</p><p>4.多媒体处理<br>视频和图片网站需要对用户上传的图片和视频信息进行加工和转换。但是这种多媒体转换的工作并不是无时无刻都在进行的，只有在一些特定事件发生时才需要被执行，比如用户上传或编辑图片和视频时。通过 Serverless 的事件驱动机制，用户可以在特定事件发生时触发处理逻辑，从而节省了空闲时段计算资源的开销，最终降低了运维的成本。</p><p>5.数据及事件流处理<br>Serverless 可以用于对一些持续不断的事件流和数据流进行实时分析和处理，对事件和数据进行实时的过滤、转换和分析，进而触发下一步的处理。比如，对各类系统的日志或社交媒体信息进行实时分析，针对符合特定特征的关键信息进行记录和告警。</p><p>6.系统集成<br>Serverless 应用的函数式架构非常适合用于实现系统集成。用户无须像过去一样为了某些简单的集成逻辑而开发和运维一个完整的应用，用户可以更专注于所需的集成逻辑，只编写和集成相关的代码逻辑，而不是一个完整的应用。函数应用的分散式的架构，使得集成逻辑的新增和变更更加灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/09/G4EVSK.md.png&quot; alt=&quot;趋势&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。&lt;/p&gt;
&lt;p&gt;值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18 福履将之</title>
    <link href="https://ustack.io/2020-03-25-Kubernetes%201.18%20%E7%A6%8F%E5%B1%A5%E5%B0%86%E4%B9%8B.html"/>
    <id>https://ustack.io/2020-03-25-Kubernetes 1.18 福履将之.html</id>
    <published>2020-03-25T12:40:08.000Z</published>
    <updated>2020-03-25T10:32:17.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt="k8s"></p><div class="note info"><p>Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？</p><p>有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。</p><p>我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。</p></div><p>此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！</p><p>以下为Kubernetes 1.18中新功能的详细列表。</p><a id="more"></a><hr><h3 id="一、版本维护"><a href="#一、版本维护" class="headerlink" title="一、版本维护"></a>一、版本维护</h3><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、Kubernetes-1-18-主要变更"><a href="#二、Kubernetes-1-18-主要变更" class="headerlink" title="二、Kubernetes 1.18 主要变更"></a>二、Kubernetes 1.18 主要变更</h3><h4 id="核心变更"><a href="#核心变更" class="headerlink" title="核心变更"></a>核心变更</h4><ol><li>＃1393 为服务帐户提供OIDC的支持</li></ol><p>维护阶段：Alpha<br>SIG-Group：auth</p><p>Kubernetes服务帐户（KSA）可以使用令牌（JSON Web令牌或JWT）对Kubernetes API进行身份验证，例如使用kubectl –token &lt;the_token_string&gt;。需要注意的是，Kubernetes API是唯一可以验证这些令牌的服务。</p><p>由于无法（也不应该）从公共网络访问Kubernetes API服务器，因此某些工作负载必须使用单独的系统进行身份验证。比如跨群集进行身份验证时，从群集内部到其他地方进行身份验证。</p><p>此增强功能旨在让KSA令牌更实用，从而使群集外部的服务可以将它们用作常规身份验证方法，而不会使API Server过载。为此，API服务器提供了一个OpenID Connect（OIDC）相关文档，其中包含令牌公共密钥以及其他数据。现有的OIDC身份验证者可以使用这些密钥来验证KSA令牌等。</p><p>可以使用ServiceAccountIssuerDiscovery功能门启用OIDC发现，但需要进行一些配置才能使用。</p><ol start="2"><li>＃853 HPA的扩展速度可配</li></ol><p>维护阶段：Alpha<br>SIG-Group：autoscaling</p><p>HPA可以自动扩展Pod的数量，以满足调整工作负载的需求。 到目前为止，您只能为整个集群定义全局缩放速度。 但是，并非所有应用场景的使用资源情况都一样，因此您可能更需要的是针对特殊群体的扩展效率的个性化方案。</p><p>现在，可以将这些需求添加到HPA配置中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line"><span class="attr">   scaleDown:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Percent</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">   scaleUp:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Pods</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p>在此示例中，pod可以每15秒加倍。 缩容时，每分钟可以减少四个pod。 检查文档中的完整语法。</p><ol start="3"><li>＃1513 CertificateSigningRequest API</li></ol><p>维护阶段：Beta<br>SIG-Group：auth</p><p>每个Kubernetes集群都有一个根证书颁发机构，该CA用于保护核心组件之间的通信，这些组件由Certificates API处理，它开始用于为非核心用途提供证书。</p><p>此增强功能旨在适应新的应用场景，从而改善签名过程及其安全性。</p><p>注册机构的数字，即批准者，确保实际的请求者已经提交了证书签名请求（CSR）； 同时他们还确保请求者具有提交该请求的适当权限。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKbd0.md.png" alt="CertificateSigningRequest-API"></p><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ol><li>＃1451 运行多个调度配置文件</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>并非Kubernetes集群中的所有工作负载都相同。您很可能希望将Web服务器分布在尽可能多的节点上，同时您可能希望在同一节点中捆绑尽可能多的对延迟敏感的资源。这就是为什么您需要在同一集群中配置多个调度程序，并指定每个Pod使用哪个调度程序的原因。</p><p>但是，这可能会导致竞争状况，因为每个调度程序在给定时刻可能具有不同的集群资源数据。</p><p>此增强功能使您可以运行一个具有不同配置的调度程序，每个配置都有其自己的调度名称。 Pod会继续使用schedulerName来定义要使用的配置文件，但是它将由相同的调度程序来完成工作，从而避免出现竞争情况。</p><ol start="2"><li>＃895 topologySpreadConstraints</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：scheduling</p><p>使用topologySpreadConstraints，您可以定义规则以在整个多区域群集中均匀分布pod，因此高可用性将正确运行，并且资源利用率将得到提高。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃1258添加可配置的默认Even Pod传播规则</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>为了利用均匀的pod扩散优势，每个pod都需要有自己的扩散规则，这可能是一项繁琐的任务。</p><p>通过此增强功能，您可以定义全局defaultConstraints，这些默认defaultConstraints将在群集级别应用到所有未定义其自己的topologySpreadConstraints的Pod。</p><ol start="4"><li>＃166基于污点驱逐</li></ol><p>维护阶段：GA<br>SIG-Group：scheduling</p><p>在Kubernetes 1.13中，基于污点的驱逐的功能，在从alpha阶段变为beta阶段后，默认启用此功能（–feature-gates中的TaintBasedEvictions = true），NodeController（或kubelet）会自动添加污点，并且基于Ready NodeCondition禁用了从节点逐出pod的逻辑。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ol><li>＃1539扩展HugePages功能</li></ol><p>维护阶段：GA<br>SIG-Group：node</p><p>HugePages是一种保留具有预定义大小的大内存块的机制，由于硬件优化，这些块可以更快地访问。这对于处理内存中的大的数据集或对内存访问延迟敏感的应用程序（例如数据库或虚拟机）特别有用。</p><p>在Kubernetes 1.18中，此功能添加了两个增强配置。</p><p>首先，现在允许Pod请求不同大小的HugePage。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        hugepages-2Mi:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">        hugepages-1Gi:</span> <span class="number">2</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>其次，已经实现了HugePages的容器隔离，以解决Pod可能使用比请求更多的内存，最终导致资源匮乏的问题。</p><ol start="2"><li>＃688 Pod Overhead：帐户资源绑定到Pod沙箱，但不包含特定的容器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>除了请求的资源之外，您的Pod还需要额外的资源来维护其运行时环境。</p><p>启用PodOverhead功能后，Kubernetes将在调度Pod时考虑到此开销。此开销与pod使用的RuntimeClass相关联。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃693节点拓扑管理器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>机器学习，科学计算和金融服务是计算密集型且要求超低延迟的系统的场景。这些类型的工作负载受益于隔离到一个CPU内核的进程，而不是在内核之间切换或与其他进程共享。</p><p>节点拓扑管理器是一个kubelet组件，可集中协调硬件资源分配。当前方法将此任务划分为几个组件（CPU管理器，设备管理器，CNI），这有时会导致分配未优化。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃950为慢启动的pod添加pod-startup、liveness-probe</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>探针使Kubernetes可以监视应用程序的状态。如果Pod启动所需的时间太长，这些探针可能会认为Pod已死，从而导致重新启动循环。此功能使您可以定义一个启动探针，该探针将推迟所有其他探针，直到容器完成其启动。例如，“在给定的HTTP端点可用之前，请勿测试活动性”。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="网路"><a href="#网路" class="headerlink" title="网路"></a>网路</h4><ol><li>＃752 EndpointSlice API</li></ol><p>维护阶段：Beta重大更新<br>SIG-Group：network</p><p>新的EndpointSlice API将把端点分为几个Endpoint Slice资源。这解决了当前API中与大型Endpoints对象有关的许多问题。该新API还旨在支持其他将来的功能，例如每个吊舱有多个IP。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="2"><li>＃508 IPv6支持添加</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>早在Kubernetes 1.9上就引入了对仅IPv6群集的支持。此功能已由社区进行了广泛的测试，现在正逐步升级为Beta。</p><ol start="3"><li>＃1024 节点本地DNS缓存到GA</li></ol><p>阶段：毕业至稳定<br>功能组：网络</p><p>NodeLocal DNSCache通过在群集节点上作为Daemonset运行dns缓存代理来提高群集DNS性能，从而避免了iptables DNAT规则和连接跟踪。本地缓存代理将查询dns服务以获取集群主机名的未命中缓存（默认为cluster.local后缀）。</p><p>您可以阅读其Kubernetes增强建议（KEP）文档中的设计说明，以了解有关此Beta功能的更多信息。</p><p>在1.15版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1453 ingress功能增强</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>Ingress资源将外部HTTP和HTTPS路由公开为服务，集群中的其他服务可以访问这些服务。</p><p>该API对象包含在Kubernetes 1.1中，成为事实上的稳定功能。此增强功能消除了Ingress实施之间的不一致之处。</p><p>例如，您现在可以定义一个pathType来显式声明将路径视为前缀还是完全匹配。如果Ingress中的多个路径与请求匹配，则最长的匹配路径将优先。</p><p>另外，不建议使用kubernetes.io/ingress.class注释。现在应该使用新的ingressClassName字段和IngressClass资源。</p><ol start="5"><li>＃1507将AppProtocol添加到服务和端点</li></ol><p>维护阶段：GA<br>SIG-Group：network</p><p>EndpointSlice API在Kubernetes 1.17中添加了一个新的AppProtocol字段，以允许为每个端口指定应用程序协议。此增强功能将该字段带入ServicePort和EndpointPort资源中，替换了可能引起不良用户体验的非标准注释。</p><h4 id="API相关"><a href="#API相关" class="headerlink" title="API相关"></a>API相关</h4><ol><li>＃1040 API服务器请求的优先级和公平性</li></ol><p>维护阶段：Alpha<br>SIG-Group：api-machinery</p><p>在高负载期间，Kubernetes API服务器需要负责管理和维护任务。现有的–max-requests-inflight和–max-mutating-requests-inflight命令行标志可以限制传入的请求，但它们的粒度过于粗糙，并且在流量繁忙时会过滤掉重要的请求。</p><p>APIPriorityAndFairness功能门可在apiserver中启用新的请求处理流程。您可以使用FlowSchema对象定义不同类型的请求，并使用RequestPriority对象为它们设定资源优先级。</p><p>例如，垃圾收集器是低优先级服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">FlowSchema</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  matchingPriority:</span> <span class="number">900</span></span><br><span class="line"><span class="attr">  requestPriority:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">  flowDistinguisher:</span></span><br><span class="line"><span class="attr">    source:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  match:</span></span><br><span class="line"><span class="attr">  - and:</span></span><br><span class="line"><span class="attr">    - equals:</span></span><br><span class="line"><span class="attr">      field:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">system:controller:garbage-collector</span></span><br></pre></td></tr></table></figure><p>因此，您可以为其分配很少的资源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>但是，自我维护请求具有更高的优先级：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-high</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">  handSize:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>您可以在增强建议中找到更多示例。</p><ol start="2"><li>＃1601 client-go签名相关重构，以标准化选项和上下文处理</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>在client-go上已经完成了一些代码重构，许多文件都使用该库来连接到Kubernetes API，以保持方法签名的一致性。</p><p>这包括向一些方法中添加上下文对象，该对象在API边界和进程之间承载请求范围的值。访问此对象可简化一些功能的实现，例如在超时和取消后释放调用线程，或添加对分布式跟踪的支持。</p><ol start="3"><li>＃576 APIServer DryRun</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>ryRun运行模式使您可以模拟真实的API请求，并查看请求是否成功（准入控制器链，验证，合并冲突等）和在不实际修改状态的情况下会发生什么。该请求的响应主体应尽可能接近非空运行响应。此核心功能将启用其他用户级别的功能，例如kubectl diff子命令。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1281 API服务器网络代理KEP到Beta</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：api-machinery</p><p>有些用户（大多数是云提供商）更喜欢将其群集API Server隔离在单独的控制网络中，而不是在集群网络中。实现此功能的一种方法是保持与其他集群组件的连通性，同时使用API Server网络代理。</p><p>具有此额外的层可以启用其他功能，例如元数据审核日志记录和传出API服务器连接的验证。</p><p>在Kubernetes 1.18中，API Server代理允许在服务，节点，webhooks和Pods之外的单独网络中分离API。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKOiT.md.png" alt="Kubernetes-1.18-enhancement-1281-API-Server-Network-Proxy.png"></p><p>此增强功能涵盖了解决一些已知问题并让该代理支持一般性的工作，例如从Kubernetes API服务器中删除SSH隧道代码，以及改善控制网络与集群网络的隔离。</p><h4 id="Windows变更"><a href="#Windows变更" class="headerlink" title="Windows变更"></a>Windows变更</h4><ol><li>＃1001在Windows上支持CRI-ContainerD</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>ContainerD是与Kubernetes兼容的OCI兼容运行时。与Docker相反，ContainerD在Windows Server 2019中包括对主机容器服务（HCS v2）的支持，该服务可更好地控制容器的管理方式并可以改善Kubernetes API的兼容性。</p><p>此增强功能引入了Windows中作为容器运行时接口（CRI）的ContainerD 1.3支持。在此增强页面中查看更多详细信息。</p><ol start="2"><li>＃1301在Windows上实现RuntimeClass</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>使用RuntimeClass，您可以定义集群中存在的不同类型的节点，然后使用runtimeClassName指定可以将Pod部署在哪些节点中。此功能在Kubernetes 1.12上引入，并在Kubernetes 1.14上进行了重大更改。</p><p>此增强功能将此功能扩展到Windows节点，这在异构集群包含Windows Pod时，对部署在Windows节点上非常有用。这是定义RuntimeClass的方法，以将pod限制为Windows Server 1903版（10.0.18362）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">node.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RuntimeClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">windows-1903</span></span><br><span class="line"><span class="attr">handler:</span> <span class="string">'docker'</span></span><br><span class="line"><span class="attr">scheduling:</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line">    <span class="string">kubernetes.io/os:</span> <span class="string">'windows'</span></span><br><span class="line">    <span class="string">kubernetes.io/arch:</span> <span class="string">'amd64'</span></span><br><span class="line">    <span class="string">node.kubernetes.io/windows-build:</span> <span class="string">'10.0.18362'</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">windows</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Equal</span></span><br><span class="line"><span class="attr">    value:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>然后，您需要在pod中使用runtimeClassName，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  runtimeClassName:</span> <span class="string">windows-1903</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>检查增强页面以获取更多详细信息。</p><ol start="3"><li>＃689为Windows工作负载支持GMSA</li></ol><p>维护阶段：GA<br>SIG-Group：windows</p><p>这将使操作员可以在部署时选择GMSA，并使用它运行容器以连接到现有应用程序（例如数据库或API服务器），而无需更改组织内部对身份验证和授权的管理方式。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1043 Windows版RunAsUserName</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：windows</p><p>现在，Kubernetes支持组托管服务帐户，我们可以使用Windows的runAsUserName特定属性来定义哪个用户将运行容器的入口点。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="5"><li>＃995 Windows版Kubeadm</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：cluster-lifecycle</p><p>Kubernetes 1.14中引入了对Windows节点的支持，但是没有一种简单的方法可以将Windows节点加入集群。</p><p>从Kubernetes 1.16开始，具有部分功能的Windows用户可以使用kubeadm join。它将缺少一些功能，例如kubeadm init或kubeadm join –control-plane。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol><li>＃695跳过卷所有权更改</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>在将卷绑定安装到容器内之前，其所有文件权限都将更改为提供的fsGroup值。这最终会导致非常大的卷上的缓慢过程，还会破坏一些对权限敏感的应用程序，例如数据库。</p><p>已添加新的FSGroupChangePolicy字段以控制此行为。如果设置为始终，它将保持当前行为。但是，当设置为OnRootMismatch时，仅当顶级目录与预期的fsGroup值不匹配时，它才会更改卷权限。</p><ol start="2"><li>＃1412不可变的Secrets和ConfigMap</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>新的不可变字段已添加到Secrets和ConfigMaps中。设置为true时，将拒绝对资源密钥所做的任何更改。这样可以保护集群数据，避免意外或错误更新从而破坏应用程序。</p><p>由于它们不变，因此Kubelet不需要定期检查其更新，这可以提高可伸缩性和性能。</p><p>启用ImmutableEmphemeralVolumes功能门之后，您可以执行以下操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是，一旦将资源标记为不可变，就无法还原此更改。您只能删除并重新创建密钥，并且需要重新创建使用已删除密钥的Pod。</p><ol start="3"><li>＃1495通用数据填充器</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>这项增强功能为用户创建预先填充的卷奠定了基础。例如，使用操作系统映像预填充用于虚拟机的磁盘，或启用数据备份和还原。</p><p>为此，将取消对持久卷的DataSource字段的当前验证，从而允许将任意对象设置为值。有关如何填充卷的实现详细信息委托给专用控制器。</p><ol start="4"><li>＃770</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>这种内部优化将简化为不需要附加/分离操作的容器存储接口（CSI）驱动程序（例如NFS或临时机密卷）创建VolumeAttachment对象的操作。</p><p>对于这些驱动程序，Kubernetes Attach/Detach控制器始终创建VolumeAttachment对象，并一直等到它们被报告为“已绑定”。对CSI卷插件进行了更改，以跳过此步骤。</p><ol start="5"><li>＃351使用永久卷源的BlockVolume</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>BlockVolume在Kubernetes 1.18中达到了常规可用性。您可以仅将volumeMode的值设置为block即可访问原始块设备。使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的高性能应用程序（如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="6"><li>＃565 CSI块存储支持</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的应用程序（例如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="7"><li>＃603在CSI调用中传递Pod信息</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>CSI存储驱动程序可以选择接收关于在NodePublish请求中请求卷的Pod的信息，例如Pod名称和名称空间。</p><p>CSI驱动程序可以使用此信息来授权或审核卷的使用，或生成针对Pod定制的卷内容。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="8"><li>＃989扩展允许的PVC数据源</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用此功能，可以“克隆”现有的持久卷。克隆会导致从现有卷中调配新的重复卷。</p><p>在1.15版本的Kubernetes新增功能中阅读更多内容。</p><hr><h3 id="Kubernetes-1-18-其他更新"><a href="#Kubernetes-1-18-其他更新" class="headerlink" title="Kubernetes 1.18 其他更新"></a>Kubernetes 1.18 其他更新</h3><ol><li>＃1441 kubectl调试</li></ol><p>维护阶段：Alpha<br>SIG-Group：功能组：cli</p><p>添加了新的kubectl debug命令以扩展调试功能。</p><p>此命令允许在正在运行的Pod中创建临时容器，使用修改后的PodSpec重新启动Pod，以及启动并附加到主机名称空间中的特权容器。</p><ol start="2"><li>＃1020将kubectl软件包代码移至暂存</li></ol><p>维护阶段：GA<br>SIG-Group：功能组：cli</p><p>kubectl代码的这种内部重组是将kubectl二进制文件移到其自己的存储库中的第一步。这有助于将kubectl与kubernetes代码库分离，并使树外项目更易于重用其代码。</p><ol start="3"><li>＃1333禁用没有Beta REST API或功能</li></ol><p>维护阶段：Beta<br>SIG-Group：architecture</p><p>此增强功能收集了所做的工作，以确保Kubernetes组件和Kubernetes一致性都不依赖于Beta REST API或功能。最终目标是确保各个发行版之间的一致性，因为启用非GA功能不需要使用非官方发行版（例如k3s，Rancher或Openshift）。</p><ol start="4"><li>＃491 Kubectl Diff</li></ol><p>维护阶段：GA<br>SIG-Group：cli</p><p>kubectl diff将为您预览kubectl将对您的集群进行哪些更改。尽管易于描述，但此功能对于群集操作员的日常工作确实非常方便。请注意，您需要在API服务器上启用dry run功能，此命令才能起作用。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃670支持vSphere Cloud Provider</li></ol><p>维护阶段：GA<br>SIG-Group：cloud-provider</p><p>提供对vSphere云提供商的支持。这涉及到经过测试的云控制器管理器版本，该版本具有与kube-controller-manager奇偶校验的功能。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.18.md" target="_blank" rel="noopener">kubernetes 1.18</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt=&quot;k8s&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？&lt;/p&gt;
&lt;p&gt;有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。&lt;/p&gt;
&lt;p&gt;我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！&lt;/p&gt;
&lt;p&gt;以下为Kubernetes 1.18中新功能的详细列表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18之Ingress API优化</title>
    <link href="https://ustack.io/2020-03-25-Kubernetes%201.18%E4%B9%8BIngress%20API%E4%BC%98%E5%8C%96.html"/>
    <id>https://ustack.io/2020-03-25-Kubernetes 1.18之Ingress API优化.html</id>
    <published>2020-03-25T12:40:08.000Z</published>
    <updated>2020-04-09T02:42:00.833Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>Kubernetes中的Ingress API对外提供简单而功能强劲的方法来管理与kubernetes集群内工作负载通信的入网流量。 在Kubernetes 1.18版本中，我们对Ingress API进行了以下3项重大改进：</p><ul><li>新增pathType字段，可以指定应该匹配哪种Ingress路径</li><li>新增IngressClass资源，可以指定控制器应如何实现Ingress</li><li>支持主机名的通配符</li></ul></div><a id="more"></a><h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>新增的pathType字段，可以指定应该匹配哪种Ingress路径。 当前支持三种类型：</p><ul><li>ImplementationSpecific（默认）: 使用此路径类型，匹配方式取决于实现IngressClass的控制器</li><li>完全匹配: 与URL完全匹配且区分大小写</li><li>前缀: 以/分隔的URL路径前缀进行匹配。 匹配区分大小写，并且在逐个路径的基础上进行匹配</li></ul><h3 id="Ingress配置增强"><a href="#Ingress配置增强" class="headerlink" title="Ingress配置增强"></a>Ingress配置增强</h3><p>Ingress资源在设计时秉承简易性设计准则，从而提供了一组简易字段以满足绝大多数应用场景。 但随着时间的推移，以及使用场景的拓宽，开始依赖各种的自定义注释来进行进一步的配置。 因此新的Ingress资源提供了一种替换注释的方案。</p><p>在Ingress规范中添加了一个新的ingressClassName字段，该字段用于决定应用于该Ingress的具体IngressClass。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  controller:</span> <span class="string">example.com/ingress-controller</span></span><br><span class="line"><span class="attr">  parameters:</span></span><br><span class="line"><span class="attr">    apiGroup:</span> <span class="string">k8s.example.com/v1alpha</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">IngressParameters</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">external-lb</span></span><br></pre></td></tr></table></figure><h3 id="弃用Ingress注释"><a href="#弃用Ingress注释" class="headerlink" title="弃用Ingress注释"></a>弃用Ingress注释</h3><p>在Kubernetes 1.18发布（即添加IngressClass资源）之前，通常会在Ingress上使用kubernetes.io/ingress.class注释来指定某类Ingress。尽管从未正式定义此注释，但Ingress控制器已广泛支持此注释，现在正式弃用该字段。</p><h3 id="设置默认的IngressClass"><a href="#设置默认的IngressClass" class="headerlink" title="设置默认的IngressClass"></a>设置默认的IngressClass</h3><p>可以在集群中将特定的IngressClass标记为默认值。在IngressClass资源上将注释<code>ingressclass.kubernetes.io/is-default-class</code>设置为true，就能够确保为未指定ingressClassName的新Ingress关联此默认IngressClass。</p><h2 id="支持主机名通配符"><a href="#支持主机名通配符" class="headerlink" title="支持主机名通配符"></a>支持主机名通配符</h2><p>许多Ingress提供程序都支持通配符主机名匹配，例如<code>* .foo.com</code>和<code>app1.foo.com</code>匹配，但是直到现在，规范都假定主机的FQDN完全匹配。当前，主机可以是精确匹配项（例如<code>foo.bar.com</code>）或通配符（例如<code>* .foo.com</code>）。精确匹配要求http主机头与主机设置匹配。通配符匹配要求http主机标头等于通配符规则的后缀。</p><table><thead><tr><th>Host</th><th>Host header</th><th>Match</th></tr></thead><tbody><tr><td>*.foo.com</td><td>*.foo.com</td><td>Matches based on shared suffix</td></tr><tr><td>*.foo.com</td><td>*.foo.com</td><td>No match, wildcard only covers a single DNS label</td></tr><tr><td>*.foo.com</td><td>foo.com</td><td>No match, wildcard only covers a single DNS label</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这些新的Ingress功能可实现更多可配置性。 下面是一个同时使用pathType，ingressClassName和主机名通配符的Ingress示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ingressClassName:</span> <span class="string">external-lb</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">*.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/example</span></span><br><span class="line"><span class="attr">        pathType:</span> <span class="string">Prefix</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">example-service</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Ingress-Controller支持"><a href="#Ingress-Controller支持" class="headerlink" title="Ingress Controller支持"></a>Ingress Controller支持</h3><p>由于这些功能是Kubernetes 1.18中的新增特性，因此每个Ingress控制器都需要一些时间来开发以完成对这些新功能的支持。首选查看Ingress控制器的相关文档，以了解它们何时将支持此新功能。</p><h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><p>在Kubernetes 1.19版本发布时，Ingress API有望从Beta变为GA。它将继续为用户管理Kubernetes工作负载的入网流量提供一种简单的方法。该API在保持简单和轻巧特性的同时希望为更复杂的用户场景提供更灵活的配置方案。</p><p>目前正在开发一套高度可配置的API，这些API在未来将成为Ingress的可选方案。这些API被称为新的“Service APIs”。当然其无意替代任何现有的API，而只是为复杂的用例提供了一种更灵活的配置方案。有关更多信息，请查看GitHub上的Service APIs。</p><p>原文链接：<a href="https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/" target="_blank" rel="noopener">Improvements to the Ingress API in Kubernetes 1.18</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes中的Ingress API对外提供简单而功能强劲的方法来管理与kubernetes集群内工作负载通信的入网流量。 在Kubernetes 1.18版本中，我们对Ingress API进行了以下3项重大改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增pathType字段，可以指定应该匹配哪种Ingress路径&lt;/li&gt;
&lt;li&gt;新增IngressClass资源，可以指定控制器应如何实现Ingress&lt;/li&gt;
&lt;li&gt;支持主机名的通配符&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>CNCF在中国 2020</title>
    <link href="https://ustack.io/2020-03-24-CNCF%E5%9C%A8%E4%B8%AD%E5%9B%BD%202019.html"/>
    <id>https://ustack.io/2020-03-24-CNCF在中国 2019.html</id>
    <published>2020-03-24T15:01:21.000Z</published>
    <updated>2020-03-25T10:11:35.094Z</updated>
    
    <content type="html"><![CDATA[  <div class="note info"><p>在开发Android项目的时候，使用的是<code>Gradle</code>构建工具，喜欢它的灵活和方便，在转向Java后端开发的时候更多时候使用的是<code>Maven</code>构建工具，然而看着漫天的尖括号，心里实在是难受。虽然只是一个构建工具，本着折腾的心，我还是更认可和看好<code>Gradle</code>。然而很多时候你的队友并没有习惯去使用或者快速熟悉<code>Gradle</code>构建工具，那么这个时候就需要将<code>Gradle</code>项目转换为Maven项目了，或者将Maven项目转换为<code>Gradle</code>项目了。</p></div><a id="more"></a><h3 id="安装Gradle／Maven"><a href="#安装Gradle／Maven" class="headerlink" title="安装Gradle／Maven"></a>安装Gradle／Maven</h3><p>首先是安装构建工具，这个没啥好说的。</p><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>打开Powershell或者Cmder执行以下命令完成安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco install gradle</span><br><span class="line">choco install maven</span><br></pre></td></tr></table></figure><p><code>choco</code>为windows下的一款包管理工具，可以方便安装管理配置一些常见的软件包，如果你没有安装<code>choco</code>的话，请移步：<a href="https://chocolatey.org/" target="_blank" rel="noopener">https://chocolatey.org/</a></p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>打开Terminal，执行以下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br><span class="line">brew install maven</span><br></pre></td></tr></table></figure><h3 id="Maven-to-Gradle"><a href="#Maven-to-Gradle" class="headerlink" title="Maven to Gradle"></a>Maven to Gradle</h3><p>需要特别说明的是，<code>Gradle</code>对<code>Maven</code>的支持是比较完善的，因此，转换也是非常的简单，在<code>pom.xml</code>文件所在的目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle init     # 根据pom.xml内容生成对应的gradle配置</span><br><span class="line">gradle build    # 开启gradle构建</span><br></pre></td></tr></table></figure><hr><h3 id="Gradle-to-Maven"><a href="#Gradle-to-Maven" class="headerlink" title="Gradle to Maven"></a>Gradle to Maven</h3><p><code>Gradle</code>项目转<code>Maven</code>项目需要借助一个Gradle插件，在项目的<code>module</code>的<code>build.gradle</code>文件中加入以下配置即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br></pre></td></tr></table></figure><p>通过双击<code>Idea</code>的Gradle Tasks GUI:</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5qcx3csoj20j20ee0ua.jpg" alt></p><p>或者执行命令来完成转换:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle install</span><br></pre></td></tr></table></figure><p>完成之后，将会在当前Module项目的<code>build</code>目录下的<code>poms</code>文件夹下生成<code>pom-default.xml</code>，将其拷贝到项目的根目录下即可。</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5pn78lbhj20ik0g4jsk.jpg" alt></p><ul><li>参考文档：<a href="https://guides.gradle.org/migrating-from-maven/" target="_blank" rel="noopener">https://guides.gradle.org/migrating-from-maven/</a></li></ul><hr><p>通过实际测试，这样的生成的<code>pom-default.xml</code>文件是不能用于直接<code>maven</code>构建的，因为生成的<code>pom-default.xml</code>文件中的<code>groupId</code>还需要我们手动指定下。这样显然是不清真的，于是我们可以在<code>build.gradle</code>文件中将其事先定义好，这样生成的pom文件就不用我们再手动更改了：</p><p><img src="https://ws1.sinaimg.cn/large/694830ebgy1fj5pvzyw2xj20ni0dign1.jpg" alt></p><p>然而这样我们还是觉得麻烦，毕竟需要手动复制到项目根目录，再重新命名。我们还可以通过Hook Gradle中Maven插件的<code>install</code>Task来完成自动的复制和命名,编辑<code>build.gradle</code>:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task convert2Maven &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        file(<span class="string">"$buildDir/poms/pom-default.xml"</span>).renameTo(file(<span class="string">"$rootDir/pom.xml"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">install.dependsOn(convert2Maven)</span><br></pre></td></tr></table></figure><p>此时，再执行<code>gradle install</code>这个task就可以看到gradle已经自动为我们在项目的根目录下生成好了<code>pom.xml</code>文件啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;在开发Android项目的时候，使用的是&lt;code&gt;Gradle&lt;/code&gt;构建工具，喜欢它的灵活和方便，在转向Java后端开发的时候更多时候使用的是&lt;code&gt;Maven&lt;/code&gt;构建工具，然而看着漫天的尖括号，心里实在是难受。虽然只是一个构建工具，本着折腾的心，我还是更认可和看好&lt;code&gt;Gradle&lt;/code&gt;。然而很多时候你的队友并没有习惯去使用或者快速熟悉&lt;code&gt;Gradle&lt;/code&gt;构建工具，那么这个时候就需要将&lt;code&gt;Gradle&lt;/code&gt;项目转换为Maven项目了，或者将Maven项目转换为&lt;code&gt;Gradle&lt;/code&gt;项目了。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="CloudNative" scheme="https://ustack.io/tags/CloudNative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之接口</title>
    <link href="https://ustack.io/2019-12-02-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://ustack.io/2019-12-02-Golang漫谈之接口.html</id>
    <published>2019-12-02T12:40:08.000Z</published>
    <updated>2019-12-01T13:14:29.137Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。</p><p><a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">Golang 1.13.1</a>已在9月26日正式发布，主要修复<code>CVE-2019-16276</code>,当然docker等相关组件也同时做了update</p></div><p>什么是interface，简单的说，interface是一组method的组合，下面这篇文章主要给大家深度解析了关于golang中的interface接口，该文章主要介绍，以下内容:</p><ul><li>接口介绍及范例</li><li>接口详情</li><li>接口与反射</li><li>接口源码</li></ul><a id="more"></a><hr><h4 id="一、接口介绍及范例"><a href="#一、接口介绍及范例" class="headerlink" title="一、接口介绍及范例"></a>一、接口介绍及范例</h4><p>如果说gorountine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道亮丽的风景，那么接口是Go语言整个类型系列的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度。Go语言在编程哲学上是变革派，而不是改良派。这不是因为Go语言有gorountine和channel，而更重要的是因为Go语言的类型系统，更是因为Go语言的接口。Go语言的编程哲学因为有接口而趋于完美。C++,Java 使用”侵入式”接口，主要表现在实现类需要明确声明自己实现了某个接口。这种强制性的接口继承方式是面向对象编程思想发展过程中一个遭受相当多质疑的特性。Go语言采用的是“非侵入式接口”,Go语言的接口有其独到之处：只要类型T的公开方法完全满足接口I的要求，就可以把类型T的对象用在需要接口I的地方，所谓类型T的公开方法完全满足接口I的要求，也即是类型T实现了接口I所规定的一组成员。这种做法的学名叫做Structural Typing，有人也把它看作是一种静态的Duck Typing。</p><p>在 Golang 中，interface 是一组 method 的集合，是 duck-type programming 的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。下面是一种 interface 的典型用法，定义函数的时候参数定义成 interface，调用函数的时候就可以做到非常的灵活。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line"> Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err os.Error)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Writer 是包裹了基础 Write 方法的接口。</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123; </span><br><span class="line"> Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err os.Error)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure><p>有一个事情是一定要明确的，不论 r 保存了什么值，r 的类型总是 io.Reader ,Go 是静态类型，而 r 的静态类型是 io.Reader。接口类型的一个极端重要的例子是空接口interface{},它表示空的方法集合，由于任何值都有零个或者多个方法，所以任何值都可以满足它。也有人说 Go 的接口是动态类型的，不过这是一种误解。 它们是静态类型的：接口类型的变量总是有着相同的静态类型，这个值总是满足空接口，只是存储在接口变量中的值运行时可能被改变。对于所有这些都必须严谨的对待，因为反射和接口密切相关。</p><h5 id="1-1、范型"><a href="#1-1、范型" class="headerlink" title="1.1、范型"></a>1.1、范型</h5><p>严格来说，在 Golang 中并不支持泛型编程。在 C++ 等高级语言中使用泛型编程非常的简单，所以泛型编程一直是 Golang 诟病最多的地方。但是使用 interface 我们可以实现泛型编程，我这里简单说一下，具体可以参考我前面给出来的那篇文章。比如我们现在要写一个泛型算法，形参定义采用 interface 就可以了，以标准库的 sort 为例。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.</span></span><br><span class="line">    n := data.Len()</span><br><span class="line">    maxDepth := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := n; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">        maxDepth++</span><br><span class="line">    &#125;</span><br><span class="line">    maxDepth *= <span class="number">2</span></span><br><span class="line">    quickSort(data, <span class="number">0</span>, n, maxDepth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sort 函数的形参是一个 interface，包含了三个方法：Len()，Less(i,j int)，Swap(i, j int)。使用的时候不管数组的元素类型是什么类型（int, float, string…），只要我们实现了这三个方法就可以使用 Sort 函数，这样就实现了“泛型编程”。有一点比较麻烦的是，我们需要将数组自定义一下。下面是一个例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByAge implements sort.Interface for []Person based on</span></span><br><span class="line"><span class="comment">// the Age field.</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person <span class="comment">//自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []Person&#123;</span><br><span class="line">        &#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(people)</span><br><span class="line">    sort.Sort(ByAge(people))</span><br><span class="line">    fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们设计函数的时候，下面是一个比较好的准则。</p><blockquote><p>Return concrete types, receive interfaces as parameter. — Robustness Principle applied to Go</p></blockquote><p>话说这么说，但是当我们翻阅 Golang 源码的时候，有些函数的返回值也是 interface。</p><h5 id="1-2、隐藏"><a href="#1-2、隐藏" class="headerlink" title="1.2、隐藏"></a>1.2、隐藏</h5><p>隐藏具体实现，这个很好理解。比如我设计一个函数给你返回一个 interface，那么你只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。Francesc 举了个 context 的例子。 context 最先由 google 提供，现在已经纳入了标准库，而且在原有 context 的基础上增加了：cancelCtx，timerCtx，valueCtx。语言的表达有时候略显苍白无力，看一下 context 包的代码吧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明上 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;</span><br><span class="line">        Context: parent,</span><br><span class="line">        done:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context     <span class="comment">//注意一下这个地方</span></span><br><span class="line"></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithCancel"</span>, c.Context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span>    //返回 <span class="title">cancelCtx</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span> //返回 <span class="title">timerCtx</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span>    //返回 <span class="title">valueCtx</span></span></span><br></pre></td></tr></table></figure><h5 id="1-3、hook"><a href="#1-3、hook" class="headerlink" title="1.3、hook"></a>1.3、hook</h5><p>通过 interface，我们可以通过类似这种方式实现 dynamic dispatch或者方便测试。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> header <span class="keyword">struct</span> &#123;</span><br><span class="line">    rt  http.RoundTripper</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h header)</span> <span class="title">RoundTrip</span><span class="params">(r *http.Request)</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> h.v &#123;</span><br><span class="line">        r.Header.Set(k,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.rt.RoundTrip(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="二、接口详情"><a href="#二、接口详情" class="headerlink" title="二、接口详情"></a>二、接口详情</h4><p>在类型中有一个重要的类别就是接口类型，表达了固定的一个方法集合。一个接口变量可以存储任意实际值（非接口），只要这个值实现了接口的方法。interface在内存上实际由两个成员组成，如下图，tab指向虚表，data则指向实际引用的数据。虚表描绘了实际的类型信息及该接口所需要的方法集。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line"> String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> b Binary = <span class="number">32</span></span><br><span class="line"> s := Stringer(b)</span><br><span class="line"> fmt.Print(s.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/01/QmkOoj.md.png" alt="接口"></p><p>观察itable的结构，首先是描述type信息的一些元数据，然后是满足Stringger接口的函数指针列表（注意，这里不是实际类型Binary的函数指针集哦）。因此我们如果通过接口进行函数调用，实际的操作其实就是s.tab-&gt;fun<a href="s.data">0</a> 。我们来看golang的实现方式，同C++一样，golang也为每种类型创建了一个方法集，不同的是接口的虚表是在运行时专门生成的.例如，当例子中当首次遇见s := Stringer(b)这样的语句时，golang会生成Stringer接口对应于Binary类型的虚表，并将其缓存。</p><p>首先我们很清楚go是没有严格意义上的继承的，go的接口不存在继承关系，只要实现了接口定义的方法都可以成为接口类型，这给go的虚表初始化带来很大的麻烦，到底有多少类型实现了这个接口，一个类型到底实现了多少接口这让编译器很confused。举个例子，某个类型有m个方法，某接口有n个方法，则很容易知道这种判定的时间复杂度为O(mXn)，不过可以使用预先排序的方式进行优化，实际的时间复杂度为O(m+n)这样看来其实还行那为什么要在运行时生成虚表呢，这不是会拖慢程序的运行速度吗，注意我们这里是某个类型，某个接口，是1对1的关系，如果有n个类型，n个接口呢，编译器难道要把之间所有的关系都理清吗？退一步说就算编译器任劳任怨把这事干了，可是你在写过程中你本来就不想实现那个接口，而你无意中给这个类型实现的方法中包含了某些接口的方法，你根本不需要这个接口(况且go的接口机制会导致很多这种无意义的接口实现)，你欺负编译器就行了，这也太欺负人了吧。如果我们放到运行时呢，我们只要在需要接口的去分析一下类型是否实现了接口的所有方法就行了很简单的一件事。</p><h5 id="2-1、空接口"><a href="#2-1、空接口" class="headerlink" title="2.1、空接口"></a>2.1、空接口</h5><p>接口类型的一个极端重要的例子是空接口：interface{} ,它表示空的方法集合，由于任何值都有零个或者多个方法，所以任何值都可以满足它。 注意，[]T不能直接赋值给[]interface{}</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t := []int&#123;1, 2, 3, 4&#125; wrong</span></span><br><span class="line"><span class="comment">//var s []interface&#123;&#125; = t</span></span><br><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">//right</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(t))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> t &#123;</span><br><span class="line"> s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"> fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，我们可以使用type switch语句查询接口变量的真实数据类型，语法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">  <span class="keyword">return</span> str <span class="comment">//type of str is string</span></span><br><span class="line"><span class="keyword">case</span> Stringer: <span class="comment">//type of str is Stringer</span></span><br><span class="line">  <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用“comma, ok”的习惯用法来安全地测试值是否为一个字符串：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、接口赋值"><a href="#2-2、接口赋值" class="headerlink" title="2.2、接口赋值"></a>2.2、接口赋值</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> LesssAdder <span class="keyword">interface</span> &#123;</span><br><span class="line">  Less(b Integer) <span class="keyword">bool</span></span><br><span class="line">  Add(b Integer)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span> <span class="title">Less</span><span class="params">(b Integer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span></span> &#123;</span><br><span class="line">  *a += b</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> b LesssAdder = &amp;a</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//var c LesssAdder = a</span></span><br><span class="line">  <span class="comment">//Error:Integer does not implement LesssAdder  </span></span><br><span class="line">  <span class="comment">//(Add method has pointer receiver)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go语言可以根据下面的函数:<br><code>func (a Integer) Less(b Integer) bool</code></p><p>自动生成一个新的Less()方法:<br><code>func (a *Integer) Less(b Integer) bool</code></p><p>这样，类型<em>Integer就既存在Less()方法，也存在Add()方法，满足LessAdder接口。 而根据<br>`func (a </em>Integer) Add(b Integer)`</p><p>这个函数无法生成以下成员方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span></span> &#123;</span><br><span class="line">  （&amp;a).Add(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为(&amp;a).Add()改变的只是函数参数a,对外部实际要操作的对象并无影响(值传递)，这不符合用户的预期。所以Go语言不会自动为其生成该函数。因此类型Integer只存在Less()方法，缺少Add()方法，不满足LessAddr接口。（可以这样去理解：指针类型的对象函数是可读可写的，非指针类型的对象函数是只读的）将一个接口赋值给另外一个接口 在Go语言中，只要两个接口拥有相同的方法列表(次序不同不要紧),那么它们就等同的，可以相互赋值。 如果A接口的方法列表时接口B的方法列表的子集，那么接口B可以赋值给接口A，但是反过来是不行的，无法通过编译。</p><h5 id="2-3、接口查询"><a href="#2-3、接口查询" class="headerlink" title="2.3、接口查询"></a>2.3、接口查询</h5><p>接口查询是否成功，要在运行期才能够确定。他不像接口的赋值，编译器只需要通过静态类型检查即可判断赋值是否可行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file1 Writer = ...</span><br><span class="line"><span class="keyword">if</span> file5,ok := file1.(two.IStream);ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句检查file1接口指向的对象实例是否实现了two.IStream接口，如果实现了，则执行特定的代码。<br>在Go语言中，你可以询问它指向的对象是否是某个类型，比如，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file1 Writer = ...</span><br><span class="line"><span class="keyword">if</span> file6,ok := file1.(*File);ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句判断file1接口指向的对象实例是否是*File类型，如果是则执行特定的代码。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> I <span class="keyword">interface</span>&#123;&#125; = slice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res, ok := I.([]<span class="keyword">int</span>)；ok &#123;</span><br><span class="line">  fmt.Println(res) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句判断接口I所指向的对象是否是[]int类型，如果是的话输出切片中的元素。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(array <span class="keyword">interface</span>&#123;&#125;, traveser Traveser)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> array == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"nil pointer"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> length <span class="keyword">int</span> <span class="comment">//数组的长度</span></span><br><span class="line">  <span class="keyword">switch</span> array.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">int</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">int</span>))</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">string</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">string</span>))</span><br><span class="line">  <span class="keyword">case</span> []<span class="keyword">float32</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(array.([]<span class="keyword">float32</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"error type"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"len is zero."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  traveser(array)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用.(type)方法可以利用switch来判断接口存储的类型。</p><hr><h4 id="三、接口与反射"><a href="#三、接口与反射" class="headerlink" title="三、接口与反射"></a>三、接口与反射</h4><hr><h4 id="四、接口源码"><a href="#四、接口源码" class="headerlink" title="四、接口源码"></a>四、接口源码</h4><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/27652856" target="_blank" rel="noopener">understanding-go-interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 1.13.1&lt;/a&gt;已在9月26日正式发布，主要修复&lt;code&gt;CVE-2019-16276&lt;/code&gt;,当然docker等相关组件也同时做了update&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;什么是interface，简单的说，interface是一组method的组合，下面这篇文章主要给大家深度解析了关于golang中的interface接口，该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口介绍及范例&lt;/li&gt;
&lt;li&gt;接口详情&lt;/li&gt;
&lt;li&gt;接口与反射&lt;/li&gt;
&lt;li&gt;接口源码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Linux线程通信之eventfd</title>
    <link href="https://ustack.io/2019-12-02-Linux%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8Beventfd.html"/>
    <id>https://ustack.io/2019-12-02-Linux 线程通信之eventfd.html</id>
    <published>2019-12-02T12:40:08.000Z</published>
    <updated>2019-12-01T13:41:22.140Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及到eventfd相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>先介绍eventfd：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eventfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> initval, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>使用这个函数来创建一个事件对象，linux线程间通信为了提高效率，大多使用异步通信，采用事件监听和回调函数的方式来实现高效的任务处理方式（虽然会将逻辑变得复杂）。<br>linux内核会为这个事件对象维护一个64位的计数器(uint64_t).并在初始化时用传进去的initval来初始化这个计数器，然后返回一个文件描述符来代表这个事件对象。</p><p>第二个参数是描述这个事件对象的属性，可以设置为EFD_NONBLOCK , EFD_CLOEXEC；前面的是设置对象为非阻塞状态，如果没有设置为非阻塞状态，read系统调用来读这个计数器，且计数器的值为0时，就会一直阻塞在read系统调用上，反之如果设置了该标志位，就会返回EAGAIN错误。后面的EFD_CLOEXEC功能是在程序调用exec()函数族加载其他程序时自动关闭当前已有的文件描述符（具体为什么暂不解释）。</p><p>通过此函数得到的对象既然是一个计数器，我们就可以对它进行读和写：<br>使用write将缓冲区写入的8字节整形值加到内核计数器上。<br>使用read将内核计数的8字节值读取到缓冲区中，并把计数器重设为0，如果buffer的长度小于8字节则read会失败，错误码设为EINVAl。</p><p>再介绍epoll，忍不住的可以直接向下翻<br>epoll是对select,poll这种IO多路转接方式的改进<br>接口:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> intsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>工作模式：</p><ul><li>水平触发：缺省的工作方式，并且同时支持block和no-blocksocket，在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表</li><li>边缘触发：高速工作方式，只支持no-blocksocket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了</li></ul><blockquote><p>用途：使用epoll_wait对某个文件描述符进行事件监听，监听到事件后会返回相关的结构体，得到其中有事件到来的fd，使用对应的回调函数(手动实现fd到回调函数的映射)来处理该fd上的事件：读数据或者写数据之类的。</p></blockquote><p>下面进入使用场景：</p><p>原始做法：(会有bug，下面分析)<br>初始化：先生成一个eventfd，初始化计数器为0，此eventfd可以通过一些方法在下面两个线程间共享<br>线程A：处理一些来自外部的请求，每处理完一个请求后会向eventfd的计数器中写入处理的结果，是一个整型值，然后接着处理下一个请求。<br>线程B：对eventfd进行Epoll监听，回调函数的功能是对eventfd的计数器读数据出来并将结果进行分发。</p><p>用例1：外部单个客户端每隔1秒向线程A发送一个请求。</p><p>用例1结果：线程A正确处理请求，并将结果写入eventfd中，线程B及时从eventfd中读取出请求处理结果，并正确分发给其他线程。</p><p>用例2：外部单个客户端连续向线程A发送多个请求。</p><p>用例2结果：线程A正确处理请求，并正确地将结果写入eventfd中，但在一定概率的情况下，线程B从eventfd中读到的结果不是线程A一次写入的结果，而是多次写入的结果。因此不能正确的分发请求。线程B中epoll捕捉到的事件次数小于线程A写入产生的事件数量。</p><p>用例3：外部多个客户端同时向线程A发送一个请求</p><p>用例3结果：线程A正确处理请求，并正确的将结果写入eventfd中，在很大的概率情况下，线程B中eventfd中读到的结果不是线程A一次写入的结果，而是多次写入的结果。因此，也不能正确的分发请求。线程B中epoll捕捉到的事件次数小于线程A写入产生的事件数量。</p><p>BUG分析：在这个场景中，线程A和线程B分别相当于生产者和消费者，只从原始生产者消费者模型上看并没有问题，满足数据为空时读不到数据，数据满时写不进数据(read,write的功能)，但是在当前场景中，加了一个特别的要求：每次写入的数据应该可以被独立识别而不是累加，每次写入的事件也应该被epoll独立的捕捉到。因此，需要对事件和数据各自进行序列化上的拆分。</p><p>改进做法：<br>初始化：先生成一个eventfd，初始化计数器为1，再生成一个空队列Q和互斥锁，此eventfd，队列Q和互斥锁可以通过一些方法在下面两个线程间共享，</p><p>线程A：处理一些来自外部的请求，每处理完一个请求后会从eventfd的计数器read数据，加1之后再write，将处理结果写入到队列末尾，然后接着处理下一个请求。</p><p>线程B：对eventfd进行Epoll监听，回调函数的功能是对eventfd的计数器read数据出来然后判断，如果大于1就自减1然后从队列头部取出数据，并将结果进行分发<br>，最后再写入新的计数器数据。如果等于1那么就直接返回，代表没有新的数据到来。</p><p>用例1,2,3在此环境下均可正常跑通。</p><p>回过头来分析原始做法的fatal error在哪：</p><p>作为生产者的线程A没有向线程B解释自己向eventfd中写入了多少个数据，产生了多少次事件。</p><p>作为消费者的线程B一次read就把eventfd中所有的数据当做一个数据读了出来，却没有相关依据来对读出来的数据做拆分。</p><p>作为通信工具的eventfd只能将数据进行累加，起到计数器的作用而不能存储实际数据。</p><p>作为消息监听的epoll在水平触发模式下只能通知是否有事件而不能通知有多少事件，在边缘触发下不能保留每次事件的产生都能及时被消费者捕获到。</p><p>因此，改进做法是将事件的多少通过计数器来表达，将实际传输的数据通过FIFO队列来传达。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及到eventfd相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="linux" scheme="https://ustack.io/tags/linux/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes调度系统初探</title>
    <link href="https://ustack.io/2019-11-26-Kubernetes%20%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2.html"/>
    <id>https://ustack.io/2019-11-26-Kubernetes 调度系统初探.html</id>
    <published>2019-11-26T04:40:08.000Z</published>
    <updated>2019-11-26T02:10:41.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg" alt></p><div class="note default"><p>Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。</p><p>本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：</p><ul><li>Kubernetes version: <code>v1.10</code></li><li>System: <code>CentOS Linux 7</code></li><li>Kernel: <code>Linux 3.10.0</code></li></ul></div><p>Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。</p><a id="more"></a><hr><blockquote><p>在后续安装部署中，将不使用kube-apiserver的HTTP非安全端口，所有组件都启用TLS双向认证通信。因此TLS证书配置是在安装配置Kubernetes系统中最容易出错和难于排查问题的一步，所以请务必耐心仔细。</p></blockquote><p>在开始前，为了模拟集群节点，我们假定需要在以下三台Linux主机上部署Kubernetes:</p><ul><li><code>10.138.148.161</code>：作为<code>master</code>节点</li><li><code>10.138.196.180</code>：作为<code>Node</code>节点</li><li><code>10.138.212.68</code>：作为<code>Node</code>节点</li></ul><div class="note danger"><p>同一台主机上可以同时部署master和Node节点相关组件，即同时作为控制节点和工作节点，不过这么做可能导致master节点负载过高而失去响应进而导致整个集群出现无法预知的问题。</p></div><hr><h3 id="安装CFSSL证书生成工具"><a href="#安装CFSSL证书生成工具" class="headerlink" title="安装CFSSL证书生成工具"></a>安装<code>CFSSL</code>证书生成工具</h3><div class="note info"><p>我们将使用<code>Cloudflare</code>的PKI工具集<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">cloudflare/cfssl</a>来生成集群所需要的各种<code>TLS</code>证书。</p></div><p>执行以下命令直接下载二进制文件进行安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O cfssl </span><br><span class="line">chmod +x cfssl </span><br><span class="line">sudo mv cfssl /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O cfssljson </span><br><span class="line">chmod +x cfssljson </span><br><span class="line">sudo mv cfssljson /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O cfssl-certinfo </span><br><span class="line">chmod +x cfssl-certinfo </span><br><span class="line">sudo mv cfssl-certinfo /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h3 id="创建CA根证书（Certificate-Authority）"><a href="#创建CA根证书（Certificate-Authority）" class="headerlink" title="创建CA根证书（Certificate Authority）"></a>创建CA根证书（Certificate Authority）</h3><p>CA（Certificate Authority）是自签名的根证书，用来签名后续创建的其它 TLS 证书；<br>确认<code>CFSSL</code>工具安装成功之后，我们先通过<code>CFSSL</code>工具来创建模版配置json文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfssl <span class="built_in">print</span>-defaults config &gt; config.json</span><br><span class="line">cfssl <span class="built_in">print</span>-defaults csr &gt; csr.json</span><br></pre></td></tr></table></figure><h4 id="创建CA配置文件"><a href="#创建CA配置文件" class="headerlink" title="创建CA配置文件"></a>创建CA配置文件</h4><p>这将生成两个模版json文件，后续<code>CFSSL</code>将读取json文件内容并生成对应的<code>pem</code>文件。我们先复制<code>config.json</code>为<code>ca-config.json</code>文件并做如下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"signing"</span>: &#123;</span><br><span class="line">        <span class="attr">"default"</span>: &#123;</span><br><span class="line">            <span class="attr">"expiry"</span>: <span class="string">"99999h"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">            <span class="attr">"kubernetes"</span>: &#123;</span><br><span class="line">                <span class="attr">"expiry"</span>: <span class="string">"99999h"</span>,</span><br><span class="line">                <span class="attr">"usages"</span>: [</span><br><span class="line">                    <span class="string">"signing"</span>,</span><br><span class="line">                    <span class="string">"key encipherment"</span>,</span><br><span class="line">                    <span class="string">"server auth"</span>,</span><br><span class="line">                    <span class="string">"client auth"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>profiles</code>：可以定义多个profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个特定的profile。</p><p><code>signing</code>：表示该证书可用于签名(签发)其它证书，生成的 ca.pem 证书中 CA=TRUE。</p><p><code>server auth</code>：表示`client可以用该 CA（生成的ca.pem） 对server提供的证书进行验证。</p><p><code>client auth</code>：表示server可以用该CA(生成的ca.pem）对client提供的证书进行验证。</p></div><h4 id="创建CA证书签名请求"><a href="#创建CA证书签名请求" class="headerlink" title="创建CA证书签名请求"></a>创建CA证书签名请求</h4><p>我们复制<code>csr.json</code>为<code>ca-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code>(<code>Common Name</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户名；</p><p><code>O</code>(<code>Organtzation</code>):后续<code>kube-apiserver</code>组件将从证书中提取该字段作为请求的用户所属的用户组；</p></div><h4 id="生成CA证书和私钥"><a href="#生成CA证书和私钥" class="headerlink" title="生成CA证书和私钥"></a>生成CA证书和私钥</h4><p>执行以下命令来生成CA证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls ca*</span><br><span class="line">ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>这样，我们就生成了CA证书和私钥了，因为我们需要双向<code>TLS</code>认证，所以需要拷贝<code>ca-key.pem</code>和<code>ca.pem</code>到所有要部署的机器的<code>/etc/kubernetes/ssl</code>目录下备用。</p><h3 id="创建kubernetes组件认证授权证书"><a href="#创建kubernetes组件认证授权证书" class="headerlink" title="创建kubernetes组件认证授权证书"></a>创建kubernetes组件认证授权证书</h3><p>因为我们准备部署的kubernetes组件是使用<code>TLS</code>双向认证的，包括<code>kube-apiserver</code>不打算使用HTTP端口，因此，我们需要生成以下的证书以供后续组件部署的时候备用：</p><div class="note info"><ul><li><code>etcd</code>证书：etcd集群之间通信加密使用的<code>TLS</code>证书。</li><li><code>kube-apiserver</code>证书：配置<code>kube-apiserver</code>组件的证书。</li><li><code>kube-controller-manager</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kube-scheduler</code>证书：用于和<code>kube-apiserver</code>通信认证的证书。</li><li><code>kubelet</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li><li><code>kube-proxy</code>证书【可选,非必需】：用于和<code>kube-apiserver</code>通信认证的证书，如果使用<code>TLS Bootstarp</code>认证方式，将没有必要配置。</li></ul></div><p>下面我们将逐个创建对应的<code>TLS</code>证书，并做相应的简短说明：</p><h4 id="创建etcd证书："><a href="#创建etcd证书：" class="headerlink" title="创建etcd证书："></a>创建<code>etcd</code>证书：</h4><p>首选我们创建<code>etcd</code>证书签名请求(CSR)，拷贝<code>csr.json</code>为<code>etcd-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"etcd"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">        <span class="string">"master"</span>,</span><br><span class="line">        <span class="string">"node1"</span>,</span><br><span class="line">        <span class="string">"node2"</span></span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger"><p>此处需要指定<code>host</code>字段的值，该值为所有需要部署etcd节点的<code>ip 域名 或者 hostname</code>，etcd需要使用<code>Subject Alternative Name（SAN）</code>来校验集群以及防止滥用。如果你不清楚应该使用哪个ip，默认情况下使用<code>ip a</code>查看<code>eth0</code>即可。此处指定的<code>ip</code>与后续指定的<code>etcd的systemd</code>配置<code>initial-cluster</code>相关。</p><p>相关阅读: <a href="https://github.com/coreos/etcd/issues/2056" target="_blank" rel="noopener">Option to accept TLS client certificates even if they lack correct Subject Alternative Names</a></p></div><p>生成<code>etcd</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line">ls etcd*</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem etcd.pem</span><br></pre></td></tr></table></figure><p>将生成的<code>etch-key.pem</code>和<code>etcd.pem</code>拷贝到所有需要部署<code>etcd</code>集群的服务器<code>/etc/etcd/ssl</code>目录下备用。</p><h4 id="创建kube-apiserver证书"><a href="#创建kube-apiserver证书" class="headerlink" title="创建kube-apiserver证书"></a>创建<code>kube-apiserver</code>证书</h4><p>创建<code>kube-apiserver</code>证书签名请求配置文件，拷贝<code>csr.json</code>为<code>kubernetes-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"CN"</span>: <span class="string">"kubernetes"</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">      <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="string">"10.138.212.68"</span>,</span><br><span class="line">      <span class="string">"10.138.196.180"</span>,</span><br><span class="line">      <span class="string">"10.138.148.161"</span>,</span><br><span class="line">      <span class="string">"10.254.0.1"</span>,</span><br><span class="line">      <span class="string">"kubernetes"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster"</span>,</span><br><span class="line">      <span class="string">"kubernetes.default.svc.cluster.local"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"key"</span>: &#123;</span><br><span class="line">        <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"names"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">            <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">            <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">            <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>此处指定了<code>host</code>字段来表示授权使用该证书的<code>ip或域名</code>列表，因此上述配置文件指定了要部署的kubernetes三台服务器ip（实际上只需要指定打算部署master节点的ip即可）以及<code>kube-apiserver</code>注册的名为<code>kubernetes</code>服务的服务ip（一般默认为后续配置<code>kube-apiserve</code>组件的时候指定的<code>—service-cluster-ip-range</code>网段的第一个ip。）如果你不清楚怎么操作，可以留空<code>host</code>字段。</p><p>如果你指定了<code>host</code>字段，这里如果有 <code>VIP</code> 的，也是需要填写的。</p></div><p>生成<code>kube-apiserver</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare apiserver</span><br><span class="line">ls apiserver*</span><br><span class="line">apiserver.csr  apiserver-key.pem  apiserver.pem</span><br></pre></td></tr></table></figure><p>我们将该证书拷贝到需要部署到<code>master</code>节点上的<code>/etc/kubernetes/ssl</code>上备用。</p><div class="note info"><p>因为我们master节点的组件之间的通信使用<code>非HTTP</code>的安全端口，所以同样也需要<code>TLS</code>认证授权，因此我们也需要配置<code>kube-controller-manager</code>和<code>kube-scheduler</code>的证书来供这两个组件访问<code>kube-apiserver</code>.如果你的集群master节点组件使用HTTP非安全端口通信，那么可以不需要配置这两个证书。</p></div><h4 id="创建kube-controller-manager证书"><a href="#创建kube-controller-manager证书" class="headerlink" title="创建kube-controller-manager证书"></a>创建<code>kube-controller-manager</code>证书</h4><p>复制<code>car.json</code>为<code>kube-controller-manager-csr.json</code>并做以下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-controller-manager"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的配置中，<code>kube-apiserver</code>将提取<code>CN</code>作为客户端组件(kube-controller-manager)的用户名(system:kube-controller-manager)，<code>kube-apiserver</code>预定义的RBAC使用ClusterRoleBinding <code>system:kube-controller-manager</code>将<code>用户system:kube-controller-manager</code>与<code>ClusterRole system:kube-controller-manager</code>绑定。</p><p>生成<code>kube-controller-manager</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare controller-manager</span><br><span class="line">ls controller-manager*</span><br><span class="line">controller-manager.csr  controller-manager-key.pem  controller-manager.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-controller-manager</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><h4 id="创建kube-scheduler-证书"><a href="#创建kube-scheduler-证书" class="headerlink" title="创建kube-scheduler`证书"></a>创建kube-scheduler`证书</h4><p>与<code>kube-controller-manager</code>一样，<code>kube-scheduler</code>同样也需要<code>TLS</code>证书来访问<code>kube-apiserver</code>。此处不再赘述。直接上<code>kube-scheduler-csr.json</code>文件内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-scheduler"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code></code>kube-scheduler <code>将提取</code>CN作为客户端的用户名<code>,这里是</code>system:kube-scheduler<code>。 kube-apiserver 预定义的 RBAC 使用的 ClusterRoleBindings</code>system:kube-scheduler <code>将</code>用户system:kube-scheduler <code>与</code>ClusterRole system:kube-scheduler `绑定。</p><p>生成<code>kube-scheduler</code>证书以及私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare scheduler</span><br><span class="line">ls scheduler*</span><br><span class="line">scheduler.csr  scheduler-key.pem  scheduler.pem</span><br></pre></td></tr></table></figure><p>将证书拷贝到需要部署<code>kube-scheduler</code>的master节点<code>/etc/kubernetes/ssl</code>上备用。</p><p>至此，<code>master</code>节点上的证书生成就全部完成了，接下来是生成<code>worker</code>节点的证书，需要注意的是：生成<code>worker</code>证书是可选的，如果你使用<code>TLS Bootstarpping</code>那么你可以跳过以下步骤<code>worker</code>证书生成工作。直接转到部署的实际操作环节。关于<code>TLS</code>证书和<code>TLS Bootstarpping</code>认证方式的区别，后续考虑单独写一遍文章展开来讲。</p><hr><h4 id="创建kubelet证书"><a href="#创建kubelet证书" class="headerlink" title="创建kubelet证书"></a>创建<code>kubelet</code>证书</h4><p>拷贝<code>car.json</code>为<code>kubelet-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:node:node"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"system:nodes"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>O</code>为用户组，kubernetes RBAC定义了ClusterRoleBinding将Group system:nodes和CLusterRole system:node关联起来。</p><p>注意:在<code>kubernetes v1.8+</code>以上版本，将不会自动创建<code>binding</code>,因此我们后续需要手动创建绑定关系。</p></div><p>生成<code>kubelet</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubelet-csr.json | cfssljson -bare kubelet</span><br><span class="line">ls kubelet*</span><br><span class="line">kubelet.csr  kubelet-csr.json  kubelet-key.pem  kubelet.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和秘钥拷贝到所有需要部署的worker节点上的<code>/etc/kubernetes/ssl</code>下备用。</p><h4 id="创建kube-proxy证书"><a href="#创建kube-proxy证书" class="headerlink" title="创建kube-proxy证书"></a>创建<code>kube-proxy</code>证书</h4><p>拷贝<code>car.json</code>为<code>kube-proxy-csr.json</code>并做以下修改:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>: <span class="string">"system:kube-proxy"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [],</span><br><span class="line">  <span class="attr">"key"</span>: &#123;</span><br><span class="line">    <span class="attr">"algo"</span>: <span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>: <span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"L"</span>: <span class="string">"Shanghai"</span>,</span><br><span class="line">      <span class="attr">"O"</span>: <span class="string">"k8s"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>: <span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p><code>CN</code> 指定该证书的 User为 system:kube-proxy。Kubernetes RBAC定义了ClusterRoleBinding将<code>system:kube-proxy用户</code>与<code>system:node-proxier 角色</code>绑定。system:node-proxier具有kube-proxy组件访问ApiServer的相关权限。</p></div><p>生成<code>kube-proxy</code>证书和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">ls kube-proxy*</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure><p>将生成的证书和私钥拷贝到所有需要部署<code>worker</code>节点的<code>/etc/kubernetes/ssl</code>下备用。</p><p>在完成证书分发之后，这样我们的证书相关的生成工作就完成了。接下来开始配置各个组件。</p><p>参考资料：</p><ul><li><a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">Using RBAC Authorization</a></li><li><a href="https://wiki.shileizcc.com/display/KUB/Kubernetes+HA+Cluster+Build" target="_blank" rel="noopener">Kubernetes HA Cluster Build</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-centos.html" target="_blank" rel="noopener">在CentOS上部署kubernetes集群</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/67/Kubernetes_logo.svg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Kubernetes是Google开源的容器化集群管理系统，其提供的应用部署、扩展、服务发现等机制对于微服务化架构应用有着十分重要的作用。&lt;/p&gt;
&lt;p&gt;本系列文章基于以下版本来讲述如何使用二进制方式安装Kubernetes集群顺便讲述下踩坑的心路历程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes version: &lt;code&gt;v1.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System: &lt;code&gt;CentOS Linux 7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kernel: &lt;code&gt;Linux 3.10.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;Kubernetes系统的各个组件需要使用TLS证书对其通信加密以及授权认证，所以在部署之前我们需要先生成相关的TLS证书以便后续操作能够顺利进行。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes GO" scheme="https://ustack.io/categories/Kubernetes-GO/"/>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之cond</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bcond.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之cond.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:53:55.777Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Cond在client-go等库中广泛使用，该文对此做知识铺垫。<br>Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Cond在client-go等库中广泛使用，该文对此做知识铺垫。&lt;br&gt;Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之信号处理</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之信号处理.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:57:02.570Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;我们在生产环境下运行的系统要求优雅退出，即程序接收退出通知后，会有机会先执行一段清理代码，将收尾工作做完后再真正退出。我们采用系统Signal来 通知系统退出，即kill pragram-pid。我们在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。kill -9强制杀掉程序是不能被接受的，那样会导致某些处理过程被强制中断，留下无法恢复的现场，导致消息被破坏，影响下次系统启动运行。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang漫谈之heap</title>
    <link href="https://ustack.io/2019-11-22-Golang%E6%BC%AB%E8%B0%88%E4%B9%8Bheap.html"/>
    <id>https://ustack.io/2019-11-22-Golang漫谈之heap.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-11-23T03:36:51.986Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.</p><p>[</p></div><p>heap是Golang内置的标准库封装，该文章主要介绍，以下内容:</p><ul><li>heap介绍及范例</li><li>heap解析</li></ul><a id="more"></a><hr><h4 id="一、heap介绍及范例"><a href="#一、heap介绍及范例" class="headerlink" title="一、heap介绍及范例"></a>一、heap介绍及范例</h4><blockquote><p>堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p></blockquote><p>堆的常用方法：</p><ul><li><p>构建优先队列</p></li><li><p>支持堆排序</p></li><li><p>快速找出一个集合中的最小值（或者最大值）</p></li></ul><h5 id="1-1-堆属性"><a href="#1-1-堆属性" class="headerlink" title="1.1 堆属性"></a>1.1 堆属性</h5><p>堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。</p><p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHIrTS.png" alt="heap1"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。10比7和2都大。7比5和1都大。</p><p>根据这一属性，那么最大堆总是将其中的最大值存放在树的根节点。而对于最小堆，根节点中的元素总是树中的最小值。堆属性非常的有用，因为堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素。</p><blockquote><p>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p></blockquote><h5 id="1-2-堆和普通树的区别"><a href="#1-2-堆和普通树的区别" class="headerlink" title="1.2 堆和普通树的区别"></a>1.2 堆和普通树的区别</h5><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p><ul><li><p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p></li><li><p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。</p></li><li><p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p></li><li><p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p></li></ul><p><strong><em>来自数组的树</em></strong></p><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间山都是很高效的。我们准备将上面的例子中的树这样存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 7, 2, 5, 1 ]</span><br></pre></td></tr></table></figure><p>就这多！我们除了一个简单的数组以外，不需要任何额外的空间。</p><p>如果我们不允许使用指针，那么我们怎么知道哪一个节点是父节点，哪一个节点是它的子节点呢？问得好！节点在数组中的位置index 和它的父节点已经子节点的索引之间有一个映射关系。</p><p>如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent(i) = floor((i - 1)/2)</span><br><span class="line">left(i)   = 2i + 1</span><br><span class="line">right(i)  = 2i + 2</span><br></pre></td></tr></table></figure><p>注意 right(i) 就是简单的 left(i) + 1。左右节点总是处于相邻的位置。</p><p>我们将写公式放到前面的例子中验证一下。</p><table><thead><tr><th>Node</th><th>Array index (i)</th><th>Parent index</th><th>Left child</th><th>Right child</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>-1</td><td>1</td><td>2</td></tr><tr><td>7</td><td>1</td><td>0</td><td>3</td><td>4</td></tr><tr><td>2</td><td>2</td><td>0</td><td>5</td><td>6</td></tr><tr><td>5</td><td>3</td><td>1</td><td>7</td><td>8</td></tr><tr><td>1</td><td>4</td><td>1</td><td>9</td><td>10</td></tr></tbody></table><blockquote><p>根节点(10)没有父节点，因为 -1 不是一个有效的数组索引。同样，节点 (2)，(5)和(1) 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。</p></blockquote><p>在最大堆中，父节点的值总是要大于（或者等于）其子节点的值。这意味下面的公式对数组中任意一个索引i都成立：<code>array[parent(i)] &gt;= array[i]</code></p><p>可以用上面的例子来验证一下这个堆属性。</p><p>如你所见，这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要O(1)的时间。</p><p>理解数组索引和节点位置之间的关系非常重要。这里有一个更大的堆，它有15个节点被分成了4层:</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoCfH.png" alt="树"></p><p>图片中的数字不是节点的值，而是存储这个节点的数组索引！这里是数组索引和树的层级之间的关系：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoUNF.png" alt="数组"></p><p>由上图可以看到，数组中父节点总是在子节点的前面。注意这个方案与一些限制。你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHoh3d.png" alt="一般树"></p><p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHovgs.png" alt="heapshap"></p><blockquote><p>注意：你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</p></blockquote><p>假设我们有这样一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10, 14, 25, 33, 81, 82, 99 ]</span><br></pre></td></tr></table></figure><p>这是一个有效的堆吗？答案是 yes ！一个从低到高有序排列的数组是以有效的最小堆，我们可以将这个堆画出来：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTMVK.png" alt="sortedArray"></p><p>堆属性适用于每一个节点，因为父节点总是比它的字节点小。（你也可以验证一下：一个从高到低有序排列的数组是一个有效的最大堆）</p><blockquote><p>注意：并不是每一个最小堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</p></blockquote><h5 id="1-3-堆的用途"><a href="#1-3-堆的用途" class="headerlink" title="1.3 堆的用途"></a>1.3 堆的用途</h5><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p><ul><li>shiftUp(): 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。</li><li>shiftDown(): 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。</li></ul><p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 O(log n)。</p><p>基于这两个原始操作还有一些其他的操作：</p><ul><li>insert(value): 在堆的尾部添加一个新的元素，然后使用 shiftUp 来修复对。</li><li>remove(): 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 shiftDown 方法来修复堆。</li><li>removeAtIndex(index): 和 remove() 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。当它与子节点比较位置不时无序时使用 shiftDown()，如果与父节点比较发现无序则使用 shiftUp()。</li><li><p>replace(index, value)：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 shiftUp() 来修复堆属性。<br>上面所有的操作的时间复杂度都是 O(log n)，因为 shiftUp 和 shiftDown 都很费时。还有少数一些操作需要更多的时间：</p></li><li><p>search(value):堆不是为快速搜索而建立的，但是 replace() 和 removeAtIndex() 操作需要找到节点在数组中的index，所以你需要先找到这个index。时间复杂度：O(n)。</p></li><li>buildHeap(array):通过反复调用 insert() 方法将一个（无序）数组转换成一个堆。如果你足够聪明，你可以在 O(n) 时间内完成。</li><li>堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度：O(n lg n)。</li></ul><p>堆还有一个 peek() 方法，不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。时间复杂度 O(1) 。</p><blockquote><p>注意：到目前为止，堆的常用操作还是使用 insert() 插入一个新的元素，和通过 remove()移除最大或者最小值。两者的时间复杂度都是O(log n)。其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p></blockquote><p><strong><em>插入</em></strong></p><p>我们通过一个插入例子来看看插入操作的细节。我们将数字16插入到这个堆中：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTgrq.png" alt="heap1"></p><p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。<br>第一股是将新的元素插入到数组的尾部。数组变成：<br><code>[ 10, 7, 2, 5, 1, 16 ]</code><br>相应的树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHTHMR.png" alt="Insert1"></p><p>16 被添加最后一行的第一个空位。<br>不行的是，现在堆属性不满足，因为2在16的上面，我们需要将大的数字在上面（这是一个最大堆）<br>为了恢复堆属性，我们需要交换16和2。</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7SRH.png" alt="Insert2"></p><p>现在还没有完成，因为 10 也比 16 小。我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 shift-up，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。<br>最后我们得到的堆：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH73wV.png" alt="Insert3"></p><p>现在每一个父节点都比它的子节点大。</p><p><strong><em>删除根节点</em></strong></p><p>我们将这个树中的 (10) 删除：</p><p><img src="https://s2.ax1x.com/2019/11/23/MH7Tk8.png" alt="Heap1"></p><p>现在顶部有一个空的节点，怎么处理？</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHsun.png" alt="Remove1"></p><p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p><p><img src="https://s2.ax1x.com/2019/11/23/MHHqUK.png" alt="Remove2"></p><p>现在来看怎么 shift-down (1)。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 7 和 2。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 7 和 1，现在树变成了：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbiUf.png" alt="Remove3"></p><p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbmKs.png" alt="Remove4"></p><p><strong><em>删除任一节点</em></strong></p><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。</p><p>但是，删除任意节点也很有用。这是 remove() 的通用版本，它可能会使用到 shiftDown 和 shiftUp。</p><p>我们还是用前面的例子，删除 (7):</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbG24.png" alt="Heap1"></p><p>对应的数组是:<code>[ 10, 7, 2, 5, 1 ]</code></p><p>你知道，移除一个元素会破坏最大堆或者最小堆属性。我们需要将删除的元素和最后一个元素交换：<br><code>[ 10, 1, 2, 5, 7 ]</code></p><p>最后一个元素就是我们需要返回的元素；然后调用 removeLast() 来将它删除。 (1) 比它的子节点小，所以需要 shiftDown() 来修复。</p><p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 (5) 会发生什么：</p><p><img src="https://s2.ax1x.com/2019/11/23/MHbyxH.png" alt="Remove5"></p><p>现在 (5) 和 (8) 交换了。因为 (8) 比它的父节点大，我们需要 shiftUp()。</p><hr><h4 id="二、heap解析"><a href="#二、heap解析" class="headerlink" title="二、heap解析"></a>二、heap解析</h4><h5 id="2-1-goroutine通信"><a href="#2-1-goroutine通信" class="headerlink" title="2.1 goroutine通信"></a>2.1 goroutine通信</h5><p>heap包对任意实现了heap接口的类型提供堆操作。（小根）堆是具有“每个节点都是以其为根的子树中最小值”属性的树。树的最小元素在根部，为index 0.<br>heap是常用的实现优先队列的方法。要创建一个优先队列，实现一个具有使用（负的）优先级作为比较的依据的Less方法的Heap接口，如此一来可用Push添加项目而用Pop取出队列最高优先级的项目。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个堆结构继承自sort.Interface, 而sort.Interface，需要实现三个方法：</p><ul><li>Len() int</li><li>Less(i, j int) bool  </li><li>Swap(i, j int)</li></ul><p>再加上堆接口定义的两个方法：</p><ul><li>Push(x interface{})</li><li>Pop() interface{}。</li></ul><p>故只要实现了这五个方法，变定义了一个堆。</p><p>任何实现了本接口的类型都可以用于构建最小堆。最小堆可以通过heap.Init建立，数据是递增顺序或者空的话也是最小堆。最小堆的约束条件是：</p><p><code>!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()</code></p><p>注意接口的Push和Pop方法是供heap包调用的，请使用heap.Push和heap.Pop来向一个堆添加或者删除元素。</p><ul><li>func Fix(h Interface, i int)  //  在修改第i个元素后，调用本函数修复堆，比删除第i个元素后插入新元素更有效率。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Init(h Interface)  //初始化一个堆。一个堆在使用任何堆操作之前应先初始化。Init函数对于堆的约束性是幂等的（多次执行无意义），并可能在任何时候堆的约束性被破坏时被调用。本函数复杂度为O(n)，其中n等于h.Len()。</li><li>func Pop(h Interface) interface{}  //删除并返回堆h中的最小元素（不影响约束性）。复杂度O(log(n))，其中n等于h.Len()。该函数等价于Remove(h, 0)。</li><li>func Push(h Interface, x interface{})  //向堆h中插入元素x，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li><li>func Remove(h Interface, i int) interface{}  //删除堆中的第i个元素，并保持堆的约束性。复杂度O(log(n))，其中n等于h.Len()。</li></ul><p>利用heap创建一个优先级队列:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line">  <span class="comment">// not just its contents.</span></span><br><span class="line">  *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *h</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  x := old[n<span class="number">-1</span>]</span><br><span class="line">  *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  heap.Init(h)</span><br><span class="line">  heap.Push(h, <span class="number">3</span>)</span><br><span class="line">  heap.Fix(h, <span class="number">3</span>)</span><br><span class="line">  fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用heap创建一个优先级队列</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates a priority queue built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"container/heap"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">  priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">  <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">  index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">  <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">  pq[i].index = i</span><br><span class="line">  pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  n := <span class="built_in">len</span>(*pq)</span><br><span class="line">  item := x.(*Item)</span><br><span class="line">  item.index = n</span><br><span class="line">  *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  old := *pq</span><br><span class="line">  n := <span class="built_in">len</span>(old)</span><br><span class="line">  item := old[n<span class="number">-1</span>]</span><br><span class="line">  item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">  *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  item.value = value</span><br><span class="line">  item.priority = priority</span><br><span class="line">  heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Some items and their priorities.</span></span><br><span class="line">  items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"banana"</span>: <span class="number">3</span>, <span class="string">"apple"</span>: <span class="number">2</span>, <span class="string">"pear"</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">  <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">  pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">    pq[i] = &amp;Item&#123;</span><br><span class="line">      value:    value,</span><br><span class="line">      priority: priority,</span><br><span class="line">      index:    i,</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">  item := &amp;Item&#123;</span><br><span class="line">    value:    <span class="string">"orange"</span>,</span><br><span class="line">    priority: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  heap.Push(&amp;pq, item)</span><br><span class="line">  pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">  <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">    item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">    fmt.Printf(<span class="string">"%.2d:%s \n"</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类,实现相关接口后,交由heap.Init()去构建堆.</p><ul><li>从堆中Pop()后,数据就被从heap中移除了.</li><li>升降序由Less()来决定.</li><li>自定义类也可以直接用Sort来排序,因为实现了相关接口.</li></ul><hr><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>heap在kubernetes scheduler相关内容涉及，将会在后续推出。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://golang.org/pkg/container/heap" target="_blank" rel="noopener">heap</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Go语言的OOP,接口,接口的组合,基础库的函数及接口如何抽象设计,这些东西在Go的Heap源码及演示例子处理中,都有很好的展示.&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;heap是Golang内置的标准库封装，该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heap介绍及范例&lt;/li&gt;
&lt;li&gt;heap解析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="golang漫谈" scheme="https://ustack.io/categories/golang%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>算法之Manacher</title>
    <link href="https://ustack.io/2019-11-22-%E7%AE%97%E6%B3%95%E4%B9%8BManacher.html"/>
    <id>https://ustack.io/2019-11-22-算法之Manacher.html</id>
    <published>2019-11-22T12:40:08.000Z</published>
    <updated>2019-12-09T13:13:29.709Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的<a href="github.com/qyuhen/book">Golang 源码剖析</a>。<br>Cond在client-go等库中广泛使用，该文对此做知识铺垫。<br>Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。</p><p>[</p></div><p>条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:</p><ul><li>cond机制</li></ul><a id="more"></a><hr><h4 id="Cond同步机制"><a href="#Cond同步机制" class="headerlink" title="Cond同步机制"></a>Cond同步机制</h4><blockquote><p>Cond模块定义：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line"></span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br></pre></td></tr></table></figure><p>Cond需要指定一个Locker，通常是一个<em>Mutex或</em>RWMutex。另外，Cond还定义了一下几个核心方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span> // <span class="title">Broadcast</span>解除所有<span class="title">wait</span> <span class="title">goroutine</span>的阻塞。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span> // <span class="title">Signal</span>解除一个<span class="title">goroutine</span>的阻塞，计数减一。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> // <span class="title">Wait</span>添加一个计数，也就是添加一个阻塞的<span class="title">goroutine</span>。</span></span><br></pre></td></tr></table></figure><p>那外部传入的Locker，是对wait，Signal，Broadcast进行保护。防止发送信号的时候，不会有新的goroutine进入wait。在wait逻辑完成前，不会有新的事件发生。</p><blockquote><p>注意：在调用Signal，Broadcast之前，应确保目标进入Wait阻塞状态。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">  locker := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">  cond := sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      wait.Add(<span class="number">1</span>)</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting start..."</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">"Waiting end..."</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">      fmt.Println(<span class="string">"Goroutine run. Number:"</span>, i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">  cond.L.Lock()</span><br><span class="line">  cond.Signal()</span><br><span class="line">  cond.L.Unlock()</span><br><span class="line">  wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting start...</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 0</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 1</span><br><span class="line">Waiting end...</span><br><span class="line">Goroutine run. Number: 2</span><br></pre></td></tr></table></figure><p>可以看出来，每执行一次Signal就会执行一个goroutine。如果想让所有的goroutine执行，那么将所有的Signal换成一个Broadcast方法可以。</p><h5 id="1-1-Broadcase、Signal"><a href="#1-1-Broadcase、Signal" class="headerlink" title="1.1 Broadcase、Signal"></a>1.1 Broadcase、Signal</h5><p>唤醒因wait condition而挂起goroutine，区别是Signal只唤醒一个，而Broadcast唤醒所有。允许调用者获取基础锁Locker之后再调用唤醒，但非必需。</p><h5 id="1-2-Wait"><a href="#1-2-Wait" class="headerlink" title="1.2 Wait"></a>1.2 Wait</h5><p>必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p><h5 id="1-3-实例"><a href="#1-3-实例" class="headerlink" title="1.3 实例"></a>1.3 实例</h5><p>生产者消费者问题是条件原语的一个典型例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> locker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> consumerNum = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> producerNum = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; producerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(out) == capacity &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Full, stop Produce"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                out &lt;- num</span><br><span class="line">                fmt.Printf(<span class="string">"Produce %d produce: num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                cond.Signal()</span><br><span class="line"></span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; consumerNum; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(nu <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                cond.L.Lock()</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line">                    fmt.Println(<span class="string">"Capacity Empty, stop Consume"</span>)</span><br><span class="line">                    cond.Wait()</span><br><span class="line">                &#125;</span><br><span class="line">                num := &lt;-in</span><br><span class="line">                fmt.Printf(<span class="string">"Goroutine %d: consume num %d\n"</span>, nu, num)</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">                cond.Signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    product := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, capacity)</span><br><span class="line"></span><br><span class="line">    producer(product)</span><br><span class="line">    consumer(product)</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="noopener">Manacher算法</a></li><li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;除了《Kubernetes GO》系列之外，对于golang相关知识，同时准备了《Golang 漫谈》以增雅趣，不足之处，万望海涵，在此特别感谢雨痕的&lt;a href=&quot;github.com/qyuhen/book&quot;&gt;Golang 源码剖析&lt;/a&gt;。&lt;br&gt;Cond在client-go等库中广泛使用，该文对此做知识铺垫。&lt;br&gt;Cond在Locker的基础上增加的一个消息通知的功能。但是它只能按照顺序去使一个goroutine解除阻塞。&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;条件变量是构建在一个基础锁上的同步原语，Golang Crondition位于sync包中，用于goroutine需要关注特定的条件的场景。该文章主要介绍，以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cond机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ustack.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="https://ustack.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>容器那些事</title>
    <link href="https://ustack.io/2019-11-21-container%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-21-container相关概念梳理.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T14:13:17.226Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续对于kubelet相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><h4 id="container与docker"><a href="#container与docker" class="headerlink" title="container与docker"></a>container与docker</h4><blockquote><p>container的概念早于docker，其源于LXC技术，当然在此需要感谢docker社区对于容器技术的贡献，因为docker的出现，container的概念深入人心，容器的特性类似sandbox，进程受到资源的限制，并且彼此间隔离，当然容器区别与虚拟机的技术，主要区别在于内核的是否共享，上述的论断可能不太精确，因此后期如gvisor技术，其通过隔离层实现系统调用。通俗来说容器技术主要指资源限制的cgroup、用于隔离的namespace以及共享内核。</p></blockquote><p>11月13日，Mirantis收购Docker的消息引爆开源届。</p><h4 id="OCI标准"><a href="#OCI标准" class="headerlink" title="OCI标准"></a>OCI标准</h4><p>Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。<br>所谓container runtime，主要负责的是容器的生命周期的管理。oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义。<br>其中<code>runc</code>，是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。</p><p>为了兼容oci标准，docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。</p><h4 id="container-engine"><a href="#container-engine" class="headerlink" title="container engine"></a>container engine</h4><p>容器引擎，或者说容器平台，不仅包含对于容器的生命周期的管理，还包括了对于容器生态的管理，比如对于镜像等。现在的docker、rkt以及阿里推出的pouch均可属于此范畴。<br>docker，随着docker的发展，docker就不再局限于容器的管理，还囊括了存储(volume)、网络(net)等的管理，因此后来的docker是一个容器的管理平台。而runtime逐渐插件化，如下图的runc与kata runtime。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTc92D.jpg" alt="docker runtime plugin"></p><hr><h3 id="Kubernetes相关"><a href="#Kubernetes相关" class="headerlink" title="Kubernetes相关"></a>Kubernetes相关</h3><p>kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。</p><p>在k8s 1.5版本之后，kubernetes推出了自己的运行时接口CRI(container runtime interface)。cri接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。</p><p>与oci不同，cri与kubernetes的概念更加贴合，并紧密绑定。cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为PodSandbox。在cri开始之初，主要是支持docker和rkt两种。其中kubelet是通过cri接口，调用dockershim，并进一步调用docker api实现的。</p><p>如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。</p><p>在之后的社区发展中，kubelet支持docker及remote两种类型，其中docker即内置的dockershim以满足CRI接口，remote方式同样需要满足CRI接口规范。</p><blockquote><p>下图为各runtime与kubelet的通信</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/22/MTc1qs.jpg" alt="kubelet CRI"></p><p>其中的CRI-O插件实现kubelet CRI接口，并能够兼容OCI标准，作为一种可替换docker的轻量级运行时方案，其允许kubelet允许任一符合OCI标准的runtime来运行Pod。<br>下图为CRI-O与OCI接口通信图示。</p><p><img src="https://s2.ax1x.com/2019/11/22/MTgdtP.jpg" alt="CRI-O通信"></p><p>CRI-O插件主要有以下功能：</p><ul><li>镜像服务</li><li>runtime服务</li><li>CNI</li><li>OCI 生成器</li></ul><p>最后，kubelet与CRI-O的交互流程如下：</p><ol><li>kubelet通过list接口获悉启动POD，其中POD是kubernetes的一个概念，由一个或多个共享IPC，NET和PID名称空间并位于同一cgroup中的容器组成。</li><li>kubelet将请求下发到kubernetes CRI-O服务，即kubelet启动时的remote配置（容器运行时接口），以启动新的POD。</li><li>CRI-O使用containers/image库从镜像仓库拉取镜像。</li><li>下载后的镜像解压存储到为容器创建rootfs，即存储在COW文件系统中。</li><li>在rootfs创建后，CRI-O会生成OCI运行时规范json文件，该文件描述了如何使用OCI Generate工具运行容器。</li><li>CRI-O使用该配置启动OCI兼容的运行时，以运行容器进程。默认的OCI运行时是runc。</li><li>每个容器都由单独的通用程序进行监控。 conmon进程保留了容器进程的PID1。它处理容器的日志记录并记录容器过程的退出代码。</li><li>通过CNI设置Pod的网络，因此任何CNI插件均可与CRI-O一起使用。</li></ol><p>下图为CRI的功能图。<br><img src="https://s2.ax1x.com/2019/11/22/MTWv90.md.png" alt="CRI-O功能"></p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将推出kubernetes runtimeclass文章</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://medium.com/kata-containers/why-kata-containers-doesnt-replace-kubernetes-75e484679727" target="_blank" rel="noopener">why-kata-containers-doesnt-replace-kubernetes</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">CRI-O</a></li><li><a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noopener">runtime-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;在使用k8s时，经常会遇到docker、oci、runc、containerd、oci-o、cri、kata等概念。本文对相关名词和其之间的联系进行一下梳理和总结，以此作为后续对于kubelet相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="linux" scheme="https://ustack.io/tags/linux/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes展望与思考</title>
    <link href="https://ustack.io/2019-11-21-Kubernetes%201.17%20%E5%B1%95%E6%9C%9B%E4%B8%8E%E6%80%9D%E8%80%83.html"/>
    <id>https://ustack.io/2019-11-21-Kubernetes 1.17 展望与思考.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T06:50:31.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt></p><div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a>当前changlog，</p></div><p>距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。</p><a id="more"></a><hr><h3 id="一、1-16版本回顾"><a href="#一、1-16版本回顾" class="headerlink" title="一、1.16版本回顾"></a>一、1.16版本回顾</h3><blockquote><p>9月18日，Kubernetes 1.16正式发布，其包含31项增强功能，其中8项增强功能已经GA，另有8项增强功能处于beta阶段，15项处于alpha阶段，该版本有以下亮点:</p></blockquote><ul><li><p>自定义资源(CRD)</p><p>  CRD作为Kubernetes的可扩展机制之一得到广泛使用，其自1.7版本发布以来就一直处于beta阶段。Kubernetes 1.16版本，也标志着CRD迎来了GA版本。</p></li><li><p>存储卷扩展</p><p>  新版本当中包含一系列与存储卷以及卷修改相关的功能。CSI规范中的存储卷大小调整能力提升为beta阶段，允许用户对CSI规范下的存储卷插件进行大小调整。</p></li><li><p>拓扑管理[alpha]</p><p>  Kubelet中旨在协调资源分配决策，从而提供优化效果更好的资源分配能力</p></li><li><p>双栈[alpha]</p><p>  IPv4/IPv6双栈可以将IPv4与IPv6地址分配给各Pod与服务<br>  a. Pod 的多个 IPv4/IPv6 地址分配<br>  b. 集群之间本地双栈通信</p></li></ul><p>下述表单为kubernetes维护时限</p><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、1-17-版本动态"><a href="#二、1-17-版本动态" class="headerlink" title="二、1.17 版本动态"></a>二、1.17 版本动态</h3><pre><code>社区1.17版本的代码freeze时间节点为11月18日，正式发布在12月9日左右，社区在调度、存储等方面进行大量优化，一些PR的进展如下：</code></pre><h4 id="一般更新"><a href="#一般更新" class="headerlink" title="一般更新"></a>一般更新</h4><ol><li>klog升级至v1.0.0</li><li><p>更新SIG图谱，详见community#4129</p><ul><li><p>将特定cloud provider修改为公有云SIG子项目</p></li><li><p>移除容器认证工作组</p></li><li><p>新增Usability SIG等</p></li></ul></li><li>推迟NodeRestriction admission插件研发时间至1.19</li><li>解决kubectl flag <code>--certificate-authority</code>重写问题</li><li>kubeadm不再移除/etc/cni/net.d目录</li><li>etcd server版本升级至3.3.17</li><li>kubeadm配置版本从v1beta1升级至v1beta2</li><li><p>golang性能优化</p><ul><li><p>encoding/json中的sync.Pool使用scanner</p></li><li><p>golang抢占调度，详见golang#24543，里程碑设定于Go 1.14版本</p></li><li><p>优化complie、link</p></li></ul></li><li><p>统一CRI于docker shim字节流长度，限定readiness/liveness字节流输出长度10kb</p></li><li>为相关组件新增readyz及livez接口</li><li>限制kubelet静态pod文件最大长度为10MB，防范Dos</li><li>增加PVC存储需求为负数的校验</li><li>移除firewalld监控，优化iptables处理</li><li><p>云服务商相关：</p><ul><li><p>openstack中doSafeMakeDir时可能带来的fd泄露</p></li><li><p>openstack LB删除故障处理，详见kubernetes#82264</p></li><li><p>azure控制器新增操作技术相关指标</p></li><li><p>升级azure sdk client至v33.1.0，优化API调用</p></li></ul></li><li><p>metrics-server版本升级至0.3.5</p></li><li>hyperkube镜像将不再与kubernetes一同发行</li></ol><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li><p>解决API-Server处理JSON/YAML时面临DoS安全风险（CVE-2019-11253），详情可参看issue#83253</p></li><li><p>net/textproto 头部字段兼容性处理导致CVE-2019-16276</p></li><li><p>非常规构建JSON安全风险问题，详见kubernetes#81158</p></li></ul><h4 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h4><ol><li><p>升级Go 1.13.3</p><ul><li><p>解决当http2握手时的写错误，transport永久缓存断链，详见go#34978</p></li><li><p>Go页分配器未优化导致apiserver延迟及内存趋高等问题，解决详见go#34978、go#35112，此问题的讨论过程详见go#32828</p></li><li><p>解决go mod在k8s模块的使用，更新heketi模块，详见kuberneets#82506</p></li></ul></li><li><p>升级etcd client 3.3.17：详见kubernetes#83801</p><ul><li><p>解决客户端无法正确解析IPv6</p></li><li><p>etcd集群故障时无法证书检查时dns不匹配</p></li></ul></li><li><p>apiserver故障</p><ul><li>当CRD资源定义中包含x-kubernetes-int-or-string字段，导致apiextensions panic：详见kubernetes#83787</li></ul></li><li><p>存储故障</p><ul><li>kubelet重启时清理raw bolck，详见kubernetes#83451</li></ul></li></ol><h4 id="特性维护"><a href="#特性维护" class="headerlink" title="特性维护"></a>特性维护</h4><ol><li><p>调度优化</p><ul><li><p>新增pre-filter插件以更新pod状态</p></li><li><p>将内置调度算法插件化：framwork等</p></li><li><p>TaintNodesByCondition特性1.17正式GA，移除节点状态相关predicate算法：内存、磁盘、PID、状态，以TaintNodesByCondition替换</p></li><li><p>新增调度队列操作pod的相关指标</p></li><li><p>新增调度相关延迟及请求相关指标</p></li><li><p>将调度插件中节点计算分范围从【0，10】调整为【0，100】，其不会影响第三方及RequestedToCapacityRatio算法</p></li></ul></li><li><p>优化EndpointSlice特性</p><ul><li>通过使用string对比替换IP，在kube-proxy启用EndpointSlice时，显著提升性能～50%，详见kubernetes#83035</li></ul></li><li><p>apiserver增强</p><ul><li>新增认证功能延迟的监控指标</li><li>移除apiserver loopback客户端QPS限制，其将影响apiserver性能，详见kuberneets#80465</li><li>提供开启/关闭 REST API及特性配置：–runtime-config=api/beta=false –feature-gates=AllBeta=false</li><li>解决kube-apiserver goroutine泄露，详见kubernetes#83333</li><li>WatchBookmark特性1.17正式GA</li></ul></li><li><p>dns优化</p><ul><li>kube-dns降权运行，详见kubernetes#82347</li></ul></li><li><p>存储优化：</p><p> a. CSI raw block特性</p><ul><li>拆分NodeStage / NodePublish</li><li><p>修改重启kubelet时的volume重建逻辑</p><p>b. VolumeSubpathEnvExpansion特性正式GA</p></li></ul></li><li><p>控制器优化</p><ul><li><p>优化ReplicaSet处理逻辑：创建/删除时考虑pod相关性，详见kubernetes#80004</p></li><li><p>Pod Disruption Budged对象处理优化，详见kubernetes#83951</p></li></ul></li></ol><hr><h3 id="三、CNCF相关"><a href="#三、CNCF相关" class="headerlink" title="三、CNCF相关"></a>三、CNCF相关</h3><ol><li><p>Jaeger项目顺利毕业</p><p> 相关介绍：Jaeger由Uber开源的端到端分布式追踪平台，用于监控与排查应用故障。</p></li><li><p>Vitess项目顺利毕业</p><p> 相关介绍：Vitess最初在2010年由YouTube创建的一个内部解决方案，用于MySQL集群扩展 ，近期发布4.0版本。</p></li><li><p>CNCF发布2019/2020赞助企划书及KubeCon相关日程</p><p> 会议：2020年KubeCon + CloudNativeCon + 中国开源峰会<br> 日程：中国上海|2020年7月28日-30日<br> 人数：4000多名参会者</p></li></ol><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md" target="_blank" rel="noopener">kubernetes 1.17</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kubernetes 1.17&lt;/a&gt;当前changlog，&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;距离Kubernetes 1.17正式发布还剩不到一个月，那么我们在即将迎来的1.17版本中，会引入哪些新特性以及性能增强呢？下⾯我们基于最新commit状态，分享社区最新动向。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>证书相关概念</title>
    <link href="https://ustack.io/2019-11-21-%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86.html"/>
    <id>https://ustack.io/2019-11-21-证书相关概念梳理.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T08:53:43.411Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>之前没接触过证书加密的话,对证书相关的这些概念一知半解,虽然属于密码学范畴，但从事计算机专业，就需要保持时刻学习的态度.写这篇文章的目的就是为了理理清这些概念及后续推出的kubernetes安全相关文档.</p></div><a id="more"></a><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>SSL: Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,https就是带加密的http协议,而https的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的.</p><p>OpenSSL:简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到.</p><h4 id="证书标准"><a href="#证书标准" class="headerlink" title="证书标准"></a>证书标准</h4><p>X.509:这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.</p><h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式.</p><ul><li><p>PEM: Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>  查看PEM格式证书的信息: <code>openssl x509 -in certificate.pem -text -noout</code><br>  Apache和*NIX服务器偏向于使用这种编码格式.</p></li><li><p>DER: Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>  查看DER格式证书的信息: <code>openssl x509 -in certificate.der -inform der -text -noout</code><br>  Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><blockquote><p>虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</p></blockquote><ul><li>CRT: CRT是certificate的三个字母,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码.</li><li>CER: 同样是certificate,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</li><li>KEY: 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.<br>查看方式:<br>  PEM格式:<code>openssl rsa -in mykey.key -text -noout</code><br>  DER格式:<code>openssl rsa -in mykey.key -text -noout -inform der</code></li><li>CSR: Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.<br>  查看方式:<pre><code>PEM格式:`openssl req -in mykey.csr -text -noout`DER格式:`openssl req -in mykey.csr -text -noout -inform der`  </code></pre></li><li>PFX/P12: predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br>  查看方式:<code>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</code><br>  这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.<br>  生成pfx的命令类似这样:<code>openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CACert.crt</code><br>  其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</li></ul><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><blockquote><p>要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req</p></blockquote><ul><li>PEM转为DER: <code>openssl x509 -in cert.crt -outform der -out cert.der</code></li><li>DER转为PEM: <code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></li></ul><h4 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h4><ol><li><p>向权威证书颁发机构申请证书<br>用这命令生成一个csr: 把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变.</p></li><li><p>自签证书<br><code>openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</code><br>在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如”yourcompany.com”,或者你服务器的IP地址,其它都可以留空的.<br>生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.有兴趣的话查查”沃通数字证书”.</p></li></ol><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将推出kubernetes AuthN/z及CSR等系列文章</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://www.360doc.com/content/15/0520/10/21412_471902987.shtml" target="_blank" rel="noopener">证书相关概念</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">CRI-O</a></li><li><a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noopener">runtime-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;之前没接触过证书加密的话,对证书相关的这些概念一知半解,虽然属于密码学范畴，但从事计算机专业，就需要保持时刻学习的态度.写这篇文章的目的就是为了理理清这些概念及后续推出的kubernetes安全相关文档.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux hugepages原理概念</title>
    <link href="https://ustack.io/2019-11-21-Linux%E4%B9%8Bhugepages%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5.html"/>
    <id>https://ustack.io/2019-11-21-Linux之hugepages原理概念.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T14:27:53.836Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p> hugepage是在Linux2.6内核被引入的，主要提供4k的page和比较大的page的选择。</p></div><a id="more"></a><p>系统进程是通过虚拟地址访问内存，但是CPU必须把它转换程物理内存地址才能真正访问内存。为了提高这个转换效率，CPU会缓存最近的虚拟内存地址和物理内存地址的映射关系，并保存在一个由CPU维护的映射表中。为了尽量提高内存的访问速度，需要在映射表中保存尽量多的映射关系。<br>而在Linux中，内存都是以页的形式划分的，默认情况下每页是4K，这就意味着如果物理内存很大，则映射表的条目将会非常多，会影响CPU的检索效率。因为内存大小是固定的，为了减少映射表的条目，可采取的办法只有增加页的尺寸。</p><hr><h3 id="1、hugepages及相关概念"><a href="#1、hugepages及相关概念" class="headerlink" title="1、hugepages及相关概念"></a>1、hugepages及相关概念</h3><p>有一些显示的概念需要澄清，在我们继续讨论Hugepages之前， 如hugetlb, hugetlbfs.<br>page table（页表）是操作系统上的虚拟内存系统的数据结构模型，用于存储虚拟地址与物理地址的对应关系。当我们访问内存时，首先访问”page table“，然后Linux在通过“page table”的mapping来访问真实物理内存（ram+swap）</p><ul><li>TLB: A Translation Lookaside Buffer (TLB)<br>TLB是在cpu中分配的一个固定大小的buffer(or cache)，用于保存“page table”的部分内容，使CPU更快的访问并进行地址转换。</li><li>hugetlb: hugetlb 是记录在TLB 中条目并指向到Hugepage。所以HugePages 通过 hugetlb entries来调用的。</li><li>hugetlbfs: 这是一个新的基于2.6 kernel之上的内存文件系统，如同tmpfs。</li></ul><p>在TLB中通过hugetlb来指向hugepage。这些被分配的hugepage作为内存文件系统hugetlbfs(类似tmpfs)提供给进程使用。</p><h3 id="2、“regular-page”和“huge-page“的请求过程"><a href="#2、“regular-page”和“huge-page“的请求过程" class="headerlink" title="2、“regular page”和“huge page“的请求过程"></a>2、“regular page”和“huge page“的请求过程</h3><p>当一个进程请求内存时，它需要访问文件系统的“页表”（Pagetable）去调用一个实际的物理内存地址,逻辑如下图所示。</p><p><img src="https://s2.ax1x.com/2019/11/23/Mq2La4.md.png" alt="regular"></p><p>当Hugepage部署后，依然是调用普通的页表。 最大的不同是process pagetable和system pagetable增加了Hugepage属性。所以任何页表中的page条目可以是“regular page” 或者是“huge page”.</p><p><img src="https://s2.ax1x.com/2019/11/23/MqRpM6.md.png" alt="huge"></p><h3 id="3、hugepage-优点"><a href="#3、hugepage-优点" class="headerlink" title="3、hugepage 优点"></a>3、hugepage 优点</h3><ol><li><p>HugePages 会在系统启动时，直接分配并保留对应大小的内存区域</p></li><li><p>HugePages 在开机之后，如果没有管理员的介入，是不会释放和改变的。</p></li><li><p>Not swappable: HugePages 是不会swap.也就是没有page-in/page-out。HugePages一直被pin在内存中</p></li><li><p>Relief of TLB pressure:</p></li></ol><p>在purge TLB的时候，减少了事物条目的加载，提高了性能。使用Hugepages后TLB能覆盖更大的内存地址空间，加快地址转换的时间更少的TLB条目，意味着有更大空间用来记录其他的地址空间.</p><ul><li>No ‘kswapd’ Operations：在Linux下进程“kswapd”是管理swap的，如果是大内存，那pages的数量就非常庞大（例如：50G内存包含1千3百万页表条目），就会耗费惊人的CPU资源。如果使用hugepages，kswapd就不会耗费资源去管理它，可以查看文档361670.1。</li><li>Eliminated page table lookup overhead: 因为hugepage是不swappable的，所有就没有page table lookups。</li><li>Faster overall memory performance:  由于虚拟内存需要两步操作才能实际对应到物理内存地址，因此更少的pages，减轻了page table访问热度，避免了page table热点瓶颈问题。</li></ul><h3 id="4、配置Hugepages"><a href="#4、配置Hugepages" class="headerlink" title="4、配置Hugepages"></a>4、配置Hugepages</h3><p>根据下面的步骤来配置Hugepages，修改Hugepages需要重启机器，使用请计划停机时间。</p><p>需要在/etc/security/limits.conf 中设置memlock值(单位KB)，该值小于内存大小，例如你的内存大小是64G，有可以设置以下的值.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft   memlock    60397977</span><br><span class="line">hard   memlock    60397977</span><br></pre></td></tr></table></figure><ul><li>编辑/etc/sysctl.conf 设置 vm.nr_hugepages参数：vm.nr_hugepages = 1496</li><li>reboot</li><li>系统重启后，启动全部的数据库，通过以下命令检查</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep HugePages /proc/meminfo</span></span><br><span class="line">HugePages_Total:    1496</span><br><span class="line">HugePages_Free:      485</span><br><span class="line">HugePages_Rsvd:      446</span><br><span class="line">HugePages_Surp:        0</span><br></pre></td></tr></table></figure><p>HugePages_Free&lt; HugePages_Total 既说明Hugepages已经生效，同时HugePages_Rsvd不为“0”.</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为linux hugepages相关内容的网络优化，后续推出kubelet涉及hugepages的相关内容。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt; hugepage是在Linux2.6内核被引入的，主要提供4k的page和比较大的page的选择。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存控制之oom killer机制</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E4%B9%8Boom%20killer%E6%9C%BA%E5%88%B6.html"/>
    <id>https://ustack.io/2019-11-21-Linux内存控制之oom killer机制.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-22T15:36:30.366Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及oom killer相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>OOM就是out of memory的缩写，虽然linux kernel有很多的内存管理技巧（从cache中回收、swap out等）来满足各种应用空间的vm内存需求，但是，当你的系统配置不合理，让一匹小马拉大车的时候，linux kernel会运行非常缓慢并且在某个时间点分配page frame的时候遇到内存耗尽、无法分配的状况。应对这种状况首先应该是系统管理员，他需要首先给系统增加内存，不过对于kernel而言，当面对OOM的时候，要根据OOM参数来进行相应的处理。oom kiiler会在内存紧张的时候，会依次kill内存占用较高的进程，发送Sig15(SIGTERM)或Sig9(SIGKILL)，取决于内核版本(可见uname -a，&gt;= 2.6.32只会发送<a href="https://elixir.free-electrons.com/linux/v2.6.18/source/mm/oom_kill.c" target="_blank" rel="noopener">sigkill</a>，并在/var/log/message中进行记录。里面会记录一些如pid，process name，cpu mask，trace等信息，通过监控可以发现类似问题。</p><p><strong><strong>初探</strong></strong></p><p>一个简单分配heap memroy的代码片段(big_mm.c)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> block (1024L*1024L*MB)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB 64L</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">  <span class="comment">// malloc big block memory and ZERO it !!</span></span><br><span class="line">  <span class="keyword">char</span>* mm = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(block);</span><br><span class="line">  usleep(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mm)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    bzero(mm,block);</span><br><span class="line">    total += MB;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"alloc %lum mem\n"</span>,total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有2个地方需要注意：</p><p>1、malloc是分配虚拟地址空间，如果不memset或者bzero，那么就不会触发physical allocate，不会映射物理地址，所以这里用bzero填充<br><br><br>2、每次申请的block大小比较有讲究，Linux内核分为LowMemroy和HighMemroy，LowMemory为内存紧张资源，LowMemroy有个阀值，通过free -lm和<br>/proc/sys/vm/lowmem_reserve_ratio来查看当前low大小和阀值low大小。低于阀值时候才会触发oom killer，所以这里block的分配小雨默认的256M，否则如果每次申请512M(大于128M)，malloc可能会被底层的brk这个syscall阻塞住，内核触发page cache回写或slab回收。</p><p>测试：<code>gcc big_mm.c -o big_mm ; ./big_mm &amp; ./big_mm &amp; ./big_mm &amp;</code></p><h3 id="2、oom-killer机制分析"><a href="#2、oom-killer机制分析" class="headerlink" title="2、oom killer机制分析"></a>2、oom killer机制分析</h3><h4 id="2-1-参数"><a href="#2-1-参数" class="headerlink" title="2.1 参数"></a>2.1 参数</h4><p><strong><strong>panic_on_oom</strong></strong></p><p>当kernel遇到OOM的时候，可以有两种选择：<br>（1）产生kernel panic<br><br><br>（2）积极面对人生，选择一个或者几个最“适合”的进程，启动OOM killer，干掉那些选中的进程，释放内存，让系统勇敢的活下去。</p><p>panic_on_oom这个参数就是控制遇到OOM的时候，系统如何反应的。当该参数等于0的时候，表示选择积极面对人生，启动OOM killer。当该参数等于2的时候，表示无论是哪一种情况，都强制进入kernel panic。panic_on_oom等于其他值的时候，表示要区分具体的情况，对于某些情况可以panic，有些情况启动OOM killer。kernel的代码中，enum oom_constraint 就是一个进一步描述OOM状态的参数。系统遇到OOM总是有各种各样的情况的，kernel中定义如下：</p><p>（1）CONSTRAINT_CPUSET。cpusets是kernel中的一种机制，通过该机制可以把一组cpu和memory node资源分配给特定的一组进程。这时候，如果出现OOM，仅仅说明该进程能分配memory的那个node出现状况了，整个系统有很多的memory node，其他的node可能有充足的memory资源。</p><p>（2）CONSTRAINT_MEMORY_POLICY。memory policy是NUMA系统中如何控制分配各个memory node资源的策略模块。用户空间程序（NUMA-aware的程序）可以通过memory policy的API，针对整个系统、针对一个特定的进程，针对一个特定进程的特定的VMA来制定策略。产生了OOM也有可能是因为附加了memory policy的约束导致的，在这种情况下，如果导致整个系统panic似乎有点不太合适吧。</p><p>（3）CONSTRAINT_MEMCG。MEMCG就是memory control group，Cgroup中的memory子系统就是控制系统memory资源分配的控制器，通俗的将就是把一组进程的内存使用限定在一个范围内。当这一组的内存使用超过上限就会OOM，在这种情况下的OOM就是CONSTRAINT_MEMCG类型的OOM。</p><p><strong><strong>oom_adj、oom_score_adj和oom_score</strong></strong></p><p>准确的说这几个参数都是和具体进程相关的，因此它们位于/proc/xxx/目录下（xxx是进程ID）。假设我们选择在出现OOM状况的时候杀死进程，那么一个很自然的问题就浮现出来：到底干掉哪一个呢？内核的算法倒是非常简单，那就是打分（oom_score，注意，该参数是read only的），找到分数最高的就OK了。那么怎么来算分数呢？<br>我们触发了oom killer的机制，那么oom killer是计算出选择哪个进程kill呢？我们先来看一下kernel提供给用户态的/proc下的一些参数：</p><p>(1）对某一个task进行打分（oom_score）主要有两部分组成，一部分是系统打分，主要是根据该task的内存使用情况。另外一部分是用户打分，也就是oom_score_adj了，该task的实际得分需要综合考虑两方面的打分。如果用户将该task的 oom_score_adj设定成OOM_SCORE_ADJ_MIN（-1000）的话，那么实际上就是禁止了OOM killer杀死该进程。<br><br><br>(2）这里返回了0也就是告知OOM killer，该进程是“good process”，不要干掉它。后面我们可以看到，实际计算分数的时候最低分是1分。<br><br><br>(3）前面说过了，系统打分就是看物理内存消耗量，主要是三部分，RSS部分，swap file或者swap device上占用的内存情况以及页表占用的内存情况。<br><br><br>(4）root进程有3%的内存使用特权，因此这里要减去那些内存使用量。<br><br><br>(5）用户可以调整oom_score，具体如何操作呢？oom_score_adj的取值范围是-1000～1000，0表示用户不调整oom_score，负值表示要在实际打分值上减去一个折扣，正值表示要惩罚该task，也就是增加该进程的oom_score。在实际操作中，需要根据本次内存分配时候可分配内存来计算（如果没有内存分配约束，那么就是系统中的所有可用内存，如果系统支持cpuset，那么这里的可分配内存就是该cpuset的实际额度值）。oom_badness函数有一个传入参数totalpages，该参数就是当时的可分配的内存上限值。实际的分数值（points）要根据oom_score_adj进行调整，例如如果oom_score_adj设定-500，那么表示实际分数要打五折（基数是totalpages），也就是说该任务实际使用的内存要减去可分配的内存上限值的一半。</p><p>了解了oom_score_adj和oom_score之后，应该是尘埃落定了，oom_adj是一个旧的接口参数，其功能类似oom_score_adj，为了兼容，目前仍然保留这个参数，当操作这个参数的时候，kernel实际上是会换算成oom_score_adj。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/[pid]/oom_adj <span class="comment">#该pid进程被oom killer杀掉的权重，介于 [-17,15]之间，越高的权重，意味着更可能被oom killer选中，-17表示禁止被kill掉。</span></span><br><span class="line">/proc/[pid]/oom_score <span class="comment">#当前该pid进程的被kill的分数，越高的分数意味着越可能被kill，这个数值是根据oom_adj运算后的结果，是oom_killer的主要参考。</span></span><br></pre></td></tr></table></figure><p>sysctl 下有2个可配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.panic_on_oom = 0       <span class="comment">#内存不够时内核是否直接panic</span></span><br><span class="line">vm.oom_kill_allocating_task = 1      <span class="comment">#oom-killer是否选择当前正在申请内存的进程进行kill</span></span><br></pre></td></tr></table></figure><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linux-mm.org/OOM_Killer" target="_blank" rel="noopener">oom</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及oom killer相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux几个重要的内核配置</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE.html"/>
    <id>https://ustack.io/2019-11-21-Linux几个重要的内核配置.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T13:50:17.539Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>以下是在/etc/sysctl.conf文件中配置的几个重要内核参数，这几个参数的设置关系到系统性能。</p></div><a id="more"></a><hr><h3 id="1、net-ipv4-tcp-syncookies"><a href="#1、net-ipv4-tcp-syncookies" class="headerlink" title="1、net.ipv4.tcp_syncookies"></a>1、net.ipv4.tcp_syncookies</h3><blockquote><p>此参数应该设置为1，防止SYN Flood</p></blockquote><p>处在SYN_RECV的TCP连接称为半连接，存储在SYN队列。大量SYN_RECV会导致队列溢出，后续请求将被内核直接丢弃，也就是SYN Flood攻击。开启syncookies后，当SYN队列满了后，TCP会通过原地址端口，目的地址端口和时间戳打造一个特别的Sequence Number(又叫cookie发回去，如果是攻击者则不会有响应，如果是正常连接则把这个SYNCookie发回来，然后服务器端可以通过cookie建立连接(即使不在SYN队列)。</p><h3 id="2、net-ipv4-tcp-fin-timeout"><a href="#2、net-ipv4-tcp-fin-timeout" class="headerlink" title="2、net.ipv4.tcp_fin_timeout"></a>2、net.ipv4.tcp_fin_timeout</h3><blockquote><p>此参数默认值60</p></blockquote><p>TCP保持在FIN_WAIT2状态的时间，超时后直接处于CLOSED，所以降低tcp_fin_timeout有助于减少TIME_WAIT数量。注意：虽然shutdown(SHUD_WR)也会处于FIN_WAIT2状态，但超时并不起作用。</p><h3 id="3、net-ipv4-tcp-tw-recycle"><a href="#3、net-ipv4-tcp-tw-recycle" class="headerlink" title="3、net.ipv4.tcp_tw_recycle"></a>3、net.ipv4.tcp_tw_recycle</h3><blockquote><p>此参数默认值0，打开快速TIME_WAIT socket回收</p></blockquote><p>如果tcp_timestamps开启的话，会缓存每个连接的最新时间戳，如果后续请求时间戳小于缓存的时间戳，即视为无效，相应的包被丢弃。所以如果是在NAT(Network Address Translation)网络下，就可能出现数据包丢弃的现象，会导致大量的TCP连接建立错误。</p><h3 id="4、net-ipv4-tcp-tw-resue"><a href="#4、net-ipv4-tcp-tw-resue" class="headerlink" title="4、net.ipv4.tcp_tw_resue"></a>4、net.ipv4.tcp_tw_resue</h3><blockquote><p>此参数默认值0，是否重用TIME_WAIT状态的socket用于新的连接</p></blockquote><p>这个选项要比net.ipv4.tcp_tw_recycle安全，从协议的角度看，复用是安全的。复用条件:</p><ul><li>net.ipv4.tcp_timestamps选项必须打开(客户端也必须打开) ；</li><li>重用TIME_WAIT的条件是收到最后一个包后超过1秒；</li></ul><h3 id="5、net-ipv4-tcp-keepalive-time-1200"><a href="#5、net-ipv4-tcp-keepalive-time-1200" class="headerlink" title="5、net.ipv4.tcp_keepalive_time = 1200"></a>5、net.ipv4.tcp_keepalive_time = 1200</h3><blockquote><p>此参数表示TCP发送keepalive探测消息的间隔时间（秒）</p></blockquote><p>用于确认TCP连接是否有效。当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，可改为20分钟。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为linux相关内容的网络优化，后续推出CNI相关内容。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;以下是在/etc/sysctl.conf文件中配置的几个重要内核参数，这几个参数的设置关系到系统性能。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存控制之overcommit</title>
    <link href="https://ustack.io/2019-11-21-Linux%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E4%B9%8B%E8%B6%85%E5%88%86.html"/>
    <id>https://ustack.io/2019-11-21-Linux内存控制之超分.html</id>
    <published>2019-11-21T12:40:08.000Z</published>
    <updated>2019-11-23T13:50:12.730Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。</p><p>kubelet组件涉及内存分配相关概念，在此先作学习铺垫。</p></div><a id="more"></a><hr><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>Memory Overcommit的意思是操作系统承诺给进程的内存大小超过了实际可用的内存。一个保守的操作系统不会允许memory overcommit，有多少就分配多少，再申请就没有了，这其实有些浪费内存，因为进程实际使用到的内存往往比申请的内存要少，比如某个进程malloc()了200MB内存，但实际上只用到了100MB，按照UNIX/Linux的算法，物理内存页的分配发生在使用的瞬间，而不是在申请的瞬间，也就是说未用到的100MB内存根本就没有分配，这100MB内存就闲置了。下面这个概念很重要，是理解memory overcommit的关键：commit(或overcommit)针对的是内存申请，内存申请不等于内存分配，内存只在实际用到的时候才分配。</p><p>Linux是允许memory overcommit的，只要你来申请内存我就给你，寄希望于进程实际上用不到那么多内存，但万一用到那么多了呢？那就会发生类似“银行挤兑”的危机，现金(内存)不足了。Linux设计了一个OOM killer机制(OOM = out-of-memory)来处理这种危机：挑选一个进程出来杀死，以腾出部分内存，如果还不够就继续杀…也可通过设置内核参数 vm.panic_on_oom 使得发生OOM时自动重启系统。这都是有风险的机制，重启有可能造成业务中断，杀死进程也有可能导致业务中断，我自己的这个小网站就碰到过这种问题，参见前文。所以Linux 2.6之后允许通过内核参数 vm.overcommit_memory 禁止memory overcommit。</p><p>内核参数 vm.overcommit_memory 接受三种取值：</p><ul><li>Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法（对该算法的详细解释请看文末）猜测你的内存申请是否合理，它认为不合理就会拒绝overcommit。</li><li>Always overcommit. 允许overcommit，对内存申请来者不拒。</li><li>Don’t overcommit. 禁止overcommit。</li></ul><p>关于禁止overcommit (vm.overcommit_memory=2) ，需要知道的是，怎样才算是overcommit呢？kernel设有一个阈值，申请的内存总数超过这个阈值就算overcommit，在/proc/meminfo中可以看到这个阈值的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i commit /proc/meminfo</span></span><br><span class="line">CommitLimit:     5967744 kB</span><br><span class="line">Committed_AS:    5363236 kB</span><br></pre></td></tr></table></figure><p>CommitLimit 就是overcommit的阈值，申请的内存总数超过CommitLimit的话就算是overcommit。<br>这个阈值是如何计算出来的呢？它既不是物理内存的大小，也不是free memory的大小，它是通过内核参数vm.overcommit_ratio或vm.overcommit_kbytes间接设置的，公式如下：<br><code>CommitLimit = (Physical RAM * vm.overcommit_ratio / 100) + Swap</code></p><blockquote><p>vm.overcommit_ratio 是内核参数，缺省值是50，表示物理内存的50%。如果你不想使用比率，也可以直接指定内存的字节数大小，通过另一个内核参数 vm.overcommit_kbytes 即可；<br>如果使用了huge pages，那么需要从物理内存中减去，公式变成：<br>CommitLimit = ([total RAM] – [total huge TLB RAM]) * vm.overcommit_ratio / 100 + swap<br>参见<a href="https://access.redhat.com/solutions/665023" target="_blank" rel="noopener">链接</a></p></blockquote><p>/proc/meminfo中的 Committed_AS 表示所有进程已经申请的内存总大小，（注意是已经申请的，不是已经分配的），如果 Committed_AS 超过 CommitLimit 就表示发生了 overcommit，超出越多表示 overcommit 越严重。Committed_AS 的含义换一种说法就是，如果要绝对保证不发生OOM (out of memory) 需要多少物理内存。</p><p>“sar -r”是查看内存使用状况的常用工具，它的输出结果中有两个与overcommit有关，kbcommit 和 %commit：<br>kbcommit对应/proc/meminfo中的 Committed_AS；<br>%commit的计算公式并没有采用 CommitLimit作分母，而是Committed_AS/(MemTotal+SwapTotal)，意思是<em>内存申请</em>占<em>物理内存与交换区之和</em>的百分比。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sar -r</span><br><span class="line">05:00:01 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">05:10:01 PM    160576   3648460     95.78         0   1846212   4939368     62.74   1390292   1854880</span><br></pre></td></tr></table></figure><h3 id="2、Heuristic-overcommit算法"><a href="#2、Heuristic-overcommit算法" class="headerlink" title="2、Heuristic overcommit算法"></a>2、Heuristic overcommit算法</h3><p>内核参数 vm.overcommit_memory 的值0，1，2，其中heuristic overcommit对应的是OVERCOMMIT_GUESS：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_GUESS                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_ALWAYS               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERCOMMIT_NEVER                2</span></span><br></pre></td></tr></table></figure><p>Heuristic overcommit算法在以下函数中实现，基本上可以这么理解：<br>单次申请的内存大小不能超过 【free memory + free swap + pagecache的大小 + SLAB中可回收的部分】，否则本次申请就会失败。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>该文为kubelet相关内容的铺垫，涉及到kubelet对于oom killer的使用。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="http://linuxperf.com/?p=102" target="_blank" rel="noopener">overcommit</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">kernel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;接触kubernetes两年有余，从18年初加入kubernetes社区来算，已经一年半，或许是时候写点什么。简单文章如何写好，难点文章如何写透，或许是一种学问，打算推一个系列：《Kubernetes GO》算是对这两年的一个总结。&lt;/p&gt;
&lt;p&gt;kubelet组件涉及内存分配相关概念，在此先作学习铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
</feed>
