<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Indagate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ustack.io/"/>
  <updated>2020-07-09T12:51:16.743Z</updated>
  <id>https://ustack.io/</id>
  
  <author>
    <name>zouyee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CloudEvents初识规范</title>
    <link href="https://ustack.io/2020-07-09-CloudEvents%E5%88%9D%E8%AF%86%E8%A7%84%E8%8C%83.html"/>
    <id>https://ustack.io/2020-07-09-CloudEvents初识规范.html</id>
    <published>2020-07-09T12:40:08.000Z</published>
    <updated>2020-07-09T12:51:16.743Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>事件无处不在。然而，事件生产者倾向于以不同的方式来描述事件。</p><p>缺乏通用的描述事件的方式意味着开发人员必须不断地重新学习如何消费事件。这也限制了类库、工具和基础设施在跨环境时发送事件数据的潜力，如SDK、事件路由器或跟踪系统等。我们从事件数据中实现的可移植性和生产力总体上受到了阻碍。CloudEvents是一个用通用格式描述事件数据的规范，以提供跨服务、跨平台和跨系统的互操作性。CloudEvents得到了大量的行业关注，从主要的云提供商到流行的SaaS公司都有。CloudEvents由云原生计算基金会（CNCF）主办，于2018年5月15日获批为云原生沙盒级项目。</p></div><a id="more"></a><hr><h4 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h4><h5 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h5><p>CNCF无服务器工作组最初是由CNCF技术监督委员会设立的，目的是调查无服务器技术，并为CNCF在这一领域的一些相关活动提出一些可能的下一步建议。其中一项建议是调查创建一种通用的事件格式，以帮助云提供商之间的函数可移植性和事件流处理的互操作性。因此，CloudEvents 规范应运而生。虽然最初CloudEvents的工作是作为无服务器工作组的一部分完成的，但在规范达到v0.1的里程碑之后，TOC批准了CloudEvents工作，将其作为一个新的独立的CNCF沙盒项目。</p><h5 id="需求目标"><a href="#需求目标" class="headerlink" title="需求目标"></a>需求目标</h5><p>CloudEvents通常用于分布式系统中，允许服务在开发过程中松散耦合，独立部署，稍后可以连接起来创建新的应用。CloudEvents规范的目标是定义事件系统的互操作性，允许服务产生或消费事件，其中生产者和消费者可以独立开发和部署。生产者可以在消费者监听之前产生事件，而消费者可以对尚未产生的事件或事件类表达兴趣。请注意，这项工作所产生的规范侧重于事件格式的互操作性，以及事件在HTTP等各种协议上发送时如何呈现。该规范将不关注事件生产者或事件消费者的处理模型。</p><p>CloudEvents 的核心是定义了一组关于系统间传输事件的元数据（被称为属性），以及这些元数据应该如何出现在该消息中。这些元数据是将请求路由到适当的组件并促进该组件对事件进行适当处理所需的最低限度的信息集。因此，虽然这可能意味着事件本身的一些应用数据可能会和作为 CloudEvent 属性集的一部分重复，但这只是为了正确传递和处理消息的目的。不用于此目的的数据应放在事件（数据）本身中。此外，假定协议层向目标系统传递消息所需的元数据完全由协议处理，因此不包含在 CloudEvents 属性中。有关详细信息，请参阅 “非目标 “部分。在定义这些属性的同时，还将对如何以不同格式（如 JSON）和协议（如 HTTP、AMQP、Kafka）序列化事件进行规范。一些协议原生支持将多个事件批量化为一个API调用。为了帮助实现互操作性，是否需要批处理和如何实现批处理由协议决定。详情可在协议绑定或协议规范中找到。</p><p>CloudEvents 的批处理没有语义，也没有顺序。中间人可以添加或删除批处理，也可以将事件分配给不同的批次。</p><hr><h4 id="二、CloudEvents相关概念"><a href="#二、CloudEvents相关概念" class="headerlink" title="二、CloudEvents相关概念"></a>二、CloudEvents相关概念</h4><p>事件（Event）包含和发生（Occurrence）相关的上下文和数据。每一个发生（Occurrence）都由事件的数据唯一标识。</p><blockquote><p>事件代表事实，因此不包括目的地，而消息则传达意图，将数据从源头传送到特定的目的地。</p></blockquote><h5 id="Eventing"><a href="#Eventing" class="headerlink" title="Eventing"></a>Eventing</h5><p>在服务器端代码中，事件通常用于连接不同的系统，其中一个系统的状态变化会导致另一个系统的代码执行。例如，当源接收到外部信号（如 HTTP 或 RPC）或观察到一个变化的值（如 IoT 传感器或非活动期）时，可能会产生一个事件。</p><p>为了说明系统如何使用 CloudEvents，下面的简化图显示了来自源的事件如何触发一个动作。</p><p>源(Source)生成消息(Message)，其中事件(Event)被封装在协议中。事件到达目的地，触发一个由事件数据提供的动作(Action)。源是源类型的一个特定实例，它允许staging和测试实例。一个特定源类型的开放源软件可以由多个公司或供应商部署。</p><ul><li><p>事件可以通过各种行业标准协议（如HTTP、AMQP、MQTT、SMTP）、开源协议（如Kafka、NATS）或平台/供应商特定的协议（AWS Kinesis、Azure Event Grid）来递送。</p></li><li><p>动作处理定义了由特定源的特定事件触发的行为或效果的事件。虽然不在本规范的范围内，但生成事件的目的通常是为了让其他系统能够轻松地对它们无法控制的源中的变化做出反应。源和动作通常是由不同的开发人员建立的。通常情况下，源是一个托管服务，而动作是无服务器函数（如AWS Lambda或Google Cloud Functions）中的自定义代码。</p></li></ul><h5 id="规范之外"><a href="#规范之外" class="headerlink" title="规范之外"></a>规范之外</h5><p>以下内容被认为超出了本规范的范围。</p><ul><li>函数的建立和调用过程</li><li>特定语言的运行时API</li><li>选择单一身份/访问控制系统</li><li>包含协议级的路由信息</li><li>事件持久化过程</li></ul><p>CloudEvents 规范将不包括协议级的路由信息（例如，发送事件的目标 URL）。这是对CloudEvents概念的新手提出的一个常见建议。经过多次讨论后，工作组得出结论：规范中没有必要包含路由信息：任何协议（如 HTTP、MQTT、XMPP 或 Pub/Sub 总线）都已经定义了路由的语义。例如，CloudEvents HTTP 绑定规定了头和请求正文内容。CloudEvents 不需要在规范中包含目标 URL 才能兼容 HTTP；HTTP 规范已经在 Request-Line 中包含了一个目标 URL。</p><p>路由信息不仅是多余的，而且会分散注意力。CloudEvents 应该增加互操作性，并将事件的生产者和消费者解耦。禁止事件格式中的路由信息，可以让CloudEvents重新传递给新的Action，或者通过包含多个通道的复杂中继器传递。例如，如果 Webhook 地址不可用，则原定用于 Webhook 的 CloudEvent 应可投递给死信队列。该死信队列应该能够将事件送入原始事件发出者从未想过的新的Action。</p><p>在系统内和跨系统产生和消费的CloudEvents会触发行为，从而产生价值。因此，归档和/或重放事件对于调试或复制来说是非常有价值的。然而，持久化事件会删除传输过程中可用的上下文信息，如生产者的身份和权利、保真验证机制或保密保护。此外，持久化会增加复杂性和挑战，以满足用户的需求。例如，重复使用私钥进行加密或签名，会增加攻击者可用的信息，从而降低安全性。预计可能会定义出有助于满足持久性要求的属性，但预计这些属性将随着行业最佳实践和进步而不断发展。</p><hr><h4 id="三、架构"><a href="#三、架构" class="headerlink" title="三、架构"></a>三、架构</h4><p>CloudEvents 规范集定义了四种不同类型的协议元素，它们构成了一个分层架构模型。</p><ol><li><p>基本规范 定义了由属性（键值对）和相关规则组成的抽象信息模型，这些属性和相关规则构成了CloudEvents。</p></li><li><p>扩展 添加了特定的、可能重叠的扩展属性和相关规则集，例如，支持不同的跟踪标准。</p></li><li><p>事件格式编码（如 JSON）定义了基本规范的信息模型和所选扩展的编码方式，以将其映射到应用协议的头和有效载荷元素。</p></li><li><p>协议绑定，例如 HTTP，定义了 CloudEvent 如何与应用协议的传输帧绑定，在 HTTP 的下是绑定 HTTP 消息。协议绑定并不约束传输帧的使用方式，这意味<br>着HTTP绑定可以与任何HTTP方法以及请求和响应消息一起使用。</p></li></ol><p>如果需要确保更广泛的互操作性，CloudEvents 规范集为使用特定应用协议的事件传递提供了特定的约束。HTTP Webhook 规范并不是 CloudEvents 所特有的，它可以用于将任何类型的单向事件和通知发布到符合的 HTTP 端点。然而，由于其他地方缺乏这样的规范，因此CloudEvents有必要定义它。</p><p><strong><em>协议错误处理</em></strong></p><p>大多数情况下，CloudEvents 规范并没有规定与创建或处理 CloudEvents 相关的处理模型。因此，如果在处理 CloudEvents 过程中出现错误，鼓励遇到错误的软件使用常规的协议级错误报告来报告错误。</p><p><strong><em>属性的版本化</em></strong></p><p>对于某些 CloudEvents 属性，其值所引用的实体或数据模型可能会随着时间的推移而变化。例如，dataschema 可能会引用模式文档的一个特定版本。通常情况下，这些属性值将通过在其值中包含某些特定于版本的字符串作为其值的一部分来区分每个变体。例如，可能会使用版本号（v1、v2）或日期（2018-01-01-01）。CloudEvents 规范并没有规定要使用任何特定的模式，甚至根本不要求使用版本字符串。此决定权在每个事件制生产者手中。但是，当包含特定版本字符串时，应注意其值的变化，因为事件的消费者可能会依赖现有的值，因此变化可能会被解释为 “破坏性变化”。应该在生产者和消费者之间建立某种形式的沟通，以确保事件消费者知道可能使用的值。一般来说，所有 CloudEvents 属性也是如此。</p><h5 id="CloudEvent属性"><a href="#CloudEvent属性" class="headerlink" title="CloudEvent属性"></a>CloudEvent属性</h5><p>本节提供了与CloudEvent的一些属性相关的其他背景和设计要点。</p><p><strong><em>id</em></strong></p><p>id 属性是指在与一个事件源相关的所有事件中都是唯一的值（每个事件源都是由其 CloudEvents 的 source 属性值唯一标识的）。虽然所使用的确切值由生产者定义，但可以保证来自单一事件源的 CloudEvents 接收者不会有两个事件共享相同的 id 值。唯一的例外情况是，如果支持事件的某些重播，在这种情况下，可以使用 id 来检测。由于一个事件的发生可能会产生一个以上的事件，所以在所有这些事件都来自同一个事件源的情况下，每个 CloudEvent 构造的事件都有一个唯一的 id。以创建 DB 条目为例，这一次发生可能会产生一个创建类型为 create 的 CloudEvent 和一个写类型为 write 的 CloudEvent。这些CloudEvents中的每一个都有一个唯一的id。如果希望这两个 CloudEvents 之间有一定的相关性，以表明它们都与同一事件相关，那么 CloudEvent 中的一些附加数据将用于此目的。在这方面，虽然事件生成者选择的确切值可能是一些随机字符串，或在其他语境中具有某种语义意义的字符串，但对于本CloudEvent属性的目的来说，这些意义并不相关，因此，将id用于唯一性检查之外的其他目的不在本规范的范围内，也不建议使用。</p><h5 id="CloudEvent-属性扩展"><a href="#CloudEvent-属性扩展" class="headerlink" title="CloudEvent 属性扩展"></a>CloudEvent 属性扩展</h5><p>为了实现既定目标，规范作者将试图限制他们在 CloudEvents 中定义的元数据属性的数量。为此，本项目所定义的属性将分为三类。</p><ul><li>required (必须的)</li><li>optional (可选的)</li><li>extensions (可扩展）</li></ul><p>正如类别名称所暗示的那样，”必需 “属性将是该组认为在所有用例中对所有事件至关重要的属性，而 “可选 “属性将在大多数情况下使用。这两种情况下的属性都将在规范本身中定义。</p><p>当小组确定一个属性不够通用，不能归入这两类，但仍然可以从定义良好的互操作性中受益，那么它们将被归入 “扩展 “类别，并被归入文档化的扩展。该规范定义了这些扩展属性在 CloudEvent 中的出现方式。</p><p>在确定提议的属性属于哪个类别时，甚至在确定是否将其包含在其中时，小组会使用用例和用户故事来解释其理由和需求。CloudEvent 规范的扩展属性是指需要包含的额外元数据，以帮助确保 CloudEvent 的正确路由和处理。与事件本身相关且在传输或处理 CloudEvent 中不需要的其他目的的附加元数据，应放在事件（数据）本身的适当扩展点中。扩展属性应保持最小化，以确保 CloudEvent 能够正确地序列化和传输。例如，事件制作者应考虑向 CloudEvent 添加扩展时可能会遇到的技术限制。例如，HTTP二进制模式使用HTTP头来传输元数据；大多数HTTP服务器会拒绝HTTP header数据过多的请求，限制低至8kb。因此，应该尽量减少扩展属性的总大小和数量。如果一个扩展变得流行，那么规范作者可能会考虑将其作为核心属性移到规范中。这意味着在正式加入规范之前，扩展机制/进程可以作为一种方式来审核新属性，然后再正式加入到规范中。</p><p><strong><em>JSON扩展</em></strong></p><p>正如在CloudEvents规范的JSON事件格式中的Attributes部分提到的那样，CloudEvent扩展属性被序列化为规范定义的属性的兄弟姐妹–也就是说，在JSON对象的顶层。该规范的作者花了很长时间考虑了所有选项，并决定这是最好的选择。以下是其中的一些道理。由于规范遵循 semver（语义化版本），这意味着新的属性可以被未来版本的核心规范所定义，而不需要重大的版本号改变–只要这些属性是可选的。在这种情况下，考虑一下现有的消费者会如何处理一个新的（未知）顶层属性。虽然它可以自由地忽略它，因为它是可选的，但在大多数情况下，相信这些属性仍然希望暴露在接收这些事件的应用程序中。这将允许这些应用程序支持这些属性，即使基础设施不支持这些属性。这意味着，未知的顶层属性（不管是谁定义的–不管是未来版本的规范还是事件生产者）很可能不会被忽略。因此，虽然其他一些规范定义了一个特定的属性来放置扩展属性（例如顶层扩展属性），但作者决定，在一个传入的事件中，为未知的属性设置两个不同的位置，可能会导致互操作性问题，也会给开发者带来混乱。</p><p>通常情况下，在规范正式采用之前，扩展通常是用来测试规范的新的潜在属性。如果有一个扩展类型的属性，在这个新属性中，这个新属性被序列化了，那么，如果这个属性曾经被核心规范采用，那么它将从扩展属性中晋升（从序列化的角度来看）为顶层属性。如果我们假设这个新属性将是可选的，那么随着它被核心规范采用，它将只是一个小的版本增量，所有现有的消费者仍然应该继续工作。然而，消费者将不知道这个属性将出现在哪里–在扩展属性中或作为顶层属性。这意味着他们可能需要在这两个地方都要找。如果这个属性同时出现在两个地方，但价值不同怎么办？生产者是否需要将其放在两个地方，因为他们可能会有新老消费者？虽然可能有可能定义明确的规则来解决每一个可能出现的问题，但作者决定最好是一开始就简单地避免所有问题，在序列化中只为未知的、甚至是新的属性提供一个位置。此外，还有人指出，现在的HTTP规范也遵循了类似的模式，不再建议在HTTP扩展头中用X-作为前缀。</p><h5 id="创建CloudEvents"><a href="#创建CloudEvents" class="headerlink" title="创建CloudEvents"></a>创建CloudEvents</h5><p>CloudEvents 规范特意避免过强的规定如何创建 CloudEvents。例如，它不假定原始事件源是为该事件的发生构造相关的 CloudEvents 的同一个实体。这样就可以有多种实现选择。但是，对于规范的实现者来说，了解规范作者的期望值是很有用的，因为这可能有助于确保互操作性和一致性。</p><p>如上所述，生成初始事件的实体是否是创建相应的 CloudEvent 的实体是一个实现选择。然而，当构造/填充 CloudEvents 属性的实体代表事件源行事时，这些属性的值是为了描述事件或事件源，而不是计算 CloudEvent 属性值的实体。换句话说，当事件源和 CloudEvents 生产者之间的分工对事件消费者没有实质性的意义时，规范定义的属性通常不会包含任何值来表示这种责任的分工。</p><p>这并不是说 CloudEvents 生产者不能为 CloudEvents 添加一些额外的属性，但这些属性不属于规范中互操作性定义的属性范围。这就类似于 HTTP 代理通常会尽量减少对传入消息中定义好的 HTTP 标头的更改，但它可能会添加一些包含代理特定元数据的附加标头。还值得注意的是，原始事件源和 CloudEvents 生产者之间的这种分离可以是小的或大的。这意味着，即使CloudEvents 生产者不属于原始事件源的生态系统的一部分，但如果它是代表事件源行事，并且它在事件流中的存在对事件消费者来说没有意义，那么上述指导仍然适用。当一个实体同时充当CloudEvents的接收方和发送方，以转发或转换入站事件为目的时，出站CloudEvent与入站CloudEvent的匹配程度将根据该实体的处理语义而有所不同。如果它作为代理，只是将 CloudEvents 转发到另一个事件消费者，那么出站 CloudEvent 通常与入站 CloudEvent 在规范定义的属性方面看起来与入站 CloudEvent 完全相同。但是，如果这个实体正在对CloudEvent进行某种类型的语义处理，通常会导致数据属性的值发生变化，那么它可能需要被视为一个与原始事件源不同的 “事件源”。因此，预计与事件生产者相关的CloudEvents属性（如源和id）将从传入的CloudEvent中更改。</p><hr><h4 id="四、协议与编码"><a href="#四、协议与编码" class="headerlink" title="四、协议与编码"></a>四、协议与编码</h4><p>正如规范中所表达的那样，CloudEvents工作的明确目标是 “以通用的方式描述事件数据”，并 “定义事件系统的互操作性，使服务能够产生或消费事件，生产者和消费者可以独立开发和部署”。</p><p>这种互操作性的基础是开放的数据格式和开放的协议，CloudEvents旨在提供这种开放的数据格式，并将其数据格式投射到常用的协议和常用的编码上。尽管每个软件或服务产品和项目显然可以选择自己喜欢的通信形式，但毫无疑问，对这种产品或项目私有的专有协议并不能促进事件生产者和消费者之间的广泛互操作性的目标。特别是在消息传递和事件处理领域，过去十年来，业界在开发一个强大的、广泛支持的协议基础上取得了重大进展，比如HTTP 1.1和HTTP/2以及WebSockets或事件网络上的WebSockets或事件，或者是面向连接的消息传递和遥测传输的MQTT和AMQP。一些被广泛使用的协议已经成为事实上的标准，有些协议是由三家或更多公司组成的顶级联盟组成的强大的生态系统中产生的，有些则是由一家公司发布的强大的项目生态系统中产生的，无论在哪种情况下，都是与前面提到的标准栈的演进同步进行的。</p><p>CloudEvents不应成为一种载体，甚至不应成为暗中认可或推广项目或产品专有协议的工具，因为这将会对 CloudEvents 的最初目标产生反作用。要使协议或编码符合 CloudEvents 核心事件格式或协议绑定的资格，它必须属于以下任一类别。</p><ul><li>该协议具有作为标准的正式地位，具有广泛认可的多厂商协议标准化机构（如 W3C、IETF、OASIS、ISO）的标准地位</li><li>该协议在其生态系统类别中具有 “非事实标准 “的地位，这意味着它被广泛使用，以至于被认为是特定应用的标准。实际上，我们希望看到至少有一家厂商中立的<br>开源组织（如Apache、Eclipse、CNCF、.NET基金会）旗下至少有一个开源实现，并且至少有十几家独立的厂商在其产品/服务中使用该协议。</li></ul><p>除了正式地位之外，协议或编码是否符合核心 CloudEvents 事件格式或协议绑定的关键标准是，该组是否同意该规范将为与协议或编码产生的产品或项目无关的任何一方带来持续的实际利益。这方面的一个基本要求是，协议或编码的定义方式必须允许独立于产品或项目的代码之外的替代实现。</p><hr><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>本节介绍了一些解释CloudEvents价值的用例。</p><ul><li>跨服务和平台的事件规范化</li></ul><p>主要的事件发布商（如AWS、微软、谷歌等）都在各自的平台上以不同的格式发布事件。甚至有少数情况下，同一提供商上的服务以不同的格式发布事件（如AWS）。这就迫使事件消费者不得不实施自定义逻辑，以实现跨平台、偶尔跨服务在单一平台上读取或合并事件数据。CloudEvents 可以为处理跨平台和跨服务的事件的消费者提供单一体验。</p><ul><li>促进跨服务和平台的集成</li></ul><p>事件数据跨环境传输的情况越来越普遍。然而，如果没有一种通用的描述事件的方式，事件的跨环境传输就会受到阻碍。没有单一的方法来确定事件的来源和可能的去向。这就阻碍了促进事件成功交付的工具化，也阻碍了消费者知道如何处理事件数据。CloudEvents 提供了有用的元数据，中间件和消费者可以依赖这些元数据来促进事件的路由、记录、传递和接收。</p><ul><li>提高FaaS的可移植性</li></ul><p>FaaS（也称无服务器计算）是IT领域发展最快的趋势之一，它主要是由事件驱动的。然而，FaaS的一个主要问题是供应商的锁定问题。这种锁定部分是由各供应商之间的函数API和签名的差异造成的，但这种锁定也是由函数内部接收事件数据的格式差异造成的。CloudEvents 对事件数据的通用描述方式提高了FaaS的可移植性。</p><ul><li>改进事件驱动/无服务器架构的开发和测试工作</li></ul><p>由于缺乏通用的事件格式，使得事件驱动和无服务器架构的开发和测试变得复杂化。没有简单的方法可以准确地模拟事件用于开发和测试，并帮助在开发环境中模拟事件驱动的工作流程。CloudEvents可以使开发人员有更好的工具来构建、测试和处理事件驱动和无服务器架构的端到端生命周期。</p><ul><li>事件数据演变</li></ul><p>大多数平台和服务对其事件的数据模型进行了不同的版本（如果他们根本不这么做的话）。这为发布和消费事件的数据模型创造了不一致的体验，因为这些数据模型在不断发展。CloudEvents 可以提供一种通用的方式来版本化和演进事件数据。这将帮助事件发布者根据最佳实践安全地对其数据模型进行版本化，这将帮助事件消费者在事件数据演进过程中安全地使用事件数据。</p><ul><li>规范化Webhooks</li></ul><p>Webhooks是一种没有使用通用格式的事件发布方式。Webhooks 的消费者没有一致的方式来开发、测试、识别、验证和整体处理通过 Webhooks 传递的事件数据。CloudEvents 可以为 webhook 发布和消费提供一致性。</p><ul><li>政策执行</li></ul><p>处于安全和策略的考虑，系统之间的事件的传送可能需要过滤、转换或阻止。例如，为了防止事件的进入或流出，如事件数据包含敏感信息或希望禁止发送方和接收方之间的信息流。</p><p>一个通用的事件格式将使人们更容易推理正在流转的数据，并允许对数据进行更好的反省。</p><ul><li>事件追踪</li></ul><p>从源发送的事件可能会导致从各种中间件设备（如事件代理和网关）发送的附加事件序列。CloudEvents 包含事件中的元数据，可将这些事件作为事件序列的一部分进行关联，以进行事件追踪和故障排除。</p><ul><li>IoT / 物联网</li></ul><p>物联网设备会发送和接收与其函数相关的事件。例如，一个连接的恒温器将发送关于当前温度的遥测数据，并可以接收改变温度的事件。这些设备通常有一个受限制的操作环境（CPU、内存），需要一个定义良好的事件消息格式。在很多情况下，这些消息是二进制编码的，而不是文本的。无论是直接来自设备还是通过网关转换，CloudEvents 都可以更好地描述消息的来源和消息中包含的数据格式。</p><ul><li>事件的关联性</li></ul><p>一个无服务器的应用程序/工作流可以与来自不同事件源/生产者的多个事件相关联。例如，一个防盗侦测应用/工作流可能同时涉及一个运动事件和一个门窗打开事件。一个无服务器平台可以接收到许多不同类型事件的实例，例如，它可以接收来自不同房屋的运动事件和门窗打开事件。无服务器平台需要将一种类型的事件实例与其他类型的事件实例正确关联，并将接收到的事件实例映射到正确的应用/工作流实例。CloudEvents 将为任何事件消费者（如无服务器平台）提供一种标准的方法，以便在事件数据中找到事件关联信息/标记，并将接收到的事件实例映射到正确的应用/工作流实例。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;事件无处不在。然而，事件生产者倾向于以不同的方式来描述事件。&lt;/p&gt;
&lt;p&gt;缺乏通用的描述事件的方式意味着开发人员必须不断地重新学习如何消费事件。这也限制了类库、工具和基础设施在跨环境时发送事件数据的潜力，如SDK、事件路由器或跟踪系统等。我们从事件数据中实现的可移植性和生产力总体上受到了阻碍。CloudEvents是一个用通用格式描述事件数据的规范，以提供跨服务、跨平台和跨系统的互操作性。CloudEvents得到了大量的行业关注，从主要的云提供商到流行的SaaS公司都有。CloudEvents由云原生计算基金会（CNCF）主办，于2018年5月15日获批为云原生沙盒级项目。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>CloudEvents知多少</title>
    <link href="https://ustack.io/2020-06-30-CloudEvents%E7%9F%A5%E5%A4%9A%E5%B0%91.html"/>
    <id>https://ustack.io/2020-06-30-CloudEvents知多少.html</id>
    <published>2020-06-30T13:40:08.000Z</published>
    <updated>2020-06-30T13:16:40.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents最初由CNCF Severless 工作组提出。</p></div><a id="more"></a><hr><h4 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h4><p>事件无处不在，然而事件发布者对事件的描述却往往不尽相同。</p><ul><li>一致性：缺乏通用的事件描述方式，意味着开发人员必须为每个事件源编写新的事件处理逻辑。</li><li>无障碍环境：没有通用的事件格式意味着没有通用的库、工具和基础设施来跨环境投递事件数据。CloudEvents提供了Go、JavaScript、Java、C#、Ruby和<br>Python的SDK，可用于构建事件路由器、跟踪系统和其他工具。</li><li>可移植性：整体上阻碍了我们从事件数据中实现的可移植性和生产力。</li></ul><h5 id="何为CloudEvents"><a href="#何为CloudEvents" class="headerlink" title="何为CloudEvents"></a>何为CloudEvents</h5><p>CloudEvents 是一个以通用方式描述事件数据的规范。CloudEvents旨在大幅简化跨服务、跨平台的事件声明和投递。</p><p>CloudEvents是一项新的工作，目前仍在积极开发中。然而，它的工作小组已经收到了令人惊讶的行业兴趣，从主要的云提供商到流行的SaaS公司都有。该规范现在由云原生计算基金会（Cloud Native Computing Foundation/CNCF）负责。</p><p>CloudEvents是通过CNCF的Serverless工作组组织的。</p><hr><h4 id="二、CloudEvents-1-0"><a href="#二、CloudEvents-1-0" class="headerlink" title="二、CloudEvents 1.0"></a>二、CloudEvents 1.0</h4><h5 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h5><p>CNCF Severless 工作组最初是由 CNCF 技术监督委员会创立的，旨在调查 Serverless 技术和指导 CNCF 在本领域下一步可能展开的相关工作的建议。其中一项建议是创建一个通用的 Event Format，以在不同云供应商提供的Function 之间实现可移植性和事件流处理的互操作性。CloudEvents 规范因此被创建出来。</p><h5 id="版本确立"><a href="#版本确立" class="headerlink" title="版本确立"></a>版本确立</h5><p>尽管 CloudEvents 的工作最初是作为 Serverless 工作组的一部分开展的，当规范到达 v0.1 里程碑之后，TOC 批准了 CloudEvents 成为一个独立的 CNCF 沙盒项目。2019年10月24日，CloudEvents项目取得了两项重大成果。第一，CNCF的技术监督委员会批准该项目成为 “孵化器 “项目（从而使其从CNCF的 “沙盒”毕业）。第二，CloudEvents规范发布了1.0版本!这是该规范的第一个主要版本，代表了整个serverless社区中一个真正伟大的团队两年来的努力工作。我们已经有几乎所有主要的云提供商参与其中，还有一些 “终端用户 “公司以及许多个人参与者，他们都在努力工作以制作出一个规范，希望在这一里程碑式的发展过程中，能够继续得到更多的采用。除了核心的CloudEvents规范外，还有Primer和协议及格式规范，所有这些都可以在GitHub repo中找到。此外，还有六种不同的SDK-Go、JavaScript、Java、C#、Ruby和Python，帮助生产和消费CloudEvents。CNCF Serverless工作组将决定下一步的工作重点（例如，额外的CloudEvents相关活动，或者解决社区正在经历的其他互操作性痛点）。</p><h5 id="集成现状"><a href="#集成现状" class="headerlink" title="集成现状"></a>集成现状</h5><p><img src="https://s1.ax1x.com/2020/06/04/tB4PzD.md.png" alt></p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">cloudevent</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents最初由CNCF Severless 工作组提出。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>CloudEvents核心规范之三</title>
    <link href="https://ustack.io/2020-06-17-CloudEvents%E6%A0%B8%E5%BF%83%E8%A7%84%E8%8C%83%E4%B9%8B%E4%B8%89.html"/>
    <id>https://ustack.io/2020-06-17-CloudEvents核心规范之三.html</id>
    <published>2020-06-17T13:40:08.000Z</published>
    <updated>2020-06-07T03:18:06.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF<br>Severless 工作组提出。本文档的目的是描述针对CloudEvents的新软件开发工具包（SDK）的最低要求。这些SDK的设计和实施是为了增强和加快CloudEvents<br>的集成。作为社区工作的一部分，CloudEvents团队承诺支持和维护以下SDK。</p></div><a id="more"></a><hr><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>本文档旨在为 SDK 作者提供指导和要求。本文档旨在与 CloudEvents 规范保持同步更新。当前提供以下语言的SDK:</p><ul><li>CSharp</li><li>Go SDK</li><li>Java SDK</li><li>JavaScript SDK</li><li>Python SDK</li><li>Ruby SDK</li></ul><h3 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h3><p>每个SDK必须满足这些要求。</p><ul><li>支持CloudEvents 的里程碑版本和正在进行的开发版本。<ul><li>将Canonical Event编码为特定于传输的编码消息。</li><li>将特定于传输的编码消息解码为Canonical事件。</li></ul></li><li>熟练使用编程语言。<ul><li>使用当前的语言版本。</li></ul></li><li>支持结构化和二进制编码的HTTP传输渲染。</li></ul><h3 id="对象模型结构准则"><a href="#对象模型结构准则" class="headerlink" title="对象模型结构准则"></a>对象模型结构准则</h3><p>每个SDK将提供一个通用的CloudEvents类/对象/结构，该类/对象/结构表示事件的典型形式。</p><p>该 SDK 应使用户能够绕过 CloudEvents Event 对象的特定传输编码和解码。对象的一般流程应该是：</p><p>Event (-&gt; Message) -&gt; Transport</p><p>和</p><p>Transport (-&gt; Message) -&gt; Event</p><p>不需要SDK来实现传输的包装器，重点应该是允许编程模型与高层次的Event对象一起工作，并提供工具将Event转化成可以与所选的实现传输一起使用的东西。</p><p>在高层次上，SDK需要能够帮助完成以下任务。</p><ul><li>组合事件。</li><li>编码事件，给定传输和编码（如果适当的话，将其编码为传输消息）。</li><li>解码特定于传输的消息、请求或响应（如果适当的话，到一个传输消息）为事件。</li></ul><p><strong><em>组合事件</em></strong></p><p>提供一种方便的方法，既可以组成单一消息，也可以组成许多消息。实现者将需要一种方法来快速建立事件数据并将其转换为CloudEvents编码的事件。在实践中，事</p><p>件的组成往往有两个方面。</p><ol><li>事件创建</li></ol><p>“我有一个格式不是CloudEvent的数据，我想让它成为CloudEvent。”</p><ol start="2"><li>事件变化</li></ol><p>“我有一个CloudEvents格式化的事件，我需要将它变成不同的事件。” “我有一个CloudEvents格式化的事件，我需要修改事件。”</p><p>对于SDK语言来说，事件的创建是非常习以为常的。</p><p>事件变化往往用访问器模式来解决，比如getters和setter。但是可以利用直接的 key 访问，也可以利用命名的 key 访问器函数。</p><p>无论是哪种情况，都必须有一个方法根据参数设置来验证生成的Event对象，最重要的是CloudEvents规范版本。</p><p><strong><em>对事件进行编码/解码</em></strong></p><p>每个SDK都支持对事件进行编码和解码。结构化编码是最容易支持的，因为它只是json，但二进制编码对于每个传输方式来说是相当定制的。</p><p><strong><em>数据</em></strong></p><p>从事件中访问数据有一些考虑，事件可以被编码成base64形式，作为结构化数据，或者像json这样的线上格式。一个SDK必须提供一种方法来将这些格式的数据解压成<br>原生格式。</p><p><strong><em>扩展</em></strong></p><p>支持CloudEventss的扩展又是成语，但镜像数据访问的方法似乎是可行的。</p><p><strong><em>验证</em></strong></p><p>验证必须在单个事件上进行。验证必须考虑到规格版本，以及每个版本的规格所提出的所有要求。</p><hr><h2 id="二、Golang示例"><a href="#二、Golang示例" class="headerlink" title="二、Golang示例"></a>二、Golang示例</h2><h3 id="处理依赖"><a href="#处理依赖" class="headerlink" title="处理依赖"></a>处理依赖</h3><p><strong><em>获取依赖</em></strong></p><p><code>go get github.com/cloudevents/sdk-go/v2@v2.0.0</code></p><p><strong><em>依赖引用</em></strong></p><p><code>import cloudevents &quot;github.com/cloudevents/sdk-go/v2&quot;</code></p><h3 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">cloudevents <span class="string">"github.com/cloudevents/sdk-go/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// The default client is HTTP.</span></span><br><span class="line">c, err := cloudevents.NewDefaultClient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to create client, %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an Event.</span></span><br><span class="line">event :=  cloudevents.NewEvent()</span><br><span class="line">event.SetSource(<span class="string">"example/uri"</span>)</span><br><span class="line">event.SetType(<span class="string">"example.type"</span>)</span><br><span class="line">event.SetData(cloudevents.ApplicationJSON, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a target.</span></span><br><span class="line">ctx := cloudevents.ContextWithTarget(context.Background(), <span class="string">"http://localhost:8080/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send that Event.</span></span><br><span class="line"><span class="keyword">if</span> result := c.Send(ctx, event); !cloudevents.IsACK(result) &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to send, %v"</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接受事件"><a href="#接受事件" class="headerlink" title="接受事件"></a>接受事件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">cloudevents <span class="string">"github.com/cloudevents/sdk-go/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(event cloudevents.Event)</span></span> &#123;</span><br><span class="line"><span class="comment">// do something with event.</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s"</span>, event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// The default client is HTTP.</span></span><br><span class="line">c, err := cloudevents.NewDefaultClient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to create client, %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(c.StartReceiver(context.Background(), receive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><strong><em>序列化为JSON</em></strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event := cloudevents.NewEvent()</span><br><span class="line">event.SetSource("example/uri")</span><br><span class="line">event.SetType("example.type")</span><br><span class="line">event.SetData(cloudevents.ApplicationJSON, map[string]string&#123;"hello": "world"&#125;)</span><br><span class="line"></span><br><span class="line">bytes, err := json.Marshal(event)</span><br></pre></td></tr></table></figure><p><strong><em>反序列化</em></strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event :=  cloudevents.NewEvent()</span><br><span class="line"></span><br><span class="line">err := json.Marshal(bytes, &amp;event)</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li><li><a href="https://cloudevents.github.io/sdk-go/" target="_blank" rel="noopener">go sdk</a></li><li><a href="https://github.com/cloudevents/sdk-go" target="_blank" rel="noopener">sdk-go</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF&lt;br&gt;Severless 工作组提出。本文档的目的是描述针对CloudEvents的新软件开发工具包（SDK）的最低要求。这些SDK的设计和实施是为了增强和加快CloudEvents&lt;br&gt;的集成。作为社区工作的一部分，CloudEvents团队承诺支持和维护以下SDK。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>CloudEvents核心规范之二</title>
    <link href="https://ustack.io/2020-06-16-CloudEvents%E6%A0%B8%E5%BF%83%E8%A7%84%E8%8C%83%E4%B9%8B%E4%BA%8C.html"/>
    <id>https://ustack.io/2020-06-16-CloudEvents核心规范之二.html</id>
    <published>2020-06-16T13:40:08.000Z</published>
    <updated>2020-06-07T03:03:05.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF<br>Severless 工作组提出。CloudEvents 的 HTTP 协议绑定定义了如何将事件映射到 HTTP 1.1 请求和响应消息。</p></div><a id="more"></a><hr><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CloudEvents是事件的结构和元数据描述的标准化且与协议无关的定义。该规范定义了如何在HTTP 1.1请求和响应消息中使用CloudEvents规范中定义的元素。</p><h3 id="与HTTP的关系"><a href="#与HTTP的关系" class="headerlink" title="与HTTP的关系"></a>与HTTP的关系</h3><p>本规范没有规定约束特定HTTP方法的使用或处理规则，也没有约束用于传输或请求事件的HTTP目标资源。</p><p>事件可以通过所有支持有效载荷体传输的标准或应用程序定义的HTTP请求方法来传输。事件也可以在HTTP响应中以及与允许有效载荷体传输的所有HTTP状态码一起传输。</p><p>这里所有显示HTTP方法、HTTP目标URI和HTTP状态码的例子都是非规范性的说明。</p><p>本规范也同样适用于与 HTTP 1.1语义兼容的 HTTP/2（RFC7540）。</p><blockquote><p>也适用于HTTP/2</p></blockquote><h3 id="内容模式"><a href="#内容模式" class="headerlink" title="内容模式"></a>内容模式</h3><p>本规范定义了传输事件的三种内容模式：二进制（binary）、结构化（structured）和批量（batched）。每个符合规范的实现都应该支持二进制（binary）和结</p><p>构化（structured）模式。</p><ul><li>在二进制内容模式下，事件 data 的值被放置到HTTP请求或响应的主体（body）中，并在HTTP Content-Type header中以 datacontenttype属性的值声明其</li></ul><p>媒体类型；所有其他事件属性都被映射到HTTP头。</p><ul><li><p>在结构化内容模式下，事件元数据属性和事件数据被放置到HTTP请求或响应body中，使用事件格式。</p></li><li><p>在批量内容模式中，多个事件使用支持批量的事件格式，分批放入单个HTTP请求或响应body中。</p></li></ul><h3 id="事件格式"><a href="#事件格式" class="headerlink" title="事件格式"></a>事件格式</h3><p>与结构化内容模式一起使用的事件格式，定义了事件如何以特定的数据格式表达。本规范的所有实现必须支持非批处理的JSON事件格式，但也可以支持任何其他格式，包括专有格式。</p><p>事件格式可以额外定义事件批处理的表达方式。这些格式可以与批处理内容模式一起使用。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>本规范没有为HTTP引入任何新的安全特性，也没有规定要使用特定的现有特性。本规范同样适用于TLS上的HTTP。</p><hr><h2 id="二、CloudEvents-属性的使用"><a href="#二、CloudEvents-属性的使用" class="headerlink" title="二、CloudEvents 属性的使用"></a>二、CloudEvents 属性的使用</h2><p>本规范没有进一步定义任何核心 CloudEvents 事件属性。</p><p>此映射是为了防止变化（包括事件属性的添加和删除），并适应供应商对事件元数据的扩展。</p><h3 id="datacontententtype-属性"><a href="#datacontententtype-属性" class="headerlink" title="datacontententtype 属性"></a>datacontententtype 属性</h3><p>datacontententtype属性被认为包含一个符合RFC2046的媒体类型表达式。</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data 被假定为包含由 datacontenttype 属性声明的不透明的应用数据。</p><p>应用程序可以自由地以其选择的任何内存中的表示方式来保存信息，但是由于该值是按照本规范中的定义被转接到HTTP中的，因此假设 data 的值是以字节序列的形式</p><p>提供的。</p><p>例如，如果声明的 datacontenttype 为 application/json;charset=utf-8，则期望 data 值以 UTF-8 编码的JSON文本形式提供给HTTP。</p><hr><h2 id="三、HTTP消息映射"><a href="#三、HTTP消息映射" class="headerlink" title="三、HTTP消息映射"></a>三、HTTP消息映射</h2><p>HTTP请求和响应消息的事件绑定是相同的。</p><p>内容模式是由事件的发送方选择的，发送方可以是请求方或响应方。可能允许使用特定模式请求事件的手势可能是由应用程序定义的，但这里没有定义。除非被邀约，</p><p>否则不能使用批量模式，而且手势应该允许接收方选择最大的批处理量。</p><p>事件的接收方可以通过检查 Content-Type header 的值来区分这三种模式。如果该值前缀为 CloudEvents 媒体类型 application/cloudevents，表示使</p><p>用已知的事件格式，则接收方使用结构化模式。如果该值前缀为 application/cloudevents-batch，则接收器使用批处理模式。否则，则默认为二进制模式。</p><blockquote><p>默认是使用二进制模式</p></blockquote><p>如果接收器检测到 CloudEvents 媒体类型，但它无法处理的事件格式（例如 application/cloudevents+avro），它仍然可以将事件作为二进制模式处理，并</p><p>将其转发到另一方。</p><h3 id="二进制内容模式"><a href="#二进制内容模式" class="headerlink" title="二进制内容模式"></a>二进制内容模式</h3><p>二进制的内容模式可以容纳任何形状的事件数据，并允许高效传输，无需转码。</p><p><strong><em>HTTP Content Type</em></strong></p><p>对于二进制模式，HTTP Content-Type header值对应于（必须从 CloudEvents datacontenttype 属性中填充或写入）CloudEvents datacontenttype </p><p>属性。请注意 ce-datacontenttype HTTP 标头不能也存在于消息中。</p><p><strong><em>事件数据编码</em></strong></p><p>data 字节序列作为HTTP报文Body。</p><p><strong><em>Metadata headers</em></strong></p><p>所有其他 CloudEvents 属性（包括扩展）必须单独映射到不同的 HTTP 消息头，并从不同的 HTTP 消息头中映射。</p><p>定义了自己属性的 CloudEvents 扩展可以为这些属性定义二级映射到 HTTP 头，特别是当特定属性需要与 HTTP 特性或其他有明确 HTTP 头绑定的规范保持一致</p><p>时。请注意，这些属性还必须作为带有 ce 前缀的 HTTP 标头出现在 HTTP 报文中，如 HTTP 标头名称中所述。</p><p><strong><em>HTTP Header Names</em></strong></p><p>除注明的情况外，所有 CloudEvents 上下文属性（包括扩展）都必须映射到与属性名称相同但前缀为 ce 的 HTTP header中。</p><p>示例:</p><ul><li><code>time</code> maps to <code>ce-time</code></li><li><code>id</code> maps to <code>ce-id</code></li><li><code>specversion</code> maps to <code>ce-specversion</code></li></ul><blockquote><p>根据HTTP规范，header name是不区分大小写的</p></blockquote><p><strong><em>HTTP header值</em></strong></p><p>每个 HTTP header的值由相应属性类型的标准字符串表示法构建。</p><p>某些 CloudEvents 元数据属性可包含任意 UTF-8 字符串内容，HTTP 标头必须仅使用 US-ASCII 字符集中的可打印字符，并由 CRLF 序列终止，标头值周围</p><p>有可选的空白。中描述的 header 编码规则之前，必须按照RFC3986，第2.4节中描述的百分比编码，对字符串值进行百分比编码。</p><p>将 HTTP 报文解码为 CloudEvent 时，必须反向应用这些规则 – RFC7230 第 3.2.6 节对 ASCII 字符串进行解码，然后按照 RFC3986 第 2.4 节中的描</p><p>述进行单轮百分比解码，以生成有效的 UTF-8 字符串。(注意，应用百分比解码的次数不正确可能导致报文损坏或安全问题)。</p><p><strong><em>Examples</em></strong></p><p>这个例子显示了带有HTTP POST请求的事件与的二进制模式映射：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /someresource HTTP/1.1</span><br><span class="line">Host: webhook.example.com</span><br><span class="line">ce-specversion: 1.0</span><br><span class="line">ce-type: com.example.someevent</span><br><span class="line">ce-time: 2018-04-05T03:56:24Z</span><br><span class="line">ce-id: 1234-1234-1234</span><br><span class="line">ce-source: /mycontext/subcontext</span><br><span class="line">    .... further attributes ...</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ... application data ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子显示了包含事件的响应：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ce-specversion: 1.0</span><br><span class="line">ce-type: com.example.someevent</span><br><span class="line">ce-time: 2018-04-05T03:56:24Z</span><br><span class="line">ce-id: 1234-1234-1234</span><br><span class="line">ce-source: /mycontext/subcontext</span><br><span class="line">    .... further attributes ...</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ... application data ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>结构化内容模式</em></strong><br>结构化的内容模式将事件元数据和数据保持在有效载荷中，使得同一事件可以在多个路由跳转、多协议之间简单转发。</p><h3 id="HTTP内容类型"><a href="#HTTP内容类型" class="headerlink" title="HTTP内容类型"></a>HTTP内容类型</h3><p>HTTP内容类型头必须设置为事件格式的媒体类型。</p><blockquote><p>JSON 格式的示例。</p></blockquote><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/cloudevents+json; charset=UTF-8</span><br></pre></td></tr></table></figure><h3 id="事件数据编码"><a href="#事件数据编码" class="headerlink" title="事件数据编码"></a>事件数据编码</h3><p>所选择的事件格式定义了所有属性和数据的表示方式。</p><p>然后按照事件格式规范对事件元数据和数据进行渲染，最后得到的数据成为HTTP报文body。</p><h3 id="metadata-header"><a href="#metadata-header" class="headerlink" title="metadata header"></a>metadata header</h3><p>实现可以包含与二进制模式定义的相同的 HTTP 标头。</p><p>所有 CloudEvents 元数据属性都必须映射到有效载荷（Payload）中，即使它们也已经映射到 HTTP header中了。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这个例子显示了一个JSON事件格式编码的事件，用PUT请求发送：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /myresource HTTP/1.1</span><br><span class="line">Host: webhook.example.com</span><br><span class="line">Content-Type: application/cloudevents+json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "specversion" : "1.0",</span><br><span class="line">    "type" : "com.example.someevent",</span><br><span class="line"></span><br><span class="line">    ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">    "data" : &#123;</span><br><span class="line">        ... application data ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子显示了一个响应中返回的JSON编码的事件：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/cloudevents+json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "specversion" : "1.0",</span><br><span class="line">    "type" : "com.example.someevent",</span><br><span class="line"></span><br><span class="line">    ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">    "data" : &#123;</span><br><span class="line">        ... application data ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量内容模式"><a href="#批量内容模式" class="headerlink" title="批量内容模式"></a>批量内容模式</h3><p>在批量内容模式下，多个事件被批量到一个HTTP请求或响应体中。选择的事件格式必须定义如何表示一个批次。基于JSON格式（任何兼容的实现都必须支持JSON格式），</p><p>JSON Batch格式是一种支持批处理的事件格式。</p><p><strong><em>HTTP 内容类型</em></strong></p><p>HTTP Content-Type头必须设置为事件格式的媒体类型。</p><p>JSON Batch 格式的示例。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/cloudevents-batch+json; charset=UTF-8</span><br></pre></td></tr></table></figure><p><strong><em>事件数据编码</em></strong></p><p>所选的事件格式定义了一批事件和所有事件属性和数据的表示方式。</p><p>然后根据事件格式规范对事件批进行渲染，结果数据将成为HTTP消息主体。</p><p>该批事件可以是空的。所有批处理的 CloudEvents 必须具有相同的 specversion 属性。其他属性可能不同，包括 datacontententtype 属性。</p><p><strong><em>示例</em></strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT /myresource HTTP/1.1</span><br><span class="line">Host: webhook.example.com</span><br><span class="line">Content-Type: application/cloudevents-batch+json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "specversion" : "1.0",</span><br><span class="line">        "type" : "com.example.someevent",</span><br><span class="line"></span><br><span class="line">        ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">        "data" : &#123;</span><br><span class="line">            ... application data ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "specversion" : "1.0",</span><br><span class="line">        "type" : "com.example.someotherevent",</span><br><span class="line"></span><br><span class="line">        ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">        "data" : &#123;</span><br><span class="line">            ... application data ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/cloudevents-batch+json; charset=utf-8</span><br><span class="line">Content-Length: nnnn</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "specversion" : "1.0",</span><br><span class="line">        "type" : "com.example.someevent",</span><br><span class="line"></span><br><span class="line">        ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">        "data" : &#123;</span><br><span class="line">            ... application data ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "specversion" : "1.0",</span><br><span class="line">        "type" : "com.example.someotherevent",</span><br><span class="line"></span><br><span class="line">        ... further attributes omitted ...</span><br><span class="line"></span><br><span class="line">        "data" : &#123;</span><br><span class="line">            ... application data ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="四、json事件格式"><a href="#四、json事件格式" class="headerlink" title="四、json事件格式"></a>四、json事件格式</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>本节定义了 CloudEvents 属性如何映射到 JSON。本规范没有明确映射每个属性，但提供了一个通用映射模型，该模型适用于所有当前和未来的 CloudEvents </p><p>属性（包括扩展）。</p><p>为明确起见，扩展属性使用与规范定义的属性相同的规则进行序列化。这包括其语法和在 JSON 对象中的位置。特别是，扩展作为顶层 JSON 属性放置。扩展必须被</p><p>序列化为顶层JSON属性。</p><p><strong><em>Type System Mapping</em></strong></p><p>扩展规范可以为其定义的属性值定义二次映射规则，但必须包括之前定义的主映射。</p><p>例如，属性值可能是在 CloudEvents 以外的标准中定义的数据结构，具有正式的 JSON 映射，如果不保留原始格式，可能会有翻译错误或信息丢失的风险。</p><p>定义了 JSON 次要映射规则的扩展规范，以及对该规范的任何修订，都必须为提交或修订时属于 CloudEvents 核心的所有其他事件格式定义明确的映射规则。</p><p>如果需要，例如在解码地图时，CloudEvents 类型可以通过使用映射表中的规则进行推理来确定，其中唯一潜在的模糊 JSON 数据类型是字符串。当满足映射规则时，</p><p>该值与相应的 CloudEvents 类型兼容。</p><h3 id="Envelope"><a href="#Envelope" class="headerlink" title="Envelope"></a>Envelope</h3><p>每个 CloudEvents 事件可以完全表示为一个 JSON 对象。</p><p>这种表示方式必须使用媒体类型 application/cloudevents+json。</p><p>给定事件中的所有 REQUIRED 和所有未省略的 OPTIONAL 属性必须成为 JSON 对象的成员，相应的 JSON 对象成员名称与属性名称相匹配，并且成员的类型和值</p><p>使用类型系统映射。</p><p><strong><em>对 “data”的处理</em></strong></p><p>在采取行动之前，JSON序列化器必须首先确定数据内容的运行时数据类型。</p><p>如果实现确定数据类型为二进制，则必须将值表示为包含Base64编码的二进制值的JSON字符串表达式，并使用成员名data_base64将其存储在JSON对象中。</p><p>对于任何其他类型，实现必须将数据值转换为JSON值，并使用成员名data_base64来存储在JSON对象中。</p><p>由此可见，在 JSON 序列化的 CloudEvent 中，数据和 data_base64 成员的使用是相互排斥的。</p><p>当从 JSON 中解串化 CloudEvents 时，data_base64 成员的存在清楚地表明该值是 Base64 编码的二进制数据，序列化器必须将其解码为二进制的运行时数据</p><p>类型。当数据成员存在时，它将使用默认的JSON类型映射来解码，用于使用的运行时。</p><p>与属性不同的是，根据类型系统映射，值类型被限制为字符串，而产生的数据成员JSON值是不受限制的，可以包含任何有效的JSON。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF&lt;br&gt;Severless 工作组提出。CloudEvents 的 HTTP 协议绑定定义了如何将事件映射到 HTTP 1.1 请求和响应消息。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>CloudEvents核心规范之一</title>
    <link href="https://ustack.io/2020-06-15-CloudEvents%E6%A0%B8%E5%BF%83%E8%A7%84%E8%8C%83%E4%B9%8B%E4%B8%80.html"/>
    <id>https://ustack.io/2020-06-15-CloudEvents核心规范之一.html</id>
    <published>2020-06-15T13:40:08.000Z</published>
    <updated>2020-06-06T11:19:59.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF<br>Severless 工作组提出。</p></div><a id="more"></a><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>事件无处不在。然而，事件生产者往往会以不同的方式来描述事件。</p><p>缺乏描述事件的常用方法意味着开发人员必须不断重新学习如何接收事件。这也限制了库，工具和基础设施的可能性，以帮助跨环境（如SDK，事件路由器或跟踪系统）</p><p>发送事件数据。我们可以从事件数据中实现的可移植性和生产力总体上受到阻碍。</p><p>CloudEvents 是一种用通用格式描述事件数据的规范，以提供跨服务、平台和系统的互操作性。</p><p>事件格式指定了如何用特定的编码格式对 CloudEvents 进行序列化。支持这些编码的 CloudEvents 实现必须遵守相应事件格式中指定的编码规则。所有实现都必</p><p>须支持 JSON 格式。</p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>CloudEvents通常用于分布式系统，以允许服务在开发期间松散耦合，独立部署，以后可以连接以创建新应用程序。</p><p>CloudEvents规范的目标是定义事件系统的互操作性，这些事件系统允许服务生成或消费事件，其中生产者和消费者可以独立开发和部署。生产者可以在消费者收听之</p><p>前生成事件，并且消费者可以表达对尚未生成的事件或事件类别的兴趣。</p><p>为此，规范将包括促进互操作性的事件的公共元数据属性，而事件不包含可能用于发送事件的消费者或传输的任何细节。</p><h3 id="非目标"><a href="#非目标" class="headerlink" title="非目标"></a>非目标</h3><p>以下内容不在规范中：</p><ul><li>函数构建和调用过程</li><li>特定于语言的运行时API</li><li>选择单一身份/访问控制系统</li></ul><hr><h2 id="二、符号和术语"><a href="#二、符号和术语" class="headerlink" title="二、符号和术语"></a>二、符号和术语</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>为了清楚起见，当一个功能被标记为 “可选/OPTIONAL “时，这意味着消息的生产者和消费者都可以选择支持该功能。换句话说，如果生产者愿意，可以选择将该功能</p><p>包含在消息中，如果消费者愿意，可以选择支持该功能。那么不支持该功能的消费者就会默默地忽略消息中的那部分内容。生产者需要为消费者忽略该功能的情况做好准</p><p>备。中间人应该转发选择性属性。</p><p><strong><em>Occurrence/发生</em></strong></p><p>“发生/occurrence”是指在软件系统运行过程中捕捉到的事实陈述。这可能是由于系统引发的信号或系统观察到的信号、状态变化、计时器过期或任何其他值得注意的</p><p>活动而发生。例如，设备可能因为电池电量不足而进入警报状态，或者虚拟机即将执行预定的重启。</p><p><strong><em>Event/事件</em></strong></p><p>“事件/event”是表示发生(occurrence)及其上下文的数据记录。事件被从事件生产者（源）路由到感兴趣的事件消费者。可以根据事件中包含的信息进行路由，但<br>事件不会确定具体的路由目的地。事件将包含两类信息：事件数据（Event Data）代表发生(occurrence)，而上下文元数据（Context metadata）提供关于发<br>生(occurrence)的上下文信息。一个发生(occurrence)可能会产生多个事件。</p><p><strong><em>Producer/生产者</em></strong></p><p>“Producer/生产者”是特定实例、过程或设备，用于创建描述 CloudEvent 的数据结构。</p><p><strong><em>Source/来源</em></strong></p><p>“Source/来源”是指发生(occurrence)出现的上下文。在一个分布式系统中，它可能由多个Producer组成。如果一个源不知道CloudEvents，外部生产者代表源<br>创建CloudEvents。</p><p><strong><em>Consumer/消费者</em></strong></p><p>“Consumer/消费者”接收到事件，并对其采取行动。它使用上下文和数据来执行一些逻辑，这可能导致新事件的发生。</p><p><strong><em>中介机构</em></strong></p><p>“中介机构/Intermediary”接收包含事件的消息，目的是将其转发给下一个接收者，而这个接收者可能是另一个中间人或消费者。中间人的一个典型任务是根据上下<br>文中的信息将事件转发到接收者。</p><p><strong><em>Context/上下文</em></strong></p><p>上下文元数据将被封装在上下文属性(Context Attributes)中。工具和应用程序代码可以使用这些信息来识别事件与系统的各个方面或与其他事件的关系。</p><p><strong><em>数据</em></strong></p><p>有关事件（即payload/有效载荷）的特定领域信息。这可能包括有关发生(occurrence)的信息、有关被更改的数据的详细信息或更多信息。有关更多信息，请参阅<br>事件数据(Event Data)部分。</p><p><strong><em>事件格式 / Event Format</em></strong></p><p>事件格式指定了如何将 CloudEvent 序列化为字节序列。独立的事件格式（如 JSON 格式）可指定独立于任何协议或存储介质的序列化。协议绑定可以定义依赖于协<br>议的格式。</p><p><strong><em>Message/消息</em></strong></p><p>事件通过消息从源（Source）传输到目的地（Destination）。</p><p>“结构化模式报文/structured-mode message” 是指使用独立的事件格式对事件进行完全编码并存储在消息主体中。</p><p>“二进制模式报文/binary-mode message” 是指事件数据（event data）存储在消息体中，事件属性作为消息元数据的一部分存储。</p><p><strong><em>Data/数据</em></strong></p><p>关于发生/occurrence（如有效载荷）的领域特定信息。这可能包括有关发生的信息，有关已更改数据的详细信息或更多。</p><p><strong><em>Protocol/协议</em></strong></p><p>消息可以通过各种行业标准协议（例如HTTP，AMQP，MQTT，SMTP），开源协议（例如Kafka，NATS）或平台/供应商特定协议（AWS Kinesis，Azure Event Grid）来传递。</p><p><strong><em>Protocol Binding/协议绑定</em></strong></p><p>协议绑定描述了事件如何通过给定协议发送和接收事件，特别是事件如何映射到该协议中的消息。</p><h3 id="上下文属性"><a href="#上下文属性" class="headerlink" title="上下文属性"></a>上下文属性</h3><p>符合本规范的每个 CloudEvent 必须包含上下文属性，而且要指定为 REQUIRED，可以包含一个或多个 OPTIONAL 上下文属性，也可以包含一个或多个扩展属性。</p><p>这些属性在描述事件的同时，被设计为可以 独立于事件数据进行序列化。这使得它们可以在目的地被检查，而不需要对事件数据进行反序列化。</p><p><strong><em>属性命名约定</em></strong></p><p>CloudEvents 规范定义了对各种协议和编码的映射，随附的 CloudEvents SDK 针对各种运行时和语言。其中有些将元数据元素视为大小写敏感，而另一些则不敏</p><p>感，而且单个 CloudEvents 可能会通过多个跳转来实现，中间涉及协议、编码和运行时。因此，本规范限制了所有属性的可用字符集，以防止大小写敏感问题或与通</p><p>用语言中标识符的允许字符集冲突。</p><p>CloudEvents 属性名称必须由 ASCII 字符集中的小写字母（’a’至’z’）或数字（’0’至’9’）组成。属性名称应具有描述性和简洁性，长度不得超过 20 个字符。</p><p><strong><em>类型系统</em></strong></p><p>以下是可用于属性中的抽象数据类型。这些类型中的每个类型都可以由不同的事件格式和协议元数据字段来表示。本规范为每个类型定义了一个标准的字符串编码，所有</p><p>的实现都必须支持。</p><ul><li><p>Boolean - 值为 “true “或 “false “的布尔值。</p><p>字符串编码：大小写敏感的 “true “或 “false” 值。</p></li><li><p>Integer -2,147,483,648到+2,147,483,647之间的整数。这是一个有符号的、32位的、二进制编码的范围。事件格式不一定要使用这个编码，但它们必须只<br>使用这个范围内的整数值。</p><p>字符串编码: 根据RFC 7159，第6节，JSON号码的整数部分。</p></li><li><p>String - 允许的Unicode字符序列。以下字符不允许使用。</p><ul><li>U+0000-U+001F 和 U+007F-U+009F (两个范围都包括在内)中的 “控制字符”，因为大多数字符没有约定的含义，有些字符，如 U+000A (换行符)，在HTTP </li></ul></li></ul><p>头等上下文中不能使用。</p><ul><li><p>代码点被Unicode识别为非字符。</p></li><li><p>U+D800-U+DBFF和U+DC00-U+DFFF，这两个范围都包括在内，除非正确地成对使用。因此，（在JSON符号中）”\uDEAD “是无效的，因为它是一个未配对的代<br>名词，</p></li></ul><p>而”\uD800\uDEAD “是合法的。</p><ul><li><p>Binary - 字节序列。</p><ul><li>字符串编码: Base64 编码，按照 RFC4648 的规定进行编码。</li></ul></li><li><p>URI–绝对统一的资源标识符。</p><ul><li>字符串编码：RFC4648中定义的绝对统一资源标识符。字符串编码：RFC 3986 第 4.3 节中定义的绝对 URI。</li></ul></li><li><p>URI-reference - 统一资源标识符引用。</p><ul><li>字符串编码：RFC 3986 第4.3 节中定义的URI-reference。URI-reference - RFC 3986 第4.1 节中定义的URI-reference。</li></ul></li><li><p>Timestamp - 使用Gregorian Calendar的日期和时间表达式。</p><ul><li>字符串编码：RFC 3339。</li></ul></li></ul><p>所有的上下文属性值必须是上面列出的类型之一。属性值可以以本地类型或标准字符串的形式呈现。表示 CloudEvent 或任何扩展的强类型编程模型必须能够将常规字</p><p>符串编码转换为最适合抽象类型的运行时/语言原生类型。</p><p>例如，在给定的实现中，时间属性可以用语言的本机日期时间类型来表示，但必须提供 RFC3339 字符串，并且在映射到 HTTP 消息的报文头时，必须可转换为 </p><p>RFC3339 字符串。</p><p>同样，CloudEvents 协议绑定或事件格式实现也必须能够在编码或协议元数据字段中将标准字符串编码转换为相应的数据类型。</p><p>时间戳类型的属性值确实可以作为一个字符串通过多次跳转，并且只在生产者和最终消费者那里以本地运行时/语言类型的形式实现。时间戳也可能被路由为本地协议</p><p>类型，并可能在生产者和消费者端被映射到/从各自的语言/运行时类型，而永远不会以字符串的形式实现。</p><p>序列化机制的选择将决定上下文属性和事件数据的序列化方式。例如，在JSON序列化的情况下，上下文属性和事件数据可能同时出现在同一个JSON对象中。</p><h3 id="必须的属性"><a href="#必须的属性" class="headerlink" title="必须的属性"></a>必须的属性</h3><p>以下属性必须在所有 CloudEvents 中出现。</p><p><strong><em>id</em></strong></p><ul><li>Type: String</li><li>描述: 标示事件。生产者必须确保 source + id 对于每个独立的事件都是唯一的。如果一个重复的事件被重新发送（例如，由于网络错误），它可能有相同的<br>id。消费者可能会认为 source 和 id 相同的事件是重复的。</li><li>Examples:<ul><li>由生产者维护的事件计数器</li><li>UUID</li></ul></li><li>Constraints:<ul><li>REQUIRED</li><li>必须是一个非空字符串</li><li>必须在生产者范围内是唯一的</li></ul></li></ul><p><strong><em>source</em></strong></p><ul><li><p>Type: URI-reference</p></li><li><p>Description: 标示事件发生的上下文。通常包括事件源的类型、发布事件的组织或产生事件的过程等信息。URI 中编码的数据背后的确切语法和语义由事件生<br>产者定义。</p><p>生产者必须确保 source + id 对于每个独立的事件都是唯一的。</p><p>应用程序可以为每个独立的生产者分配一个唯一的source，这样就很容易产生唯一的ID，因为没有其他生产者会有相同的source。应用程序可以使用 UUIDs、URNs、</p><p>DNS 权限或特定于应用程序的方案来创建唯一的source标识符。</p><p>一个源也可以包括多个的生产者。在这种情况下，生产者必须合作，确保 source + id 对于每个独立的事件都是唯一的。</p></li><li><p>Constraints:</p><ul><li>REQUIRED</li><li>非空URI-reference</li><li>推荐使用绝对URI<br>Examples</li></ul></li><li>全网唯一的URI，具有DNS权限。<ul><li><a href="https://github.com/cloudevents" target="_blank" rel="noopener">https://github.com/cloudevents</a></li><li>mailto:<a href="mailto:cncf-wg-serverless@lists.cncf.io" target="_blank" rel="noopener">cncf-wg-serverless@lists.cncf.io</a></li></ul></li><li>通用唯一的URN与UUID<ul><li>urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66</li></ul></li><li>应用特定的标识符<ul><li>/cloudevents/spec/pull/123</li><li>/sensors/tn-1234567/alerts</li><li>1-555-123-4567</li></ul></li></ul><p><strong><em>specversion</em></strong></p><ul><li>Type: String</li><li>Description: 事件所使用的 CloudEvents 规范的版本。该版本可用于解释上下文。兼容的事件制作者在引用此版本的规范时，必须使用 1.0 的值。</li><li>Constraints:<ul><li>REQUIRED</li><li>MUST be a non-empty string</li></ul></li></ul><p><strong><em>type</em></strong></p><ul><li>Type: String</li><li>Description: 该属性包含一个描述事件类型的值，描述与起源事件相关的事件类型。该属性通常用于路由、可观察性、策略执行等。该属性的格式是由生产者<br>定义的，可能包括类型的版本等信息–更多信息请参见Primer中的属性版本化。</li><li>Constraints:<ul><li>REQUIRED</li><li>MUST be a non-empty string</li><li>应该以一个反转的DNS名称为前缀。前缀域决定了定义这个事件类型的语义的组织。<br>Examples</li><li>com.github.pull.create</li><li>com.example.object.delete.v2</li></ul></li></ul><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>以下为可在 CloudEvents 中出现的可选属性。有关 OPTIONAL 定义的更多信息，请参阅 Notational Conventions 部分。</p><p><strong><em>datacontenttype</em></strong></p><ul><li>ype: String per RFC 2046</li><li>Description: data 值的内容类型。该属性使数据可以携带任何类型的内容，其格式和编码可能与所选事件格式不同。例如，使用JSON信封格式渲染的事件<br>可能会携带一个XML有效载荷的数据，这个属性被设置为 “application/xml “就会通知消费者。不同的数据内容如何渲染不同的数据内容类型值的规则在事件<br>格式规范中定义了；例如，JSON事件格式在3.1节中定义了这种关系。</li></ul><p>对于一些二进制模式的协议绑定，该字段直接映射到各自协议的内容类型元数据属性。二进制模式和内容类型元数据映射的规范性规则可以在相应的协议中找到。</p><p>在某些事件格式中，datacontententtype属性可能会被省略。例如，如果一个JSON格式的事件没有datacontententtype属性，那么就意味着数据是符合 </p><p>“application/json “媒体类型的JSON值。换句话说：一个没有datacontententtype的JSON格式事件与一个datacontenttype=“application/json “</p><p>的事件完全等同。</p><p>当将一个没有datacontenttype属性的事件消息翻译成不同的格式或协议绑定时，目标datacontenttype应该明确地设置为源的隐含datacontenttype。</p><ul><li>Constraints:<ul><li>OPTIONAL</li><li>如果存在，必须遵守RFC 2046中规定的格式。</li></ul></li></ul><p><strong><em>dataschema</em></strong></p><ul><li>Type: URI<br>指明 data 所遵循的 schema。对模式的不兼容的更改应该通过不同的URI来反映。更多信息请参见Primer中的属性版本化。</li><li>Constraints:<ul><li>OPTIONAL</li><li>If present, MUST be a non-empty URI</li></ul></li></ul><p><strong><em>subject</em></strong></p><ul><li><p>Type: String</p></li><li><p>Description: 描述了事件生产者（通过 source 标识）上下文中的事件主题。在发布-订阅场景中，订阅者通常会订阅由源发出的事件，但如果源上下文有<br>内部子结构，仅有源标识符可能不足以作为任何特定事件的限定符。</p><p>在上下文元数据中识别事件的主体（而不是仅在 data 有效载荷中），这在中间件无法解释 data 内容的通用订阅过滤场景中特别有帮助。在上面的例子中，订<br>阅者可能只对以’.jpg’或’.jpeg’结尾的blob感兴趣，而主题属性允许为该事件的子集构造一个简单有效的字符串后缀过滤器。</p></li><li><p>Constraints:</p><ul><li>OPTIONAL</li><li>If present, MUST be a non-empty string</li><li>Example:<br>当在blob-存储容器内创建新的blob时，订阅者可能会注册兴趣。在这种情况下，事件 source 标识了订阅范围（存储容器），type 标识了“blob创建“<br>事件，id唯一标识了事件实例，以区分已创建的相同名称的blob的单独出现；新创建的blob的名称在 subject中携带。<ul><li>source：<a href="https://example.com/storage/tenant/container" target="_blank" rel="noopener">https://example.com/storage/tenant/container</a></li><li>subject: mynewfile.jpg</li></ul></li></ul></li></ul><p><strong><em>time</em></strong></p><ul><li>Type: Timestamp</li><li>Description: 事件发生的时间戳。如果无法确定事件发生的时间，则该属性可以由 CloudEvents 生产者设置为其他时间（如当前时间），但同一源的所有<br>生产者在这方面必须保持一致。换句话说，它们要么都使用实际发生的时间，要么都使用相同的算法来确定所使用的值。</li><li>Constraints:<ul><li>OPTIONAL</li><li>If present, MUST adhere to the format specified in RFC 3339</li></ul></li></ul><h3 id="扩展上下文属性"><a href="#扩展上下文属性" class="headerlink" title="扩展上下文属性"></a>扩展上下文属性</h3><p>CloudEvent 可包含任意数量的具有不同名称的附加上下文属性，称为 “扩展属性”。扩展属性必须遵循与标准属性相同的命名惯例，并使用与标准属性相同的类型系<br>统。扩展属性在本规范中没有定义的含义，它们允许外部系统将元数据附加到事件中，就像HTTP自定义头一样。</p><p>扩展属性总是按照与标准属性一样的绑定规则进行序列化。然而，本规范并不妨碍扩展将事件属性值复制到消息的其他部分，以便与同样处理消息的非CloudEvents<br>系统进行交互。这样做的扩展规范应该指定如果复制的值与 cloud event 序列化的值不同，接收者应该如何解释消息。</p><h3 id="定义扩展"><a href="#定义扩展" class="headerlink" title="定义扩展"></a>定义扩展</h3><p>扩展的定义应该完全定义属性的所有方面，例如，其名称、类型、语义和可能的值。新的扩展定义应该使用一个描述性足够强的名称，以减少与其他扩展名称碰撞的</p><p>可能性。特别是，扩展作者应该检查文档中的扩展文档中的已知扩展集–不仅仅是检查可能的名称冲突，还应该检查可能感兴趣的扩展。</p><p>许多协议支持发送者包含附加元数据的能力，例如作为 HTTP 头文件。虽然 CloudEvents 接收方没有被强制要求处理和传递这些元数据，但建议他们通过某种机制</p><p>来处理和传递这些元数据，以表明它们是非 CloudEvents 元数据。</p><p>下面是一个例子，说明了对附加属性的需求。在许多 IoT 和企业用例中，一个事件可以在无服务器的应用程序中使用，该事件可以在多个类型的事件中执行操作。为了</p><p>支持这样的用例，事件生产者需要在 “上下文属性 “中添加额外的身份属性，事件消费者可以使用这些属性将该事件与其他事件关联起来。如果这种身份属性恰好是事件 </p><p>“数据 “的一部分，事件生产者也将把身份属性添加到 “上下文属性 “中，这样，事件消费者就可以方便地访问这些信息，而不需要解码和检查事件数据。这样的身份属</p><p>性也可以用来帮助中间网关确定如何路由事件。</p><p><strong><em>事件数据</em></strong></p><p>正如术语 “Data “所定义的那样，CloudEvents 可包括与事件发生相关的领域特定信息。如果存在，此信息将被封装在 data 中。</p><ul><li>描述：事件有效载荷（Payload）。本规范不对该信息的类型进行任何限制。它被编码成由datacontententtype属性指定的媒体格式（例如：application/json），<br>并且当这些相应的属性存在时，它将遵循dataschema格式。</li><li>Constraints:</li><li>OPTIONAL</li></ul><p><strong><em>大小限制</em></strong></p><p>在许多场景中，CloudEvents 将通过一个或多个通用中间人转发，每个中间人都可能会对转发事件的大小进行限制。CloudEvents 也可能会被转发到消费者，比如</p><p>嵌入式设备，这些设备受存储或内存限制，因此在处理大的单一事件时可能会很吃力。</p><p>事件的 “大小”是指事件的线上（wire-size）大小，包括事件的线上传输的每一个比特：协议帧元数据、事件元数据和事件数据，基于所选的事件格式和所选的协议</p><p>绑定。如果应用配置要求在不同的协议之间转发事件，或要求对事件进行重新编码，则应考虑应用所使用的最有效的协议和编码，以符合这些大小限制。</p><ul><li>中间商必须转发大小为64KByte或以下的事件。</li><li>消费者应接受至少64 KByte大小的事件。</li></ul><p>实际上，这些规则将允许生产者安全地发布大小不超过64KB的事件。这里的 “安全 “指的是，一般来说，期望事件被所有中间人接受并转发是合理的。出于本地的考虑，</p><p>它是否愿意接受或拒绝该大小的事件，是在任何特定消费者的控制范围内。</p><p>一般来说，CloudEvents 发布者应该通过避免在事件有效载荷中嵌入大型数据项来保持事件的紧凑性，而是使用事件有效载荷链接到这些数据项。从访问控制的角度</p><p>来看，这种方法还可以让事件的分布范围更广，因为通过解析链接访问事件相关的细节，可以实现差异化的访问控制和选择性的披露，而不是直接将敏感细节嵌入事件中。</p><h3 id="隐私和安全"><a href="#隐私和安全" class="headerlink" title="隐私和安全"></a>隐私和安全</h3><p>互操作性是本规范背后的主要驱动力，要实现这样的行为，需要将一些信息公开，导致信息泄露的可能性。请考虑以下几点，以防止不经意间的泄漏，特别是在利用第三</p><p>方平台和通信网络时。</p><ul><li><p>上下文属性</p><p>敏感信息不应在上下文属性中携带或表示。</p><p>CloudEvent 生产者、消费者和中间人可以审查并记录上下文属性。</p></li><li><p>Data</p><p>领域特定 event data 应进行加密，以限制受信任方的可见性。用于这种加密的机制是生产者和消费者之间的协议，因此不属于本规范的范围。</p></li><li><p>Protocol Bindings</p><p>应采用协议级的安全性，以确保CloudEvents的可信和安全交换。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的示例展示了一个被序列化为JSON的CloudEvent：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"specversion"</span> : <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="attr">"type"</span> : <span class="string">"com.github.pull.create"</span>,</span><br><span class="line">    <span class="attr">"source"</span> : <span class="string">"https://github.com/cloudevents/spec/pull"</span>,</span><br><span class="line">    <span class="attr">"subject"</span> : <span class="string">"123"</span>,</span><br><span class="line">    <span class="attr">"id"</span> : <span class="string">"A234-1234-1234"</span>,</span><br><span class="line">    <span class="attr">"time"</span> : <span class="string">"2018-04-05T17:31:00Z"</span>,</span><br><span class="line">    <span class="attr">"comexampleextension1"</span> : <span class="string">"value"</span>,</span><br><span class="line">    <span class="attr">"comexampleothervalue"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"datacontenttype"</span> : <span class="string">"text/xml"</span>,</span><br><span class="line">    <span class="attr">"data"</span> : <span class="string">"&lt;much wow=\"xml\"/&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;CloudEvents是一种以通用方式描述事件数据的规范。CloudEvents旨在简化跨服务，平台及其他方面的事件声明和发送。CloudEvents　最初由　CNCF&lt;br&gt;Severless 工作组提出。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless函数小解</title>
    <link href="https://ustack.io/2020-06-12-Serverless%E5%87%BD%E6%95%B0%E5%B0%8F%E8%A7%A3.html"/>
    <id>https://ustack.io/2020-06-12-Serverless函数小解.html</id>
    <published>2020-06-12T13:40:08.000Z</published>
    <updated>2020-06-21T12:55:23.176Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/06/21/N8MiqS.md.png" alt></p><div class="note info"><p>本文介绍当前serverless框架的函数概念，Serverless框架还允许用户监视代码存储库中的更改（例如代码触发器等），并在每次提交时自动构建函数镜像。函数代码、依赖项和/或二进制文件可以驻留在外部存储库（例如S3对象存储桶或Git存储库）中，或由用户直接提供。如果代码在外部存储库中，则用户需要指定路径和接入凭证。函数可能依赖于外部库或二进制文件，这些需要由用户提供，包括描述其构建过程的方式（例如，使用 Dockerfile、Zip等）。另外，可以通过一些二进制打包（例如OCI镜像）将函数提供给框架。</p></div><a id="more"></a><p>接下来让我们介绍一下serverless函数概念。</p><hr><h4 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h4><p>函数代码、依赖项或二进制文件可以驻留在外部存储库（例如S3对象存储桶或Git存储库）中，或由用户直接提供。如果代码在外部存储库中，则用户需要指定路径和凭据。Serverless 框架还允许用户 watch 代码存储库中的更改（例如，使 Webhook），并在每次提交时自动构建函数镜像/二进制文件。函数可能依赖于外部库或二进制文件，这些需要由用户提供，包括描述其构建过程的方式（例如，使用 Dockerfile、Zip）。另外，可以通过一些二进制打包（例如OCI镜像）将函数提供给框架。</p><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>Serverless 函数定义可能包含以下规范和元数据，该函数定义：</p><ul><li>唯一ID</li><li>名称</li><li>说明</li><li>Label（或tag）</li><li>版本ID/或版本别名</li><li>版本创建时间</li><li>上次修改时间（函数定义）</li><li>函数处理程序</li><li>运行时语言</li><li>代码 + 依赖关系或代码路径和凭据</li><li>环境变量</li><li>执行角色和密钥</li><li>资源（所需的 CPU、内存）</li><li>执行超时处理</li><li>日志记录失败（Dead Letter Queue，）</li><li>网络策略/VPC</li><li>数据绑定</li><li>网关接入等</li></ul><blockquote><p>Dead Letter Queue<br>中文译作“死信队列”，在消息队列中，死信队列是一种服务实现，用于存储满足以下一个或多个条件的消息： 发送到不存在的队列的消息。 超出队列长度限制。 超<br>出了邮件长度限制。 消息被另一个队列交换拒绝。 消息达到阈值读取计数器编号，因为它没有被消耗。有时这被称为“退出队列”。 存储这些消息的死信队列允许<br>开发人员查找常见模式和潜在的软件问题。</p></blockquote><hr><h4 id="二、元数据"><a href="#二、元数据" class="headerlink" title="二、元数据"></a>二、元数据</h4><p>函数框架可能包括以下函数元数据：</p><ul><li>版本：每个函数版本应具有唯一的标识符，此外，可以使用一个或多个别名（例如“latest”、“production”、“beta”）来标记版本。API 网关和事件源会将流<br>量/事件路由到特定的函数版本。</li><li>环境变量：用户可以指定在运行时将提供给函数的环境变量。环境变量也可以从机密和加密的内容派生，也可以从平台变量派生（例如，像Kubernetes EnvVar定<br>义）。环境变量使开发人员能够控制函数行为和参数，而无需修改代码和/或重建函数，从而获得更好的开发人员体验和函数重用。</li><li>执行角色：该函数应在特定的用户或角色身份下运行，以授予和审核其对平台资源的访问权限。</li><li>资源：定义所需或最大的硬件资源，例如函数使用的内存和CPU。</li><li>超时：指定函数调用在平台终止之前可以运行的最长时间。</li><li>故障日志（死信队列）：队列或流的路径，它将存储具有适当详细信息的失败函数执行列表。</li><li>网络策略：分配给函数的网络域和策略（函数与外部服务/资源进行通信）。</li><li>执行语义：指定应如何执行函数（例如，每个事件至少执行一次，最多执行一次，恰好一次）。</li></ul><hr><h4 id="三、数据绑定"><a href="#三、数据绑定" class="headerlink" title="三、数据绑定"></a>三、数据绑定</h4><p>某些 Serverless 框架允许用户指定函数使用的输入/输出数据资源，这使开发变得更简单，性能更高（在执行期间保留数据连接，可以预取数据等）以及更好的安全<br>性（数据资源凭据是上下文的一部分，而不是代码）。</p><p>绑定数据可以采用文件、对象、记录、消息等形式，函数说明可以包括一组数据绑定定义，每个定义都指定数据资源、其凭证和使用参数。数据绑定可以引用事件数据<br>（例如，DB 键是从事件 “username” 字段派生的）</p><hr><h4 id="四、函数输入"><a href="#四、函数输入" class="headerlink" title="四、函数输入"></a>四、函数输入</h4><p>函数输入包括事件数据和元数据，并且可以包括上下文对象。</p><p><strong><em>事件数据和元数据</em></strong></p><p>事件详细信息应传递给函数处理程序，不同的事件可能具有不同的元数据，因此希望函数能够确定事件的类型并轻松解析公共和特定于事件的元数据。</p><p>可能需要将事件类与实现分离，例如：不管流存储是 Kafka 还是 Kinesis，处理消息流的函数都可以运行。在这两种情况下，它将接收消息正文和事件元数据，消</p><p>息可能在不同框架之间路由。</p><p>事件可以包括单个记录（例如，在请求/响应模型中），也可以接受多个记录或微批处理（例如，在流模式中）。</p><p>FaaS 解决方案使用的常见事件数据和元数据的示例：</p><ul><li>Event Class/Kind</li><li>版本</li><li>事件 ID</li><li>Event Source/Origin</li><li>来源身份</li><li>内容类型</li><li>邮件正文</li><li>时间戳记</li></ul><p>事件/记录特定元数据的示例</p><ul><li>HTTP：Path、Method、Header、查询参数</li><li>消息队列：Topic、Header</li><li>记录流（Record Stream）：表、键、操作、修改时间、旧字段、新字段</li></ul><p>事件源结构的示例：</p><ul><li><a href="http://docs.aws.amazon.com/lambda/latest/dg/eventsources.html" target="_blank" rel="noopener">http://docs.aws.amazon.com/lambda/latest/dg/eventsources.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/azure-functions/functions-triggers-bindings" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/azure-functions/functions-triggers-bindings</a></li><li><a href="https://cloud.google.com/functions/docs/concepts/events-triggers" target="_blank" rel="noopener">https://cloud.google.com/functions/docs/concepts/events-triggers</a></li></ul><p>一些实现将 JSON 视为将事件信息传递给函数的机制。对于高速函数（例如，流处理）或低能耗设备（IoT），这可能会增加大量的序列化/反序列化开销。在这些情况</p><p>下，可能值得考虑使用本地语言结构或其他序列化机制。</p><hr><h4 id="五、函数上下文"><a href="#五、函数上下文" class="headerlink" title="五、函数上下文"></a>五、函数上下文</h4><p>调用函数时，框架可能希望提供对跨多个函数调用的平台资源或常规属性的访问，而不是将所有静态数据放入事件中或强制该函数在每次调用时初始化平台服务。上下文（Context）可以是一组输入属性、环境变量或全局变量。有的实现将这三者结合使用。</p><p>上下文示例：</p><ul><li>函数名称、版本、ARN</li><li>内存限制</li><li>请求 ID</li><li>Cloud Region</li><li>环境变量</li><li>安全密钥/令牌</li><li>运行时/绑定路径</li><li>日志</li><li>数据绑定</li></ul><p>有的实现初始化日志对象（例如， AWS 中的全局变量或 Azure 中的部分上下文），用户可以使用平台集成的工具查看日志来跟踪函数执行。除了传统的日志记录，未来的实现可能会将计数器/监控和跟踪活动抽象为平台上下文的一部分，以进一步提高函数的可用性。数据绑定是函数上下文的一部分，平台根据用户配置启动与外部数据资源的连接，并且这些连接可以在多个函数调用之间重用。</p><hr><h4 id="五、函数输出"><a href="#五、函数输出" class="headerlink" title="五、函数输出"></a>五、函数输出</h4><p>当函数退出时，它可能：</p><ul><li>将值返回给调用方（例如，在 HTTP 请求/响应示例中）</li><li>将结果传递到工作流程中的下一个执行阶段</li><li>将输出写入日志</li></ul><p>应该有确定的方式通过返回的错误值或退出代码来知道函数是成功还是失败。</p><p>函数输出可以是结构化的（例如 HTTP 响应对象）或非结构化的（例如某些输出字符串）。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/21/N8MiqS.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍当前serverless框架的函数概念，Serverless框架还允许用户监视代码存储库中的更改（例如代码触发器等），并在每次提交时自动构建函数镜像。函数代码、依赖项和/或二进制文件可以驻留在外部存储库（例如S3对象存储桶或Git存储库）中，或由用户直接提供。如果代码在外部存储库中，则用户需要指定路径和接入凭证。函数可能依赖于外部库或二进制文件，这些需要由用户提供，包括描述其构建过程的方式（例如，使用 Dockerfile、Zip等）。另外，可以通过一些二进制打包（例如OCI镜像）将函数提供给框架。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless功能特性</title>
    <link href="https://ustack.io/2020-06-12-Serverless%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7.html"/>
    <id>https://ustack.io/2020-06-12-Serverless功能特性.html</id>
    <published>2020-06-12T13:40:08.000Z</published>
    <updated>2020-06-30T13:12:02.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgchr.com/i/tdXXgP" alt></p><div class="note info"><p>本文介绍当前serverless架构中函数及事件系统应该具备的能力。</p></div><a id="more"></a><p>让我们介绍一下serverless架构功能。</p><hr><h4 id="一、函数功能"><a href="#一、函数功能" class="headerlink" title="一、函数功能"></a>一、函数功能</h4><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><ul><li>可以使用多种语言，只需要提供一个代码片段即可运行</li><li>函数之间可以调用</li><li>函数执行超时时间</li><li>支持代码中使用第三方依赖</li></ul><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><ul><li>本地IDE开发调试</li><li>在界面上调试，能够快速的部署，收集调试的日志</li></ul><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>从源码到服务，自动构建，支持不同语言，第三方依赖</p><h5 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h5><p>能够方便的调用其他服务（如存储、数据库等）</p><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><ul><li>支持多个版本</li><li>支持蓝绿测试</li></ul><h5 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h5><p>包括外部请求接口的权限以及函数内部调用其他服务的权限</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>高性能</p><h5 id="数据输入输出绑定"><a href="#数据输入输出绑定" class="headerlink" title="数据输入输出绑定"></a>数据输入输出绑定</h5><p>输入输出数据源的绑定（比如数据源可以是http、kafka队列）</p><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>统一收集调用日志</p><h5 id="自动伸缩容"><a href="#自动伸缩容" class="headerlink" title="自动伸缩容"></a>自动伸缩容</h5><p>按指标（请求数、cpu）对业务进行快速扩容，扩容过程业务最好无感知，对服务性能无影响。<br>能缩容到0，减少常驻服务降低成本。</p><h5 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h5><p>冷启动时间尽可能缩短，如果使用k8s，包含k8s启动容器时间 + 业务进程启动时间。解决从0-&gt;1和1-&gt;n快速扩容的问题。</p><h5 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h5><p>能够编排工作流，按步骤调用函数</p><h5 id="计费（可选）"><a href="#计费（可选）" class="headerlink" title="计费（可选）"></a>计费（可选）</h5><p>只为使用的资源付费，能够采集cpu时间、耗时用于计费</p><hr><h4 id="二、事件功能"><a href="#二、事件功能" class="headerlink" title="二、事件功能"></a>二、事件功能</h4><h5 id="自定义事件源"><a href="#自定义事件源" class="headerlink" title="自定义事件源"></a>自定义事件源</h5><p>根据规范可以自由定制业务自己想要的事件源来触发Event</p><h5 id="任务完成提供回调功能"><a href="#任务完成提供回调功能" class="headerlink" title="任务完成提供回调功能"></a>任务完成提供回调功能</h5><p>事件触发后等待任务完成，完成后可以回调业务配置的接口</p><h5 id="事件编排——工作流引擎"><a href="#事件编排——工作流引擎" class="headerlink" title="事件编排——工作流引擎"></a>事件编排——工作流引擎</h5><ul><li>提供工作流定制的功能，让用户可以在Event上配置各种事件的依赖关系</li><li>支持顺序事件、分支事件和并行事件</li></ul><h6 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h6><p>高吞吐处理事件源</p><h5 id="事件权限隔离"><a href="#事件权限隔离" class="headerlink" title="事件权限隔离"></a>事件权限隔离</h5><p>业务只能编排自己创建的事件，外部触发事件流时，也只能触发自己创建的事件流</p><h5 id="监控功能"><a href="#监控功能" class="headerlink" title="监控功能"></a>监控功能</h5><p>可监控各个业务的单个事件、事件链路耗时等指标</p><h5 id="操作平台"><a href="#操作平台" class="headerlink" title="操作平台"></a>操作平台</h5><p>供用户编排事件，查看事件结点日志等</p><h5 id="对外API提供"><a href="#对外API提供" class="headerlink" title="对外API提供"></a>对外API提供</h5><p>可提供通用hook供业务使用，用来触发事件链路的根节点</p><h5 id="横向扩展能力"><a href="#横向扩展能力" class="headerlink" title="横向扩展能力"></a>横向扩展能力</h5><p>具有横向扩展能力来应对持续增长的事件处理</p><h5 id="全局唯一事件id"><a href="#全局唯一事件id" class="headerlink" title="全局唯一事件id"></a>全局唯一事件id</h5><p>提供唯一事件id，在并行事件中可以等到该id的所有前置步骤完成后，才触发下一步行为；不同id的 前置步骤不会触发其他id的下一步行为</p><h5 id="下游扩展能力"><a href="#下游扩展能力" class="headerlink" title="下游扩展能力"></a>下游扩展能力</h5><p>事件触发后，除http调用外，还提供如RPC等其他协议来触发下游任务</p><h5 id="调试功能"><a href="#调试功能" class="headerlink" title="调试功能"></a>调试功能</h5><p>提供单步调试功能，可直接调试事件链路中的任意相连结点组合</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.bookstack.cn/read/serverless-handbook/core-function-code.md" target="_blank" rel="noopener">function</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgchr.com/i/tdXXgP&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍当前serverless架构中函数及事件系统应该具备的能力。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless典型应用</title>
    <link href="https://ustack.io/2020-06-09-Serverless%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF.html"/>
    <id>https://ustack.io/2020-06-09-Serverless典型场景.html</id>
    <published>2020-06-09T13:40:08.000Z</published>
    <updated>2020-06-22T12:45:45.482Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/06/22/NJ3NhF.md.png" alt></p><div class="note info"><p>本文介绍当前serverless框架的典型使用场景，虽然serverless计算广泛使用，但它仍然相对较新。通常，当工作负载为以下情况时，应将serverless方法视为首选：</p><ul><li>异步，并发，易于并行化为独立的工作单元</li><li>在扩展要求方面存在较大的差异性</li><li>无状态，短暂的，对瞬间冷启动时间没有重大需求</li><li>在业务需求变更方面具有高度灵活性，需要满足开发的敏捷性</li></ul></div><a id="more"></a><p>让我们介绍一下基于serverless的典型应用，以下应用场景主要为aws跟azure，后续会 提供其他云的使用场景。</p><hr><h4 id="一、后端服务"><a href="#一、后端服务" class="headerlink" title="一、后端服务"></a>一、后端服务</h4><blockquote><p>AWS Lambda：可以使用AWS Lambda构建无服务器后端，以处理 Web、移动、物联网(IoT)和第3方API请求。</p></blockquote><p><strong><em>Web 应用程序后端</em></strong></p><p>从队列中获取在线订单，并进行处理，生成的数据保存在数据库中。</p><p><img src="https://s1.ax1x.com/2020/06/03/twSrFg.md.png" alt></p><p>场景分析：</p><ul><li>需要通过Service Bus ，处理结果存储到Azure自家的Cosmos DB。</li></ul><blockquote><p>Aws Lambda应用</p></blockquote><p>通过将AWS Lambda与其他AWS服务相结合，开发人员可以构建功能强大的Web应用程序，从而可自动扩缩，并跨多个数据中心运行，而无需在扩展、备份或多数据中心冗余方面执行任何管理工作。</p><p>实际案例：Bustle 使用 AWS Lambda 和 Amazon API Gateway 为其 Bustle iOS 应用程序和网站运行了一个无服务器后端。借助无服务器架构，Bustle无需管理基础设施，因此每位工程师都能够集中精力构建新功能并进行创新性研发工作。</p><p><img src="https://s1.ax1x.com/2020/06/03/twSLOx.md.png" alt></p><p>场景分析：</p><ul><li>web请求通过REST走API Gateway进来，触发Lambda</li><li>Lambda返回数据给请求</li><li>标准的对BaaS后端的请求</li></ul><p><strong><em>移动应用程序后端</em></strong></p><blockquote><p>Azure应用</p></blockquote><p>通过使用手机银行支付午餐费用：垫付午餐费用的人通过移动应用请求付款，这将在其他同事的手机上触发通知。</p><p><img src="https://s1.ax1x.com/2020/06/03/twpeAS.md.png" alt></p><p>场景分析：</p><ul><li>跳过了Service Bus</li><li>同样处理结果存储进Cosmos DB</li><li>存Cosmos DB时再次触发其他函数</li><li>继续通过使用 Notifications Hub 发送通知</li></ul><blockquote><p>Aws Lambda应用</p></blockquote><p>使用AWS Lambda 和Amazon API Gateway构建后端，以验证和处理API请求。Lambda能够提供丰富、个性化的应用程序体验。</p><p><img src="https://s1.ax1x.com/2020/06/03/twpDnx.md.png" alt></p><p>场景分析：</p><ul><li>移动应用程序更新状态，通过REST请求走API Gateway进来，触发Lambda</li><li>Lambda处理并发起状态更新通知，push给Amazon SNS</li></ul><p><strong><em>IOT 后端</em></strong></p><blockquote><p>Aws Lambda应用</p></blockquote><p>使用 AWS Lambda 构建无服务器后端，以处理 Web、移动、物联网 (IoT) 和第3方API 请求。</p><p><img src="https://s1.ax1x.com/2020/06/03/twpjvn.md.png" alt></p><p>场景分析：</p><ul><li>传感器发送数据给流数据处理平台</li><li>捕获传感器数据并流式传输传感器数据，触发Lambda</li></ul><hr><h4 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h4><p>Aws lambda：使用AWS Lambda 执行代码以响应数据更改、系统状态变化或用户操作等触发器。Lambda可以由S3、DynamoDB、Kinesis、SNS 和 CloudWatch 等 AWS 产品直接触发，也可以通过 AWS Step Functions 编排到工作流程中。您可借此构建各种实时的无服务器数据处理系统。</p><h5 id="数据库更改或更改数据捕获"><a href="#数据库更改或更改数据捕获" class="headerlink" title="数据库更改或更改数据捕获"></a>数据库更改或更改数据捕获</h5><p>在此场景中，当从数据库插入，修改或删除数据时调用函数。在这种情况下，它的功能类似于传统的SQL触发器。其结果是执行一个异步逻辑，可以修改同一个数据库中的某些内容（例如记录到审计表），或者依次调用外部服务（例如发送电子邮件）或更新其他数据库，例如DB CDC（更改数据捕获）用例的情况。 由于业务需要和处理变更的服务分布的原因，这些用例的频率以及对原子性和一致性的需要可能不同。</p><p>例子包括：</p><ul><li>审核对数据库的更改，或确保它们满足特定质量或分析标准以进行可接受的更改。</li><li>在输入数据时或之后不久自动将数据翻译为其他语言。</li></ul><h5 id="实时文件处理"><a href="#实时文件处理" class="headerlink" title="实时文件处理"></a>实时文件处理</h5><blockquote><p>Azure应用</p></blockquote><p>数据以PDF文件形式安全上传。然后使用OCR检测分解和处理该数据，并将其添加到数据库以便查询。</p><p><img src="https://s1.ax1x.com/2020/06/03/tw9cq0.png" alt></p><p>场景分析：</p><ul><li>触发来自Blob Storage</li><li>function进行处理，转交给OCR处理的服务</li><li>再将结构化信息存储在数据库中</li></ul><blockquote><p>Aws Lambda应用</p></blockquote><p>使用 Amazon S3 触发 AWS Lambda，以便在上传数据后立即对它们进行处理。例如，您可以使用 Lambda 实时创建缩略图、转换视频代码、建立文件索引、处理日志、验证内容以及聚合和筛选数据。</p><p>实际案例：某传媒利用 AWS Lambda 来调整图像大小，以便于在不同的设备（如台式机、平板电脑和智能手机）上查看。</p><p><img src="https://s1.ax1x.com/2020/06/03/tw9xRH.md.png" alt></p><p>场景分析：</p><ul><li>相机拍照，图片上传，触发Lambda （同样是Blob Storage触发）</li><li>对图片进行处理如修改大小</li><li>但这里没有说处理之后的图片如何存储，应该也是类似的存储在s3中</li></ul><h5 id="实时流式处理"><a href="#实时流式处理" class="headerlink" title="实时流式处理"></a>实时流式处理</h5><blockquote><p>Azure应用</p></blockquote><p>从大量云应用收集到大量遥测数据。近乎实时地处理该数据，并将其存储到DB中，供分析仪表板使用。</p><p><img src="https://s1.ax1x.com/2020/06/03/twCezj.png" alt></p><p>场景分析：</p><ul><li>应用或者设备产生数据，作为遥测信息收集</li><li>函数处理遥测数据，将结果发送给 Cosmos DB</li><li>按照实际经验，这里的function应该会是多次流处理，不会简单的一个function</li></ul><blockquote><p>Aws Lambda应用</p></blockquote><p>使用 AWS Lambda 和 Amazon Kinesis 处理实时流数据，从而跟踪应用程序活动、处理事务处理顺序、分析单击数据流、整理数据、生成指标、筛选日志、建立索引、分析社交媒体以及遥测和计量IoT设备数据。</p><p>实际案例：某社交软件可实时处理数十亿个数据点，并使用Lambda来处理存储在 S3 中或从 Kinesis 进行流式处理的历史和活动数据。</p><p><img src="https://s1.ax1x.com/2020/06/03/twCaO1.md.png" alt></p><p>场景分析：</p><ul><li>社交媒体数据实时上载，触发Lambda</li><li>Lambda生成趋势数据，存储到 DynamoDb</li><li>趋势数据可以被立即查看</li></ul><h5 id="提取、转换、加载"><a href="#提取、转换、加载" class="headerlink" title="提取、转换、加载"></a>提取、转换、加载</h5><blockquote><p>Aws Lambda应用</p></blockquote><p>使用 AWS Lambda 针对 DynamoDB 表中的每个数据更改执行数据验证、筛选、排序或其他转换，并将转换后的数据加载到其他数据存储。</p><p>实际案例：Zillow 使用 Lambda 和 Kinesis 实时跟踪移动指标子集。凭借 Kinesis 和 Lambda，我们得以在两周内开发和部署一套成本高效的解决方案。</p><p><img src="https://s1.ax1x.com/2020/06/03/twCXmq.md.png" alt></p><p>场景分析：</p><ul><li>订单操作更新数据库，触发Lambda</li><li>Lambda进行转换，将数据存储到数据仓库</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><strong><em>计划任务的自动化</em></strong></p><blockquote><p>Azure应用</p></blockquote><p>每 15 分钟对客户数据库执行一次分析，检查是否有重复条目，避免将多个通信发送给同一个客户。</p><p><img src="https://s1.ax1x.com/2020/06/03/twPFXR.png" alt></p><p>场景分析：</p><ul><li>function定时调度，定期清理数据</li></ul><blockquote><p>批处理作业或计划任务: 每天只需几分钟就能以异步方式进行强大的并行计算，IO或网络访问的作业非常适合serverless。作业可以在以弹性方式运行时有效地消<br>费他们所需的资源，并且在不被使用的当天剩余时间内不会产生资源成本。</p></blockquote><p>例子：</p><ul><li>计划任务可以是每晚运行的备份作业</li><li>并行发送许多电子邮件的作业会扩展function实例</li></ul><hr><h4 id="三、SaaS应用程序扩展"><a href="#三、SaaS应用程序扩展" class="headerlink" title="三、SaaS应用程序扩展"></a>三、SaaS应用程序扩展</h4><blockquote><p>Azure应用</p></blockquote><p>SaaS 解决方案通过 webhook（可通过 Functions 实现）提供扩展性，以自动执行某些工作流。</p><p><img src="https://s1.ax1x.com/2020/06/03/twPhv9.md.png" alt></p><p>场景分析：</p><ul><li>外部活动，通过web hook触发function</li><li>function进行处理，或者通过事件继续触发其他function</li></ul><h5 id="持续集成管道"><a href="#持续集成管道" class="headerlink" title="持续集成管道"></a>持续集成管道</h5><p>传统的CI管道包括一个构建从属主机池，它们处于空闲等待以便分派作业。Serverless是一种很好的模式，可以消除对预配置主机的需求并降低成本。构建作业由新代码提交或PR合并触发。 调用function来运行构建和测试用例，仅在所需的时间内执行，并且在未使用时不会产生成本。这降低了成本，并可通过自动扩展来减少瓶颈以满足需求。</p><h5 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><p>当与管理和协调函数一起部署时，在业务流程中执行一系列步骤的微服务工作负载的编排是serverless计算的另一个好用例。执行特定业务逻辑的function（例如订单请求和批准，股票交易处理等）可以与有状态管理器一起安排和协调。来自客户端门户的事件请求可以由这样的协调function提供服务，并传递给适当的serverless function。</p><p>例子包括：</p><p>交易台，处理股票市场交易并处理客户的交易订单和确认。协调器使用状态图管理交易。初始状态接受来自客户端门户的交易请求，并将请求传递给微服务function以解析请求并验证客户端。随后的状态根据买入或卖出交易指导工作流，验证基金余额，股票代码等，并向客户发送确认。在从客户端接收到确认请求事件时，后续状态调用管理交易执行的function，更新账户，并通知客户完成交易。</p><h5 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h5><p>与人类交互不一定需要毫秒级别的响应时间，并且在许多方面，稍微延迟让回复人类的机器人对话感觉更自然。因此，等待从冷启动加载函数的初始等待时间是可以接受的。当添加到Facebook，WhatsApp或Slack等流行的社交网络时，机器人可能还需要具有极高的可扩展性，因此在PaaS或IaaS模型中预先设置一个永远在线的守护程序，以预测突然或高峰需求，可能不会比采用serverless方法更加高效及较低的成本效益。</p><p>例子包括：</p><ul><li>支持和销售机器人插入到大型社交媒体服务，如Facebook或其他高流量网站。</li><li>消息应用程序Wuu使用Google Cloud Functions使用户能够创建和共享在数小时或数秒内消失的内容。</li><li>另请参阅下面的HTTP REST API和Web应用程序。</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/serverless-needs-standards-to-be-the-future-of-application-infrastructure/" target="_blank" rel="noopener">the-future-of-application-infrastructure</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/22/NJ3NhF.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍当前serverless框架的典型使用场景，虽然serverless计算广泛使用，但它仍然相对较新。通常，当工作负载为以下情况时，应将serverless方法视为首选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步，并发，易于并行化为独立的工作单元&lt;/li&gt;
&lt;li&gt;在扩展要求方面存在较大的差异性&lt;/li&gt;
&lt;li&gt;无状态，短暂的，对瞬间冷启动时间没有重大需求&lt;/li&gt;
&lt;li&gt;在业务需求变更方面具有高度灵活性，需要满足开发的敏捷性&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless用武之地</title>
    <link href="https://ustack.io/2020-06-09-Serverless%E7%94%A8%E6%AD%A6%E4%B9%8B%E5%9C%B0.html"/>
    <id>https://ustack.io/2020-06-09-Serverless用武之地.html</id>
    <published>2020-06-09T12:40:08.000Z</published>
    <updated>2020-06-09T14:15:40.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/06/09/tI1qTP.md.png" alt="趋势"></p><div class="note info"><p>Serverless是指构建和运行不需要服务器管理的应用程序的概念。它描述了一种更细粒度的部署模型，应用程序包含一个或多个函数，代码上传到平台，然后执行，通过响应当前的确切需求进行扩缩和计费。Serverless并不意味着我们不再使用服务器来托管和运行代码，这也并不是意味着不再需要运维工程师。它指的是serverless计算服务的消费者不再需要花费时间来进行服务器配置，维护，更新，扩展和容量规划，所有这些任务和功能都由serverless平台处理，并完全将开发人员从运维业务中剥离出来。因此，开发人员只需要专注于编写应用程序的业务逻辑，而运维工程师能够将业务重点更多的放到关键性业务任务上。</p></div><a id="more"></a><hr><h3 id="一、初识Serverless"><a href="#一、初识Serverless" class="headerlink" title="一、初识Serverless"></a>一、初识Serverless</h3><p>虽然按需或“花多少用多少”模式的概念可追溯到2006年一个名为Zimki的平台，但serverless一词的第一次使用是2012年来自Iron.io的IronWorker产品，一个基于容器的调度平台。</p><p>至此，公共云和私有云都出现了更多serverless解决方案，首先是BaaS产品，例如2011年的Parse和2012年的Firebase（分别由Facebook和谷歌收购）。2014年11月，AWS推出Lambda，2016年初在Bluemix上宣布了IBM OpenWhisk on Bluemix（现在是IBM Cloud Functions，其核心开源项目成为Apache OpenWhisk），Google Cloud Functions和Microsoft Azure Functions。华为Function Stage于2017年推出。在此之间，还有许多serverless框架宣布开源。每个框架（公共和私有）都具有独特的语言运行时和服务集，用于处理事件和数据。而在Serverless应用中，根据他们的功能，又可以进一步切分成不同的Serverless函数。</p><hr><h3 id="二、Serverless使用场景"><a href="#二、Serverless使用场景" class="headerlink" title="二、Serverless使用场景"></a>二、Serverless使用场景</h3><p>虽然serverless计算广泛使用，但它仍然相对较新。通常，当工作负载符合以下情况时，可优选serverless架构方案：</p><ul><li>异步，并发，易于并行的独立的工作单元</li><li>偶发的需求，在扩展要求方面存在巨大的偶发性</li><li>无状态，短暂的应用场景，对冷启动时间没有重大限制</li><li>在业务需求变更方面具有高度灵活性，需要加快开发迭代的速度</li></ul><p>例如，对于常见的基于HTTP的应用程序，在自动扩展和更细粒度的成本模型方面有明显的优势。也就是说，使用serverless平台可能会有以下一些方面的考量。 例如，如果函数的实例数下降到零，则在一段不活动时间后函数启动可能会导致性能业务下降。因此，选择是否采用serverless架构需要考量该计算模型的弊端。</p><p>不适合IaaS，PaaS或CaaS解决方案的以非HTTP为中心和无弹性需求的工作负载同样可以利用serverless架构的按需付费。其中一些工作负载包括：</p><ul><li>以响应数据库更改（insert, update, trigger, delete）的执行逻辑</li><li>对IoT传感器输入消息（例如MQTT消息）执行分析</li><li>流处理（分析或修改动态数据）</li><li>管理单次提取，转换和加载的作业，这些作业需要在短时间内进行大量处理（ETL）</li><li>通过聊天机器人界面提供认知计算（异步，但有关联）</li><li>调度执行时间很短的任务，例如cron或批处理样式调用</li><li>服务于机器学习和AI模型（检索一个或多个数据元素，如表格，NLP或图像，并与预先学习的数据模型匹配，以识别文本，面孔，异常等）</li><li>持续集成pipeline，按需为构建作业提供资源，而不是保留构建从属主机池等待作业分派</li></ul><p>这些场景中的每一个都显示了serverless架构如何解决技术问题，即Iaas，PaaS或CaaS效率低下或无法实现。这些例子是：</p><ul><li>在没有按需模型的情况下，有效解决了一个全新的问题</li><li>更有效地解决了传统的云问题（性能，成本）</li><li>显示“大”的维度，无论是处理的数据大小还是处理的请求</li><li>通过低错误率的自动缩放（向上和向下）来显示弹性</li><li>以前所未有的速度（从天到小时）为市场带来了解决方案</li></ul><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>一个常见的用例，也是最早具体化的用例之一，是响应新文件上传执行一些转换过程的函数。 例如，如果将图像上载到诸如Amazon S3的对象存储服务，则该事件触发函数，用于创建图像的缩略图版本并将其存储回另一个对象存储桶或Database-as-a-Service。 这是一个相当原子化，可并行化的计算任务示例，该计算任务不经常运行并根据需求进行伸缩。</p><ul><li>使用serverless function构建了一个概念验证，使用光学字符识别来处理移动支票存款。 这种类型的工作量变化很大，发薪日的处理需求 - 每两周一次 -<br>可能比支付期的大部分空闲时间大几倍。</li><li>通过将 每个视频帧通过图像识别服务 来自动分类电影，以提取演员，情感和对象; 或处理灾区的无人机镜头以估计损坏的程度。</li></ul><p><strong><em>数据库事件触发</em></strong></p><p>在此场景中，当从数据库插入，修改或删除数据时调用function。在这种情况下，它的功能类似于传统的SQL触发器，几乎就像是与主同步流并行的副作用或动作。其结果是执行一个异步逻辑，可以修改同一个数据库中的某些内容（例如记录到审计表），或者依次调用外部服务（例如发送电子邮件）或更新其他数据库，例如 DB CDC（更改数据捕获）用例的情况。 由于业务需要和处理变更的服务分布的原因，这些用例的频率以及对原子性和一致性的需要可能不同。</p><ul><li>审核对数据库的更改，或确保它们满足特定质量或分析标准以进行可接受的更改</li><li>在输入数据时或之后不久自动将数据翻译为其他语言</li></ul><p><strong><em>IoT消息</em></strong></p><p>随着连接到网络的自主设备的爆炸式增加，额外的流量体积庞大，并且使用比HTTP更轻量级的协议。 高效的云服务必须能够快速响应消息并扩展以响应其扩散或突然涌入的消息。Serverless功能可以有效地管理和过滤来自IoT设备的MQTT消息。 它们既可以弹性扩展，也可以屏蔽负载下游的其他服务。</p><ul><li>GreenQ的卫生用例（垃圾互联网），根据垃圾箱的相对饱满度来优化卡车取件路线。</li><li>在物联网设备（如AWS Greengrass）上使用serverless来收集本地传感器数据，对其进行规范化，与触发器进行比较，并将事件推送到聚合单元/云。</li></ul><p><strong><em>实时流处理</em></strong></p><p>另一种非事务性，非请求/响应类型的工作负载是在可能无限的消息流中处理数据。 函数可以连接到消息源，而消息必须从事件流中读取和处理。 鉴于高性能，高弹性和计算密集型处理工作负载，这对于serverless而言非常重要。 在许多情况下，流处理需要将数据与一组上下文对象（在NoSQL或in-mem DB中）进行比较，或者将数据从流聚合并存储到对象或数据库系统中。</p><p>例子包括：</p><ul><li>Mike Roberts有一个很好的 Java/AWS Kinesis 示例 ，可以有效地处理数十亿条消息。</li><li>SnapChat 在Google AppEngine上使用serverless 处理邮件。</li></ul><h4 id="批任务"><a href="#批任务" class="headerlink" title="批任务"></a>批任务</h4><p><strong><em>批处理作业或计划任务</em></strong></p><p>每天只需几分钟就能以异步方式进行强大的并行计算，IO或网络访问的作业非常适合serverless。作业可以在以弹性方式运行时有效地消费他们所需的资源，并且在不被使用的当天剩余时间内不会产生资源成本。</p><ul><li>计划任务可以是每晚运行的备份作业。</li><li>并行发送许多电子邮件的作业会扩展function实例。</li></ul><p><strong><em>持续集成管道</em></strong></p><p>传统的CI管道包括一个构建从属主机池，它们处于空闲等待以便分派作业。Serverless是一种很好的模式，可以消除对预配置主机的需求并降低成本。构建作业由新代码提交或PR合并触发。 调用function来运行构建和测试用例，仅在所需的时间内执行，并且在未使用时不会产生成本。这降低了成本，并可通过自动扩展来减少瓶颈以满足需求。</p><h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>当与管理和协调function一起部署时，在业务流程中执行一系列步骤的微服务工作负载的编排是serverless计算的另一个好用例。执行特定业务逻辑的function（例如订单请求和批准，股票交易处理等）可以与有状态管理器一起安排和协调。来自客户端门户的事件请求可以由这样的协调function提供服务，并传递给适当的serverless function。</p><p>例子包括：</p><p>交易台，处理股票市场交易并处理客户的交易订单和确认。协调器使用状态图管理交易。初始状态接受来自客户端门户的交易请求，并将请求传递给微服务function以解析请求并验证客户端。随后的状态根据买入或卖出交易指导工作流，验证基金余额，股票代码等，并向客户发送确认。在从客户端接收到确认请求事件时，后续状态调用管理交易执行的function，更新账户，并通知客户完成交易。</p><p><strong><em>聊天机器人</em></strong></p><p>与人类交互不一定需要毫秒级别的响应时间，并且在许多方面，稍微延迟让回复人类的机器人对话感觉更自然。因此，等待从冷启动加载function的初始等待时间可能是可接受的。当添加到Facebook，WhatsApp或Slack等流行的社交网络时，机器人可能还需要具有极高的可扩展性，因此在PaaS或IaaS模型中预先设置一个永远在线的守护程序，以预测突然或高峰需求，可能不会有作为serverless方法的高效或成本效益。</p><ul><li>支持和销售机器人插入到大型社交媒体服务，如Facebook或其他高流量网站。</li><li>消息应用程序Wuu使用Google Cloud Functions使用户能够创建和共享在数小时或数秒内消失的内容。</li></ul><p><strong><em>移动后端</em></strong></p><p>使用serverless进行移动后端任务也很有吸引力。它允许开发人员在BaaS API之上构建REST API后端工作负载，因此他们可以花时间优化移动应用程序，而不是扩展后端。 例子包括：优化视频游戏的图形，而不是在游戏成为病毒式打击时投资服务器; 或者对于需要快速迭代以发现产品/市场适合性，或者上市时间至关重要的消费者业务应用程序。另一个示例是批量通知用户或程序其他异步任务以获得离线优先体验。</p><p>例子包括：</p><ul><li>需要少量服务器端逻辑的移动应用程序; 开发人员可以将精力集中在原生代码开发上。</li><li>使用已配置的安全策略（例如Firebase身份验证/规则或Amazon Cognito）通过事件触发的serverless计算使用直接从移动设备访问BaaS的移动应用程序。</li><li>“Throwaway”或短期使用的移动应用程序，例如大型会议的调度应用程序，在会议前后的周末几乎没有需求，但需要极大的扩展和收缩; 在周一和周二早上的活动过<br>程中根据时间表查看要求，然后在午夜时分回到主题演讲。</li></ul><p><strong><em>HTTP REST API和Web应用程序</em></strong></p><p>传统的请求/响应工作负载仍然非常适合serverless，无论工作负载是静态网站还是使用JavaScript或Python等编程语言按需生成响应。即使它们可能会为第一个用户带来启动成本，但在其他计算模型中存在这种延迟的先例，例如将JavaServer Page初始编译为servlet，或者启动新的JVM来处理额外的负载。好处是单个REST调用（例如，微服务中的GET，POST，UPDATE和DELETE 4端点中的每一个）可以独立扩展并单独计费，即使它们共享公共数据后端。</p><p>例子包括：</p><ul><li>移植到serverless架构的澳大利亚人口普查显示了开发速度，成本改进和自动扩展。</li><li>“如何通过无服务器将我的AWS账单削减90％。”</li><li>AutoDesk示例：“成本只占传统云方法的一小部分（约1％）。”</li><li>在线编码/教育（考试，测试等）在事件驱动的环境中运行训练代码，并基于与该训练的结果和预期结果的比较向用户提供反馈。Serverless平台根据需要运行应答<br>检查并根据需要进行扩展，仅在代码运行的时间内需要付费。</li></ul><p><strong><em>AI应用</em></strong></p><p>算法工程师训练好模型后需要把模型变成服务，Serverless计算无需运维和弹性伸缩的特性，可以助力AI工程师快速构建弹性高可用的AI应用。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/09/tI1qTP.md.png&quot; alt=&quot;趋势&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Serverless是指构建和运行不需要服务器管理的应用程序的概念。它描述了一种更细粒度的部署模型，应用程序包含一个或多个函数，代码上传到平台，然后执行，通过响应当前的确切需求进行扩缩和计费。Serverless并不意味着我们不再使用服务器来托管和运行代码，这也并不是意味着不再需要运维工程师。它指的是serverless计算服务的消费者不再需要花费时间来进行服务器配置，维护，更新，扩展和容量规划，所有这些任务和功能都由serverless平台处理，并完全将开发人员从运维业务中剥离出来。因此，开发人员只需要专注于编写应用程序的业务逻辑，而运维工程师能够将业务重点更多的放到关键性业务任务上。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless生命周期</title>
    <link href="https://ustack.io/2020-06-07-Serverless%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>https://ustack.io/2020-06-07-Serverless生命周期.html</id>
    <published>2020-06-07T13:40:08.000Z</published>
    <updated>2020-06-03T14:26:47.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgchr.com/i/tdXXgP" alt></p><div class="note info"><p>本文介绍serverless框架中当前的函数使用，并概括了serverless函数需求，生命周期，调用类型和所需的抽象。 主要讲解的是定义serverless函数规范，<br>以便相同的函数可以编码一次并在不同的serverless框架中使用。</p></div><a id="more"></a><ul><li>Event sources/事件源 - 触发事件或流式传输触发到一个或多个函数实例中</li><li>Function instances/函数实例 - 单个函数/微服务，可以按需扩展</li><li>FaaS Controller/FaaS控制器- 部署，控制和监视函数实例及其来源</li><li>Platform services/平台服务 - FaaS解决方案使用的一般集群或云服务（有时称为Backend-as-a-Service）</li></ul><p>让我们首先看一下serverless环境中函数的生命周期。</p><hr><h2 id="一、函数生命周期"><a href="#一、函数生命周期" class="headerlink" title="一、函数生命周期"></a>一、函数生命周期</h2><blockquote><p>以下部分描述了函数生命周期的各个方面以及serverless框架/运行时通常如何管理它们。</p></blockquote><p><strong><em>函数部署管道</em></strong></p><p><img src="https://s1.ax1x.com/2020/06/03/tdj8v6.md.png" alt="deploy"></p><p>函数的生命周期从编写代码并提供规范和元数据开始（参见下面的函数定义），“builder”实体将获取代码和规范，编译并将其转换为工件（代码二进制文件，包或容</p><p>器镜像）。 然后将工件部署在具有控制器实体的集群上，该控制器实体负责基于事件流量和/或实例上的负载来扩展函数实例的数量。</p><p><strong><em>函数操作</em></strong></p><p>Serverless框架可以允许以下动作和方法来定义和控制函数生命周期：</p><ul><li>Create - 创建新函数，包括其规格和代码</li><li>Publish - 创建可在群集上部署的函数新版本</li><li>Update Alias/Label (版本的) - 更新别名/标签（版本） - 更新版本别名</li><li>Execute/Invoke - 调用特定版本，不通过其事件源</li><li>Event Source association - 将特定版本的函数与事件源连接</li><li>Get - 返回函数元数据和规范</li><li>Update - 修改函数的最新版本</li><li>Delete - 删除函数，可以删除特定版本或其所有版本的函数</li><li>List - 显示函数列表及其元数据</li><li>Get Stats - 返回有关函数运行时使用情况的统计信息</li><li>Get Logs - 返回函数生成的日志</li></ul><p><img src="https://s1.ax1x.com/2020/06/03/tdj4Gn.md.png" alt></p><p>在创建函数时，提供其元数据（稍后在函数规范中描述）作为函数创建的一部分，函数将被编译并可能被发布。 稍后可以启动，禁用和启用函数。函数部署需要能够支</p><p>持以下用例：</p><ul><li><p>Event streaming/事件流，在此用例中，队列中可能始终存在事件，而处理的暂停/恢复可能需要通过显式请求</p></li><li><p>Warm startup/热启动 - 在任何时候具有最少实例数量的函数，在接收的“first”事件时进行热启动，因为该函数已经部署并准备好为事件服务（而不是冷启动，</p></li></ul><p>冷启动时指函数获得通过“incoming”事件在第一次调用时部署）</p><p>用户可以发布函数，这将创建新版本（“latest”版本的副本），发布的版本可能被标记或具有别名，请参阅下文。</p><p>用户可能希望直接执行/调用函数（绕过事件源或API gateway）以进行调试和开发过程。用户可以指定调用参数，例如所需版本，同步/异步操作，详细级别等。</p><p>用户可能想要获得函数统计（例如调用次数，平均运行时间，平均延迟，失败，重试等），统计可以是当前度量值或时间序列值（例如存储在Prometheus或云提供者设</p><p>施中例如AWS Cloud Watch）。</p><p>用户可能希望检索函数日志数据。这可以通过严重性级别和/或时间范围和/或内容来进行过滤。 Log数据是每个函数都有的，它包括诸如函数创建和删除，显式错误，</p><p>警告或调试消息之类的事件，以及可选的函数Stdout或Stderr。倾向每次调用有一个日志条目或者将日志条目与特定调用相关联的方式（以允许更简单地跟踪函数执</p><p>行流程）。</p><hr><h2 id="二、函数版本和别名"><a href="#二、函数版本和别名" class="headerlink" title="二、函数版本和别名"></a>二、函数版本和别名</h2><p>一个函数可能具有多个版本，使用户能够运行不同级别的代码，例如 beta/production、A/B测试等。使用版本控制时，默认情况下函数版本为 “latest”，“latest” </p><p>版本可以进行更新和修改，可能会在每次更改时触发新的构建过程。如果用户想要冻结一个版本可以使用发布操作，该操作将创建一个具有潜在标签或别名（例如，“ beta”、</p><p>“production”）的新版本，以配置事件源，事件或 API 调用可以被路由到特定的函数版本。非最新的函数版本是不可变的（它们的代码以及所有或某些函数规范），</p><p>并且一旦发布就不能更改。函数不能“未发布”，而应将其删除。</p><p>请注意，当前的大多数实现都不允许函数 branch/fork（更新旧版本代码），因为这会使实现和用法变得复杂，但是将来可能需要这样做。</p><p>当同一函数有多个版本时，用户必须指定要操作的函数版本以及如何在不同版本之间划分事件流量。例如，用户可以决定路由 90％ 的事件流量到稳定版本，10% 的流</p><p>量到 Beta 版（又称“ canary update” ）。可以通过指定确切版本或通过指定版本别名来实现。版本别名通常将引用特定的函数版本。用户创建或更新函数时，</p><p>它可能会根据变更的性质来驱动新的构建和部署。</p><hr><h2 id="三、事件源管理"><a href="#三、事件源管理" class="headerlink" title="三、事件源管理"></a>三、事件源管理</h2><h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p>不同类型的事件源包括：</p><ul><li>事件和消息传递服务，例如：RabbitMQ、MQTT、SES、SNS、Google Pub / Sub</li><li>存储服务，例如：S3、DynamoDB、Kinesis、Cognito、Google Cloud Storage，Azure Blob、iguazio V3IO（对象/流/数据库）</li><li>端点服务，例如：物联网、HTTP网关、移动设备、Alexa、Google Cloud Endpoint</li><li>配置存储库，例如：Git、CodeCommit</li><li>使用特定于语言的 SDK 的用户应用程序</li><li>SchEnable 定期调用函数</li></ul><p>尽管每个事件提供的数据在不同事件源之间可能会有所不同，但事件结构应该具有通用性，能够封装有关事件源的特定信息（详细信息见事件数据和元数据）。</p><h3 id="函数关联"><a href="#函数关联" class="headerlink" title="函数关联"></a>函数关联</h3><p>由于事件源触发事件而调用函数。函数和事件源之间存在一个 n:m 映射。每个事件源都可以用于调用多个函数，而一个函数可以由多个事件源触发。事件源可以映射到函数的特定版本或函数的别名，后者提供了一种用于更改函数并部署新版本的方法，而无需更改事件关联。事件源还可以定义为使用同一函数的不同版本，并定义应为每个函数分配多少流量。</p><p>创建函数后或稍后的某个时间，需要关联事件源，该事件源应触发作为该事件的函数调用。这需要一系列动作（action）和方法（method），例如：</p><ul><li>创建事件源关联</li><li>更新事件源关联</li><li>列出事件源关联</li></ul><hr><h2 id="四、函数规范"><a href="#四、函数规范" class="headerlink" title="四、函数规范"></a>四、函数规范</h2><h3 id="函数要求"><a href="#函数要求" class="headerlink" title="函数要求"></a>函数要求</h3><p>根据当前的技术水平描述了函数和 Serverless 运行时应满足的一组通用要求：</p><ul><li>函数必须与不同事件类的基础实现分离</li><li>可以从多个事件源调用函数</li><li>无需为每个调用方法使用不同的函数</li><li>事件源可以调用多个函数</li><li>函数可能需要一种与基础平台服务进行持久绑定的机制，可能是跨函数调用。函数的寿命可能很短，但是如果需要在每次调用时都进行引导，那么引导可能会很昂贵，例如在日志记录、连接、安装外部数据源的情况下。</li><li>同一个应用程序中每个函数可以使用不同的语言编写</li><li>函数运行时应尽可能减少事件序列化和反序列化的开销（例如，使用本地语言结构或有效的编码方案）</li></ul><h3 id="工作流相关要求"><a href="#工作流相关要求" class="headerlink" title="工作流相关要求"></a>工作流相关要求</h3><ul><li>函数可以作为工作流的一部分被调用，一个函数的结果可以作为另一个函数的触发</li><li>可以由事件或 “and/or 事件组合”触发函数</li><li>一个事件可能触发按顺序或并行执行的多个函数</li><li>“and/or 事件组合”可能触发顺序运行、并行运行或分支运行的 m 个函数</li><li>在工作流的中间，可能会收到不同的事件或函数结果，这将触发分支切换到不同的函数</li><li>函数的部分或全部结果需要作为输入传递给另一个函数</li><li>函数可能需要一种与基础平台服务进行持久绑定的机制，这可能是跨函数调用或函数寿命很短</li></ul><hr><h2 id="五、函数调用"><a href="#五、函数调用" class="headerlink" title="五、函数调用"></a>五、函数调用</h2><p>可以根据不同的用例从不同的事件源调用函数，例如：</p><p>1、同步请求（Req/Rep），例如 HTTP 请求、gRPC调用</p><ul><li>客户端发出请求并等待立即响应。这是一个阻塞调用。</li></ul><p>2、异步消息队列请求（Pub/Sub），例如 RabbitMQ、AWS SNS、MQTT、电子邮件，对象（S3）更改、计划事件（如 CRON 作业）</p><ul><li><p>消息发布到交换场所并分发给订阅者</p></li><li><p>没有严格的消息顺序。恰好一次（Exactly once）处理</p></li></ul><p>3、消息/记录流：例如 Kafka、AWS Kinesis、AWS DynamoDB 流、数据库 CDC</p><ul><li>一组有序的消息/记录（必须按顺序处理）</li><li>通常，将流分片到多个分区/分片（分片消费者）每个分片分配给一个 worker</li><li>可以从消息，数据库更新（日志）或文件（例如CSV、Json、Parquet）产生流</li><li>事件可以推入（Push）到函数运行时或由函数运行时拉取（Pull）</li><li>批处理作业，例如 ETL 工作、分布式深度学习、HPC 模拟</li><li>作业被调度或提交到到队列中，并在运行时使用多个并行的函数实例进行处理，每个实例处理工作集（一个任务）的一个或多个部分</li><li>当所有并行 worker 成功完成所有计算任务时，作业完成</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/serverless-needs-standards-to-be-the-future-of-application-infrastructure/" target="_blank" rel="noopener">the-future-of-application-infrastructure</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgchr.com/i/tdXXgP&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍serverless框架中当前的函数使用，并概括了serverless函数需求，生命周期，调用类型和所需的抽象。 主要讲解的是定义serverless函数规范，&lt;br&gt;以便相同的函数可以编码一次并在不同的serverless框架中使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless开源对比</title>
    <link href="https://ustack.io/2020-06-01-Serverless%E5%BC%80%E6%BA%90%E5%AF%B9%E6%AF%94.html"/>
    <id>https://ustack.io/2020-06-01-Serverless开源对比.html</id>
    <published>2020-06-01T13:40:08.000Z</published>
    <updated>2020-06-21T08:57:43.235Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/06/21/N35FKA.md.jpg" alt="趋势"></p><div class="note info"><p>Kubernetes 的蓬勃发展由催生了一系列以它为基础的Serverless框架，目前开源的Serverless框架大多以Kubernetes为基础。接下来，将针对性介绍2020年应用较为广泛的几种Serverless框架.</p></div><a id="more"></a><hr><h4 id="一、Openfass"><a href="#一、Openfass" class="headerlink" title="一、Openfass"></a>一、Openfass</h4><p>OpenFaaS是一个构建无服务器功能的框架，它拥有对指标的第一个类支持。任何流程都可以打包为一个功能，使你能够使用一系列web事件，而无需重复的样板化编码。</p><p>优点：</p><ul><li>通过UI入口和单击安装轻松使用</li><li>为Linux或Windows的任何语言编写函数，以容器方式运行</li><li>支持Kubernetes、Docker、mesos等多种运行平台</li><li>用于模板和定义函数的YAML格式的命令行工具</li><li>根据请求数自动扩缩</li></ul><h5 id="Openfaas概述"><a href="#Openfaas概述" class="headerlink" title="Openfaas概述"></a>Openfaas概述</h5><ol><li>Watchdog</li></ol><p>通过添加Watchdog程序(一个小型的Golang HTTP服务器)，您可以将任何Docker镜像都添加到一个serverless函数中。</p><p>函数Watchdog是执行入口，允许通过STDIN将HTTP请求转发到目标进程。通过将应用程序写入标准输出，将响应发送回调用方。</p><ol start="2"><li>gateway</li></ol><p>API网关为函数提供了一个外部路由，并通过Prometheus收集监控数据。</p><p>API网关将根据需求来扩展函数，底层通过更改Docker Swarm或Kubernetes API中的服务副本数。UI允许您在浏览器中调用函数，并根据需要创建新的函数。</p><ol start="3"><li>命令行</li></ol><p>容器中的任何实例都可以是FaaS中的一个函数。通过使用FaaS CLI，您可以直接部署您的函数，或者通过诸如Node.js或Python这样的模板快速创建新的函数。</p><h5 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h5><p>watchdog对于我们编写的函数封装了一层http的外壳（通过创建子进程，写入子进程的标准输入，然后从子进程标准输出接受响应数据）</p><p><img src="https://s1.ax1x.com/2020/06/01/tJt5DS.md.png" alt="watchdog"></p><p>Wtachdog，作为函数的对外代理程序，必须作为启动的入口，处理流程如下图所示。</p><p><img src="https://s1.ax1x.com/2020/06/01/tJNpE4.md.png" alt="workflow"></p><hr><h4 id="二、KNative"><a href="#二、KNative" class="headerlink" title="二、KNative"></a>二、KNative</h4><p>KNative是谷歌开源的 serverless 架构方案，旨在提供一套简单易用的 serverless 方案，把 serverless 标准化。目前参与的公司主要是 Google、Pivotal、IBM、Red Hat，2018年7月24日才刚刚对外发布，当前还处于快速发展的阶段。knative 是为了解决容器为核心的 serverless 应用的构建、部署和运行的问题。</p><p>用户只需要编写代码（或者函数），以及配置文件（如何build、运行以及访问等声明式信息），然后运行build和deploy就能把应用自动部署到集群（可以是公有云，也可以是私有云）。其他事情交由serverless平台（比如这里的KNative）自动处理的，这些事情包括：</p><ul><li><p>自动完成代码到容器的构建</p></li><li><p>把应用（或者函数）和特定的事件进行绑定：当事件发生时，自动触发应用（或者函数）</p></li><li><p>网络的路由和流量控制</p></li><li><p>函数的自动伸缩</p></li></ul><p>和标准化的 FaaS 不同（只运行特定标准的 Function 代码），KNative期望能够运行所有的workload: traditional application、function、container。KNative建立在kubernetes平台之上，使用kubernetes提供的容器管理能力，以及基于envoy实现的网络管理功能。</p><p><img src="https://s1.ax1x.com/2020/06/01/tJdGKx.md.png" alt="arch"></p><ul><li>Serving：服务系统，用来配置应用的路由、升级策略、自动扩缩容等功能</li><li>Eventing：事件系统，用来自动完成事件的绑定和触发</li></ul><h5 id="Serving"><a href="#Serving" class="headerlink" title="Serving"></a>Serving</h5><p>serving 的核心功能是让应用运行起来提供服务。虽然听起来很简单，但这里包括了很多的事情：</p><ul><li>自动化启动和销毁容器</li><li>根据名字生成网络访问相关的 service、ingress 等对象</li><li>监控应用的请求，并自动扩缩容</li><li>支持蓝绿发布、回滚功能，方便应用发布流程</li></ul><p>KNative在Kubernetes之上提供了更高一层的抽象（这些对象是基于kubernetes的CRD实现的）。这些抽象出来的概念对应的关系如下图：</p><p><img src="https://s1.ax1x.com/2020/06/01/tJBC5D.md.png" alt="serving"></p><ul><li>Configuration：应用的最新配置，也就是应用目前期望的状态，对应了kubernetes 的容器管理（deployment）。每次应用升级都会更新configuration，<br>而KNative也会保留历史版本的记录（图中的 revision），结合流量管理，KNative可以让多个不同的版本共同提供服务，方便蓝绿发布和滚动升级.</li><li>Route：应用的路由规则，也就是进来的流量如何访问应用</li><li>Service：注意这里不是kubernetes中提供服务发现的那个service，而是KNative 自定义的CRD，它的全称目前是services.serving.knative.dev。<br>单独控制route和configuration就能实现serving的所有功能，但KNative更推荐使用Service来管理，因为它会自动帮你管理route和configuration.</li></ul><h5 id="Eventing"><a href="#Eventing" class="headerlink" title="Eventing"></a>Eventing</h5><p>serving 系统实现的功能是让应用/函数能够运行起来，并且自动伸缩，那什么时候才会调用应用呢？除了我们熟悉的正常应用调用之外，serverless 最重要的是基于事件的触发机制，也就是说当某件事发生时，就触发某个特定的函数。</p><p>事件概念的出现，让函数和具体的调用方能够解耦。函数部署出来不用关心谁会调用它，而事件源触发也不用关心谁会处理它。</p><blockquote><p>目前Serverless的产品和平台很多，每个地方支持的事件来源以及对事件的定义都是不同的（比如 AWS Lambda 支持很多自己产品的事件源）。<br>KNative自然也会定义自己的事件类型，除此之外，KNative还联合CNCF在做事件标准化的工作，目前的产出是CloudEvents这个项目。</p></blockquote><p>为了让整个事件系统更有扩展性和通用性，knative 定义了很多事件相关的概念。我们先来介绍一下：</p><ul><li>EventSource：事件源，能够产生事件的外部系统</li><li>Feed：把某种类型的EventType和EventSource 和对应的Channel绑定到一起</li><li>Channel：对消息实现的一层抽象，后端可以使用 kafka、RabbitMQ、Google PubSub 作为具体的实现。channel name 类似于消息集群中的 topic，可<br>以用来解耦事件源和函数。事件发生后 sink 到某个 channel 中，然后 channel 中的数据会被后端的函数消费</li><li>Subscription：把 channel 和后端的函数绑定的一起，一个 channel 可以绑定到多个KNative service</li></ul><p>它们之间的关系流程图如下：</p><p><img src="https://s1.ax1x.com/2020/06/01/tJ2K3T.md.png" alt="EVENT"></p><p>Bus是KNative内部的事件存储层，用户可以选择自己感兴趣的实现，目前支持的方式有：Stub（在内存中实现的简单消息系统）、Kafka、Google PubSub。如果想要事件能够正常运行，必须在KNative集群中安装其中一个 bus 实现方式。</p><p>有了bus之后，我们就可以监听外部的事件了。目前支持的事件源有三个：github（比如 merge 事件，push 事件等），kubernetes（events），Google PubSub（消息系统），后面还会不断接入更多的事件源。如果要想监听对应的事件源，需要在KNative中部署一个 source adaptor 的 pod，它负责从外部的系统中读取事件。读取后的事件，会根据用户配置的 Feed 对象（里面包括了事件源和 channel 的对应关系），找到对应的 channel，然后把消息发送到这个channel 中（channel 的消息最终是存储在后端的 bus 系统里的）。然后，KNative会根据 subscription 的配置，不断从 channel 中读取事件，然后把事件作为参数调用对应的函数，从而完成了整个事件的流程。</p><hr><h4 id="三、OpenWhisk"><a href="#三、OpenWhisk" class="headerlink" title="三、OpenWhisk"></a>三、OpenWhisk</h4><p>OpenWhisk（<a href="https://openwhisk.apache.org）是一个开源的Serverless" target="_blank" rel="noopener">https://openwhisk.apache.org）是一个开源的Serverless</a> FaaS平台。这个源于IBM的Serverless平台目前由Apache基金会进行孵化和管理。OpenWhisk是一个功能完备的FaaS平台，包含事件驱动及函数执行时等核心组件。OpenWhisk可以运行在不同的基础架构上，包括各类物理机、虚拟机、容器平台（如Kubernetes）、PaaS（如OpenShift）、公有云（如AWS和Azure等）和私有云（如Open-Stack）环境中.</p><p><img src="https://s1.ax1x.com/2020/06/01/tJRlJP.md.png" alt="OpenWhisk"></p><hr><h4 id="四、Kubeless"><a href="#四、Kubeless" class="headerlink" title="四、Kubeless"></a>四、Kubeless</h4><p>和 Fission相似，Kubeless也是运行在 Kubernetes平台之上的 FaaS。 Kubeless官方强调其是 Kubernetes原生（ Kubernetes native）的 Serverless实现。 Kubeless在设计之初就引用了许多 Kubernetes原生的组件，如 Service、 Ingress、 HPA（ Horizontal Pod Autoscaler）等。<br>目前 Kubeless支持的编程语言有 Python、 Ruby、 Node.js和 PHP。用户可以通过定制容器镜像来自定义函数的执行环境​.</p><p>Fission和Kubeless都倾向于向用户隐藏底层容器技术的细节。在 OpenFaaS中函数是以容器的形式定义的，容器对用户而言并不是抽象的，用户在定义函数时将指定具体的容器镜像。这对于一些容器技术爱好者而言是一个优点.</p><p>OpenFaaS项目还维护了一个应用市场 OpenFaaS Store，用户可以从这个软件市场上查找和快速部署社区验证过的函数应用​.</p><hr><h4 id="五、Fn"><a href="#五、Fn" class="headerlink" title="五、Fn"></a>五、Fn</h4><ul><li>是 IronFunctions团队成员加盟 Oracle后的产物。 Fn项目的特点是基于容器技术（ Container native），支持多个不同的容器编排平台，<br>包括 Kubernetes、 Docker Swarm及 Mesosphere，支持在不同的私有云和公有云平台上进行部署</li><li>Fn可以兼容 AWS Lambda的函数代码，用户可以将 AWS Lambda的代码导入 Fn中运行。不难想象，当 Oracle在其云服务 Oracle Cloud上提供以 Fn为基础<br>的 FaaS服务时，用户可以更容易地将他们的 Serverless应用从 AWS Lambda上迁移到 Oracle Cloud</li><li>容器技术已成为当前云计算的一个重要基石，也是 Serverless实现的一个重要技术手段。通过容器，用户可以很方便地打包各种编程语言的运行环境。通过容器编<br>排， Serverless平台可以很快速地将其部署到庞大的计算集群中去.</li></ul><hr><h4 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h4><p>容器技术已成为当前云计算的一个重要基石，也是 Serverless实现的一个重要技术手段。通过容器，用户可以很方便地打包各种编程语言的运行环境。通过容器编排，<br>Serverless平台可以很快速地将其部署到庞大的计算集群中去.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/21/N35FKA.md.jpg&quot; alt=&quot;趋势&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes 的蓬勃发展由催生了一系列以它为基础的Serverless框架，目前开源的Serverless框架大多以Kubernetes为基础。接下来，将针对性介绍2020年应用较为广泛的几种Serverless框架.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Operators和Sidecars成为软件交付新模式</title>
    <link href="https://ustack.io/2020-05-25-Operators%E5%8F%8ASidecars%E6%88%90%E4%B8%BA%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98%E6%96%B0%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://ustack.io/2020-05-25-Operators及Sidecars成为软件交付新模式.html</id>
    <published>2020-05-25T12:40:08.000Z</published>
    <updated>2020-05-27T14:15:32.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/23/Yxdj1A.md.jpg" alt></p><div class="note info"><p>现如今的开发人员希望可以开发出具备弹性和可扩展的分布式系统。 该系统受益于软件复用和开源模型创新，针对安全性问题能够轻易完成补丁更新并进行低风险的升级。<br>该系统不可能通过带有各种嵌入式语言库的应用程序框架来实现。</p><p>最近，一篇关于“多运行时微服务体系结构”的文章，其中探讨了分布式系统的需求，例如生命周期管理，高级网络，资源绑定，状态抽象以及这些抽象概念多年来的变化。<br>在以Kubernetes为中心的分布式系统的发展过程中，形成了以Kubernetes Operators和sidecar作为分布式系统交付的主要创新机制。</p></div><p>基于Kubernetes构建的软件应用，其架构的发展正朝着Kubernetes Operators和sidecar模型发展。 Kubernetes Operators和sidecar可能会成为主流<br>的软件分发和消费方式，在极端情况下甚至会像我们过去那样取代软件库和框架。Sidecar模型允许以不同语言编写的应用程序组合完成交付，而无需与运行时捆绑。<br>接下来让我们看一下Kubernetes Operators和sidecar的一些具体示例，然后我们将探索这种新的模型如何影响我们后续的开发模式。<br><a id="more"></a></p><hr><h3 id="一、智能化进程外延"><a href="#一、智能化进程外延" class="headerlink" title="一、智能化进程外延"></a>一、智能化进程外延</h3><blockquote><p>在Kubernetes中，sidecar是通过在单个Pod中组织多个容器而实现的核心设计模式之一。 Pod功能可确保将容器与指定节点绑定，并通过网络，文件<br>系统或其他IPC来进行协作。 并且Operator可以将sidecar与平台的其余部分进行自动化管理和集成。 sidecar代表了语言无关性，可扩展的数据平面，为定<br>制应用程序提供了分布式原语。 Operator代表了集中化管理和控制平面。</p></blockquote><p>  让我们看一下基于Sidecar模型的一些流行的开源项目。</p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>Istio，Consul等服务网格使用诸如Envoy之类的透明服务代理为分布式系统提供增强型联网功能。 Envoy具备高安全性、高级流量管理、弹性、深度监控和跟踪特性。<br>不仅如此，它支持越来越多的七层协议产品，例如Redis，MongoDB，MySQL和Kafka。 它增加了响应缓存功能，甚至还支持WebAssembly，这些功能将支<br>持各种自定义插件。 Envoy是透明服务代理如何将高级网络功能添加到分布式系统而不将其涵盖在分布式应用程序组件的运行时的一个典型示例。</p><h4 id="Skupper"><a href="#Skupper" class="headerlink" title="Skupper"></a>Skupper</h4><p>除了典型的服务网格外，还有一些项目（如Skupper）可通过外部代理透传应用程序网络流量。 Skupper通过7层虚拟网络解决了多集群Kubernetes的通信难题，<br>并提供了高级路由和连接功能。 但是，它没有将Skupper嵌入到业务服务运行时中，而是在每个Kubernetes名称空间运行一个实例。</p><h4 id="Cloudstate"><a href="#Cloudstate" class="headerlink" title="Cloudstate"></a>Cloudstate</h4><p>Cloudstate是Sidecar模型的另一个示例，但这一次是为serverless开发模型提供有状态抽象。 它通过GRPC提供有状态原语，用于EventSourcing，CQRS，Pub / Sub，<br>键值存储和其他用例。这次是serverless编程模型涵盖Operators和sidecar的例子。</p><h4 id="Dapr"><a href="#Dapr" class="headerlink" title="Dapr"></a>Dapr</h4><p>Dapr是由Microsoft发起的一个相对较年轻的项目，它还是使用sidecar模型来提供以开发人员为中心的分布式系统原语。 Dapr为状态管理，服务调用和故障处理，<br>资源绑定，发布/订阅，分布式跟踪等提供抽象。 尽管Dapr和Service Mesh提供的功能有些重叠，但两者在本质上却大有不同。 带有Istio的Envoy被注入并在<br>服务中透明运行，其代表一种操作工具。 另一方面，必须从应用程序运行时通过HTTP或gRPC显式调用Dapr，它是面向开发人员的显式工具。 其是一个用于分布<br>式原语的库，可作为sidecar进行分发和使用，该模型对于使用分布式功能的开发人员变得非常有吸引力。</p><h4 id="Camel-K"><a href="#Camel-K" class="headerlink" title="Camel K"></a>Camel K</h4><p>Apache Camel是一个成熟的集成库。 其子项目Camel K大量使用Operators模型来改善开发人员体验并与Kubernetes平台进行深度集成。 虽然Camel K不依赖<br>于sidecar，但通过其CLI和Operators，它能够在不到一秒钟的时间内重用同一应用程序容器并在远程Kubernetes集群中执行任何本地修改代码。</p><p>这些只是通过Operators和sidecar探索各种可能的一些探索项目。 为了减少基于容器的分布式体系结构（如数据平面开发工具包（DPDK））引入的网络开销，需要做更多的<br>工作，该工具包是一种用户空间应用程序，它绕过Linux内核网络堆栈直接访问网络硬件。 Kubernetes项目正在进行一些工作，以创建具有更精细的生命周期保证的<br>sidecar容器。 有一些基于GraalVM实现的Java项目，例如Quarkus，它们减少了资源消耗和应用程序启动时间，这些创新的尝试使得sidecar更具有吸引力。<br>并使更多此类项目的诞生提供了可能。</p><p><img src="https://imgchr.com/i/YxwfUS" alt></p><p>看到围绕更具体用例的项目，例如sidecar上的作业调度程序对长期运行的有状态编排（例如，BPMN引擎）进行的处理。 无状态集成引擎，如Sidecar中的Enterprise Integration Patterns实现；<br>sidecar中的数据抽象和数据联合引擎；sidecar中的OAuth2 / OpenID代理；可扩展的数据库连接池；可用于无人驾驶汽车中的serverless工作负载； 应用程序网络，<br>如辅助工具等。但是，为什么软件供应商和开发人员会切换到这种模式？ </p><p>接下来介绍这种模式带来的优越性。</p><hr><h3 id="二、模式的优势"><a href="#二、模式的优势" class="headerlink" title="二、模式的优势"></a>二、模式的优势</h3><h4 id="控制平面的运行时"><a href="#控制平面的运行时" class="headerlink" title="控制平面的运行时"></a>控制平面的运行时</h4><p>作为软件供应商，可能已经考虑过将软件以API或基于SaaS的解决方案的方式提供给客户，这是最快的软件消费模型。 根据软件的性质，您可能还会将软件作为工具库<br>或运行时框架进行产品分发，也许现在是时候考虑是否将其以operator方式提供。 这种软件的分发机制和体系结构具有一些可执行文件无法提供的特有的好处。</p><ol><li><p>支持多语言<br>通过协议标准或者标准库，为多数编程语言提供开发方案。使用sidecar方式运行并通过HTTP协议对外暴露接口的方式，而无需任何特定的运行时库。即使采用<br>gRPC和Protobuf协议用于处理低延迟和高性能的交互，生成此类客户端也比在应用程序运行时中包含第三方自定义库和实现某些接口来的容易得多。</p></li><li><p>兼容性<br>显式的sidecar体系结构（与透明的sidecar体系结构相反）是一种软件消费方式，其作为一个独立运行时，支持面向开发人员为中心的API。它作为一种通用特性，可<br>以添加到任何应用程序中，无论是单体，微服务，还是基于函数的架构。在Kubernetes上创建辅助工具很简单，并且在其他软件编排平台上也可行。</p></li><li><p>容错性<br>业务逻辑始终是内部定制和开发的。分布式系统原语是众所周知的产品功能，并且已作为平台功能或产品库使用。您可能正在使用来自第三方的开源项目或<br>商业软件来实现消息传递，网络弹性和监视。这些第三方软件的发布周期、关键代码的修复和CVE补丁同样会影响您的软件发布周期。当第三方库作<br>为单独的运行时（sidecar）使用时，升级过程会更简单，因为它位于API服务的后面，并且不与应用程序运行时解藕。软件开发团队与第三方软件之间的解藕变得更易于管理。</p></li><li><p>控制平面<br>当某个功能作为库使用时，它就包含在应用程序的运行时中，您有责任了解它的工作方式，其中包括配置、监控、性能和升级。语言的运行时（例如JVM）和运行时框架<br>（例如Spring Boot或应用程序服务器）决定了如何处理配置、监视和升级方案。<br>当软件功能作为单独的运行时使用（例如，sidecar或独立容器）时，它将以Kubernetes operator的形式提供其控制平面。</p></li></ol><p>由于控制平面了解其管理的软件并具备必要的智能化管理特性，否则它将作为文档和最佳实践进行分发。此外，运营商还与Kubernetes进行了深度集成，提供了平台<br>集成和operator开箱即用的奇妙组合。operator由同一开发人员创建，他们了解容器化功能的内部结构，并且知道如何最佳地操作。operator是容器中的SRE，<br>随着更多operator及其应用市场的兴起，operator的数量及其功能正在稳步增长。</p><hr><h3 id="三、未来的软件发行"><a href="#三、未来的软件发行" class="headerlink" title="三、未来的软件发行"></a>三、未来的软件发行</h3><h4 id="以sidecar方式分发软件并附带管理平面"><a href="#以sidecar方式分发软件并附带管理平面" class="headerlink" title="以sidecar方式分发软件并附带管理平面"></a>以sidecar方式分发软件并附带管理平面</h4><p>假设您是Java框架的软件提供商，我们可以以Maven配置方式进行分发。当然更进一步，我们可以直接以容器镜像方式分发。无论采用何种方式，在当今的云原生世界中，<br>都未达到尽善尽美的地步。用户仍然需要知道如何在零停机状态下对应用程序程序进行热更新，同时需要知道应该备份的内容以及如何配置其监控并设置告警阈值。<br>他们必须知道如何检测复杂故障并解决。他们必须知道如何根据当前的负载配置文件来调整应用程序。</p><p>在处理上述类似的场景时，Kubernetes以operator方式提供管理平面的方案将是最优解。operator包含应用程序和以关联业务特性的配置方式来以管理工作负载的组件。</p><blockquote><p>Sidecars和operators正在成为主流的软件分发和消费方式，在某些情况下甚至会像我们过去那样取代软件库和框架。</p></blockquote><p>假设您提供的软件库作为依赖项包含在使用者应用程序中。可能是上面描述的后端框架的客户端库。例如，如果它是在Java中，那么您可能已经在JEE服务器上运行，<br>前提是Spring启动程序、构建程序、工厂和其他实现都隐藏在Java接口后面，这样你甚至可以把它移植到golang。</p><p>有了Kubernetes的operator和sidecars之后，所有这些都对消费者透明。工厂类被operator取代，唯一的配置接口是自定义资源的YAML文件。然后，operator负责配置软件<br>，以便用户可以将其作为一个显式的sidecar来使用。在所有情况下，您的应用程序都可以通过远程API调用，并与平台功能甚至其他依赖的operator完全集成。</p><h4 id="通过远程API而不是嵌入式库使用的软件"><a href="#通过远程API而不是嵌入式库使用的软件" class="headerlink" title="通过远程API而不是嵌入式库使用的软件"></a>通过远程API而不是嵌入式库使用的软件</h4><p>换种角度来看，sidecar的作用类似于OOP中继承原则的组合，但是在多语言环境中。通过组合来自不同进程的功能，而不是将它们作为依赖项包含在单个应用程序中，这是<br>一种组织应用程序功能的不同方式。当您将软件用作库时，可以实例化一个类，并通过传递一些值来调用其方法。当您将其用作进程外功能时，您将访问本地进程。<br>在此模型中，方法被API取代，进程内方法被HTTP或gRPC调用所取代，并使用CloudEvents之类的通信标准。这是从应用程序服务器到Kubernetes的分布式运行时的转变。<br>这是从特定语言的界面到远程API的转变。从内存调用到HTTP，从值对象到CloudEvents，等等。</p><p>这要求软件提供商分发容器和控制器以对其进行管理。创建能够在本地构建和调试多个运行时服务的IDE。用于代码更新并配置控制平面以快速部署到Kubernetes的CLI。<br>可以决定在自定义应用程序运行时中进行编译的内容，可以从Sidecar输出哪些能力以及从业务流程平台获得哪些功能。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yx0RMR.png" alt></p><p>从长远来看，这将导致标准API的合并，这些标准API用于消耗sidecar中的通用能力。除了特定语言的标准和API，我们将使用多语种API。例如，除了Java数据库连接<br>（JDBC）API，Java缓存API（JCache），Java持久性API（JPA）之外，我们还将使用CloudEvents之类的基于HTTP的多语言API。以Sidecar为中心API，如<br>用于消息传递，缓存，可靠的网络，cron作业和计时器调度，资源绑定（其他API，协议的连接器），幂等性，SAGA等。所有这些功能都将随表格中包含的管理层一起提供<br>，甚至包含自助式用户管理界面。operator是上述特性的关键推动力，因为它们将使分散的架构易于在Kubernetes上进行管控。operator的管理接口由<br>CustomResourceDefinition定义，代表第三方资源面向公众管理的API。</p><p>在交付速度和可操作性的驱动下，这是一种思想上的巨大转变，其转向了一种革命性的软件分发和使用的方式。这是从单一运行时架构到多运行时应用程序架构的转变。这与<br>摩尔定律结束后硬件行业从单核平台向多核平台的转变累屎。这一变化正在慢慢发生：我们已经统一采用标准化容器，我们已经基于Kubernetes确定了事实上的编排标准，<br>随着推出的sidecar，以及operator的广泛应用，以及CloudEvents标准的深入人心，标准化的API和生态系统也会随之出现。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/operators-and-sidecars-are-the-new-model-for-software-delivery/" target="_blank" rel="noopener">software-delivery</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/23/Yxdj1A.md.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;现如今的开发人员希望可以开发出具备弹性和可扩展的分布式系统。 该系统受益于软件复用和开源模型创新，针对安全性问题能够轻易完成补丁更新并进行低风险的升级。&lt;br&gt;该系统不可能通过带有各种嵌入式语言库的应用程序框架来实现。&lt;/p&gt;
&lt;p&gt;最近，一篇关于“多运行时微服务体系结构”的文章，其中探讨了分布式系统的需求，例如生命周期管理，高级网络，资源绑定，状态抽象以及这些抽象概念多年来的变化。&lt;br&gt;在以Kubernetes为中心的分布式系统的发展过程中，形成了以Kubernetes Operators和sidecar作为分布式系统交付的主要创新机制。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;基于Kubernetes构建的软件应用，其架构的发展正朝着Kubernetes Operators和sidecar模型发展。 Kubernetes Operators和sidecar可能会成为主流&lt;br&gt;的软件分发和消费方式，在极端情况下甚至会像我们过去那样取代软件库和框架。Sidecar模型允许以不同语言编写的应用程序组合完成交付，而无需与运行时捆绑。&lt;br&gt;接下来让我们看一下Kubernetes Operators和sidecar的一些具体示例，然后我们将探索这种新的模型如何影响我们后续的开发模式。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>Serverless标准化夯实应用基础架构的未来</title>
    <link href="https://ustack.io/2020-05-16-Serverless%E6%A0%87%E5%87%86%E5%8C%96%E5%A4%AF%E5%AE%9E%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>https://ustack.io/2020-05-16-Serverless标准化夯实应用基础架构的未来.html</id>
    <published>2020-05-16T13:40:08.000Z</published>
    <updated>2020-05-17T11:57:11.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg" alt></p><div class="note info"><p>Serverless正在迅猛发展：根据2019度CNCF调查报告，目前有41％的受访者正在使用serverless技术，另有20％的受访者计<br>划在未来12至18个月内使用serverless技术。 serverless技术允许云化应用程序开发团队将代码交付给serverless服务商-以减少<br>开销成本，提高可伸缩性并简化DevOps周期。</p></div><a id="more"></a><hr><h3 id="一、Serverless标准"><a href="#一、Serverless标准" class="headerlink" title="一、Serverless标准"></a>一、Serverless标准</h3><blockquote><p>Serverless已经被认为是应用程序基础架构的下一个发展阶段，但目前仍然有一些障碍需要克服，特别是标准化工作。</p></blockquote><p>长期以来，推进标准化一直是统一计算领域的重要方式。 正如当初的Mesos、Kubernetes以及Swarm的容器编排之争，在争夺霸主地位的过程中，因为Kubernetes致力于标准化的引进，从而异军突起，后发制人，一举赢得容器编排之争，正是因为秉持标准化的理念，Kubernetes得到越来越多的人员的加入，从社区的维护到使用者的参与，再到CNCF的壮大。更久远的事例，就是浏览器之争，因为2001年成功说服Internet Explorer，Netscape和其他浏览器采用World Wide Web Consortium建立的标准。 结果就是今天我们知道和喜欢的互联网：一个开放，协作且通用的平台，可以在线连接世界各地的人们，从而使Web开发人员的生活变得更加轻松。</p><p>如今，serverless的生态系统仍然呈现零散状态，就像早期的互联网一样。 在AWS Lambda，Microsoft Azure Functions，Google Cloud Functions和众多其他平台之间，许多serverless功能都是专有的，这使得将应用程序从一个平台迁移到另一个平台成为一项难题。 平台之间缺乏可移植性和互操作性，这阻碍了serverless的应用，开发人员担心业务与云服务商过于耦合。</p><p>在serverless市场较初期的情况下，如果能够降低业务与服务的耦合下，那么在将来存在更好的选择情况下，开发人员就不会陷入选择serverless提供商的困境。 而且，随着新冠病毒给经济造成的不可弥补的伤害，serverless市场有望为快速整合做好准备，这使得云服务商具备跨平台迁移serverless应用程序的能力比以往任何时候都更为重要。</p><p>缺乏serverless标准化同时也带来了安全挑战。尽管serverless可以通过减少服务器管理来简化运维等成本，但是由于开发人员无法看到他们在无服务器平台上运行的工作负载。这意味着无法察觉诸如数据泄露，配置错误，过度的访问权限等安全威胁。当然，可以让开发人员通过serverless提供商提供的API来观察可能的安全威胁。但是没有标准化的serverless框架，在整个serverless生态系统中就不会存在标准化的安全工具或最佳实践。</p><p>庆幸的是，标准化工作正在推进。位于云原生世界中心的CNCF，已经意识到了”标准化的紧迫性，并指出需要高质量的文档，最佳实践，更重要的是工具和实用程序。通常，有必要将不同的参与者聚集在同一个屋檐下，以通过协作来推动创新”。本着协作的精神，CNCFserverless平台提供商和第三方库开发人员召集到serverless工作组中，以推进标准化。</p><hr><h3 id="二、CloudEvent试水"><a href="#二、CloudEvent试水" class="headerlink" title="二、CloudEvent试水"></a>二、CloudEvent试水</h3><p>serverless工作组的早期推出的CloudEvents标准，它用于事件描述的标准化。serverless工作组经过两年的工作，于2019年10月发布了1.0版。 CloudEvents为Go，JavaScript，Java，C＃，Ruby和Python等语言提供了标准化的SDK，可用于构建事件路由器，跟踪系统和其他工具，从而简化跨平台和环境的事件数据交付。</p><p>Kubernetes已经成为另一个有预期未来的解决方案。容器生态系统已经围绕Kubernetes进行了整合，使其成为统一serverless生态系统的理想平台。在2018年，由Google领导、与Pivotal，IBM，Red Hat和SAP合作推出了Knative开源框架，其用于在Kubernetes之上运行serverless应用程序组件。该平台提供以构建，部署，扩展和运行serverless工作负载的所有API。</p><p>除了互操作性和可移植性之外，Knative还具有安全性优势。 Knative允许您使用已经为Kubernetes开发的安全工具，其中安全策略更加成熟。借助Knative，您可以通过将安全代理嵌入Kubernetes中的serverless工作负载来实现更丰富的可扩展性，而无需使用serverless平台提供的基础架构插件。如果您的团队已经在Kubernetes安全性上进行了投资，则这些安全性投资可以扩展到serverless安全性。</p><p>Knative是否能够成为serverless标准化的赢家还有待观察。截至3月，Knative的采用率达到17％，这意味着其成熟度和增长空间仍然很大。 Knative本身建立在Kubeless的基础上，Kubeless是先前围绕Kubernetes标准化serverless的前期尝试。但是，有迹象表明，谷歌已经在Knative的基础上构建了其下一代，完全托管的无服务器平台Cloud Run，这表明其他早期的serverless平台可能会加速效仿。</p><p>Serverless使开发人员可以心无旁骛的专注于在其代码中构建功能，而不是管理运行这些功能的服务器。从繁重而又至关重要的运维责任中解放出来的有可能为应用程序开发人员释放更多的创新热情和业务价值，但是缺乏标准化的风险会分散serverless生态系统。随着标准化的发展，开源协作的力量便推动了创新。</p><hr><h3 id="三、何为CloudEvent"><a href="#三、何为CloudEvent" class="headerlink" title="三、何为CloudEvent"></a>三、何为CloudEvent</h3><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>CNCF的Serverless工作组最初是由CNCF技术监督委员会创建的，旨在调查serverless技术并为该领域中与CNCF相关的活动提出一些可能的下一步建议。 建议之一是研究创建通用事件格式，以帮助云提供商之间功能的可移植性以及事件流处理的互操作性。 最终，创建了CloudEvents规范。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>起初，制定CloudEvents标准是serverless工作组的一部分工作内容的，而当规范达到其v0.1里程碑时，TOC批准将其作为CNCF一个全新的独立沙箱项目。</p><p>CloudEvents通常用于分布式系统中，以实现服务在开发过程中的解耦，并完成独立部署，并且以后以此连接新的应用程序。</p><p>CloudEvents规范的目标是定义事件系统的互操作性，该系统允许服务生成或使用事件，其中包括独立开发和部署生产者和使用者。生产者可以在消费者收听之前生成事件，并且消费者可以进行相关订阅操作。需要注意的是，此工作产生的规范集中于事件格式的互操作性以及在各种协议（例如HTTP）上发送事件格式的显示方式。规范不关注事件产生者或事件消费者的处理模型。</p><p>CloudEvents的核心是定义了一组元数据，称为属性，以及有关在系统之间传输的事件和这些元数据应如何出现在消息中。该元数据是将请求路由到适当组件并促进该组件对事件进行适当处理所需的最少信息集。尽管这可能意味着事件本身的某些应用程序数据可能会作CloudEvent属性集的一部分，但这也是为了正确传递和处理消息而进行的必要操作。相反，不打算用于此目的的数据应放在事件（数据）本身。</p><p>此外，假定协议层将消息传递到目标系统所需的元数据完全由协议处理，那么就没有必要包含在CloudEvents属性中。除了这些属性的定义之外，还将规范如何以不同的格式（例如JSON）和协议（例如HTTP，AMQP，Kafka）来序列化事件。某些协议本身支持将多个事件批处理到单个API调用中。为了帮助实现互操作性，应由协议决定是否实现批处理以及如何实现批处理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://thenewstack.io/serverless-needs-standards-to-be-the-future-of-application-infrastructure/" target="_blank" rel="noopener">the-future-of-application-infrastructure</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/Yc4JUK.jpg&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Serverless正在迅猛发展：根据2019度CNCF调查报告，目前有41％的受访者正在使用serverless技术，另有20％的受访者计&lt;br&gt;划在未来12至18个月内使用serverless技术。 serverless技术允许云化应用程序开发团队将代码交付给serverless服务商-以减少&lt;br&gt;开销成本，提高可伸缩性并简化DevOps周期。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>xDS标准引入gRPC生态</title>
    <link href="https://ustack.io/2020-05-06-xDS%E6%A0%87%E5%87%86%E5%BC%95%E5%85%A5GRPC%E7%94%9F%E6%80%81.html"/>
    <id>https://ustack.io/2020-05-06-xDS标准引入GRPC生态.html</id>
    <published>2020-05-06T12:40:08.000Z</published>
    <updated>2020-05-06T12:45:25.753Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/06/YAWtkd.md.png" alt></p><div class="note info"><p>gRPC小组正在努力扩展当前的gRPCLB功能。其不再使用自定义负载均衡协议，而是采用基于Envoy xDS API的xDS协议。这将允许与支持xDS API的开源控制<br>平面（例如Istio Pilot，go-control-plane和java-control-plane）进行交互。其他优化如下所示：</p><ul><li>更加灵活和先进的负载均衡策略配置功能</li><li>基于LRS（负载报告服务）的负载报告功能等</li></ul></div><p>客户端侧实现的xDS负载均衡插件与当前的gRPCLB协议不兼容。因此，我们可以认为当前的gRPCLB实现已被废弃。我们正在积极致力于新协议的推进。预计在接下来的几<br>个季度中会看到更多的进展，其中包括有关新设计的gRFC。下述将介绍gRPC关于负载均衡的设计。<br><a id="more"></a></p><hr><h3 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h3><blockquote><p>值得注意的是，gRPC中的负载均衡是在每个调用而不是每个连接的基础上进行的。 换句话说，即使所有请求都来自单个客户端，我们仍然希望在所有服务器之间实现负载均衡。</p></blockquote><h4 id="负载均衡方案"><a href="#负载均衡方案" class="headerlink" title="负载均衡方案"></a>负载均衡方案</h4><p>在介绍gRPC之前，我们将探讨一些常用的方法来实现负载平衡。</p><ol><li>代理模式</li></ol><p>该方案使用代理来提供稳定可靠的客户端，其可以将负载报告上报给负载均衡系统。 代理通常需要更多资源以维持运行，因为它们需要保存RPC请求和响应的临时副本。<br>此模型还增加了RPC的延迟。</p><blockquote><p>在高并发应用场景下（例如存储），代理模型效率比较低下。</p></blockquote><ol start="2"><li>客户端动态均衡</li></ol><p>该方案将大多的负载均衡逻辑放置在客户端侧。例如，客户端可能包含许多用于服务器的负载均衡策略（如Round Robin，Random等）。<br>在该方案中，服务器列表将由名称解析系统（如DNS等解析），或者由外部负载均衡器等静态配置，无论如何，客户端负责从列表中选择首选服务器。</p><p>这种方案的缺点之一是以多种语言/版本的客户端维护负载均衡策略。这些策略可能相当复杂。一些算法还需要客户端与服务器之间的通信，因此，除了<br>RPC用于用户请求之外，客户端可能变得更加厚重，以满足获取运行状况或加载信息等需求。</p><blockquote><p>这将使客户端的代码复杂化：新的设计需要隐藏多层负载均衡的复杂性，而将其以简单的服务器列表反馈给客户端。</p></blockquote><ol start="3"><li>外部负载均衡服务</li></ol><p>客户端负载均衡代码保持简洁且可移植，实现选择服务器的通用算法（如Round Robin等）。复杂的负载均衡算法由外部负载均衡器提供。客户端依靠<br>外部负载均衡器提供负载均衡配置以及客户端应向其发送请求的服务器列表。均衡器根据需要更新服务器列表，并且负责处理服务器不可用或运行故障等问题。负载均<br>衡器将做出最终研判，并通知客户端。负载均衡器可以与后端服务器通信以收集负载和健康等信息。</p><hr><h3 id="二、要求"><a href="#二、要求" class="headerlink" title="二、要求"></a>二、要求</h3><h4 id="简洁的API和客户端"><a href="#简洁的API和客户端" class="headerlink" title="简洁的API和客户端"></a>简洁的API和客户端</h4><p>gRPC客户端的负载均衡代码必须保持简洁且可移植性。客户端应仅包含用于选择服务器的简单算法（如Round Robin等）。对于复杂算法，客户端应依靠负载均衡器来提供<br>以及客户端应向其发送请求的服务器列表。均衡器将根据需要更新服务器列表，并且负责处理服务器不可用或运行故障等问题。负载均衡器将做出最终研判，并通知客户。<br>负载均衡器可以与后端服务器通信以收集负载和健康等信息。</p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>负载均衡器可能与实际的服务器后端分离，并且负载均衡器的安全风险仅局限于负载均衡组件。换句话说，与没有负载均衡功能的相比，受到攻击的负载均衡器<br>应该不能让客户端取信（可能是恶意的）后端服务器。</p><hr><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>gRPC中负载均衡的主要机制是外部负载均衡，其中外部负载均衡器为客户端提供服务器的最新列表。</p><p>gRPC客户端支持用于操作内置负载均衡策略的API。 其中只有少数支持（如grpclb策略，该策略支持外部负载均衡），但是不鼓励用户通过添加<br>更多代码来扩展gRPC。 而是，推荐用户在外部负载均衡器中实现新的负载均衡策略。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><blockquote><p>在域名解析和与服务器的连接之间，负载均衡策略适配gRPC客户端工作流。 运作方式如下：</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/06/YAWl6K.md.png" alt></p><p>1.在启动时，gRPC客户端发出域名解析请求，解析服务器名称。该名称将解析为一个或多个IP地址，每个都将指示它是服务器地址还是一个负载均衡器地址及<br>一个服务配置（标明使用的客户端负载均衡策略，如round_robin或grpclb等）。</p><p>2.负载均衡策略</p><blockquote><p>注意：如果解析程序返回的地址中的任何一个是负载均衡器地址，那么客户端将使用<code>grpclb</code>策略，无论服务配置请求什么负载均衡策略。<br>否则，客户端将使用请求的负载均衡策略进行服务配置。如果未请求负载平衡策略通过服务配置，客户端将使用策略选择第一个可用的服务器地址。</p></blockquote><p>3.负载均衡策略为每个服务器实例创建了一个子通道</p><ul><li>对于所有策略（grpclb除外），这意味着解析器返回的每个地址都有一个子通道。 请注意，这些策略会忽略解析器返回的任何均衡器地址。</li><li>对于<code>grpclb</code>策略，工作流程如下：<ol><li>该策略在解析器返回的均衡器地址间开辟一个流通道。它需要均衡器提供服务器地址以用于客户端最初发起请求。<br>注意：在<code>grpclb</code>策略中，在负载均衡策略启动时，如果没有均衡器可以正常通信，那么返回的非负载均衡器地址可以作为后备选项。<br>2.负载均衡器将客户端定向到的gRPC服务器，gRPC服务器根据负载均衡器的配置，可以向其上报负载等信息。<br>3.负载均衡器将服务器列表返回到gRPC<code>grpclb</code>策略的客户端，然后，<code>grpclb</code>策略将为列表中的每个服务器建立子通道。</li></ol></li></ul><p>4.对于每个发送的RPC，负载均衡策略决定RPC应该发送到的哪个子通道（哪个服务器）。</p><ul><li>对于<code>grpclb</code>策略，客户端将把请求发送到服务器。如果服务器列表为空，则呼叫阻塞，直到出现非空。</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/grpc/grpc/blob/618a3f561d4a93f263cca23abad086ed8f4d5e86/doc/load-balancing.md" target="_blank" rel="noopener">load balancing</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/06/YAWtkd.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;gRPC小组正在努力扩展当前的gRPCLB功能。其不再使用自定义负载均衡协议，而是采用基于Envoy xDS API的xDS协议。这将允许与支持xDS API的开源控制&lt;br&gt;平面（例如Istio Pilot，go-control-plane和java-control-plane）进行交互。其他优化如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加灵活和先进的负载均衡策略配置功能&lt;/li&gt;
&lt;li&gt;基于LRS（负载报告服务）的负载报告功能等&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;客户端侧实现的xDS负载均衡插件与当前的gRPCLB协议不兼容。因此，我们可以认为当前的gRPCLB实现已被废弃。我们正在积极致力于新协议的推进。预计在接下来的几&lt;br&gt;个季度中会看到更多的进展，其中包括有关新设计的gRFC。下述将介绍gRPC关于负载均衡的设计。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="grpc" scheme="https://ustack.io/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>下一代云原生网关Gloo之架构赏析</title>
    <link href="https://ustack.io/2020-05-06-%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BD%91%E5%85%B3Gloo:%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html"/>
    <id>https://ustack.io/2020-05-06-下一代云原生网关Gloo:相关概念.html</id>
    <published>2020-05-06T12:40:08.000Z</published>
    <updated>2020-05-21T13:25:30.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/21/YqsrWR.md.png" alt></p><div class="note info"><p>Gloo聚合后端服务并为客户端提供端到端的功能转换，从而允许与后端API分离。客户端向在Gloo上定义的路由发出请求或<a href="https://github.com/solo-io/gloo-sdk-go" target="_blank" rel="noopener">发出事件</a>。 这些路由<br>通过Gloo的配置（由Gloo的API的客户端提供）在上游服务起作用。</p></div><p>Gloo在客户端定义的路由和后端功能之间执行必要的转换，能够<br>通过其可扩展的<a href="https://github.com/solo-io/gloo/blob/master/projects/gloo/pkg/plugins/plugin_interface.go" target="_blank" rel="noopener">插件接口</a>支持各种上游功能。<br><a id="more"></a></p><p>Gloo在所有功能上均提供一流的API管理功能:</p><ul><li>超时</li><li>指标和追踪</li><li>健康检查</li><li>重试</li><li>高级负载平衡</li><li>具有SNI支持的TLS终止</li><li>HTTP标头修改</li></ul><hr><h3 id="一、Gloo组件"><a href="#一、Gloo组件" class="headerlink" title="一、Gloo组件"></a>一、Gloo组件</h3><blockquote><p>从最基本的意义上讲，Gloo是转换引擎，Envoy xDS服务器为Envoy提供高级配置（包括Gloo的自定义Envoy过滤器）。 Gloo遵循基于事件的体系结构，监视各<br>种配置源以进行更新，并立即通过v2 版本的gRPC接口更新Envoy配置。</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/21/YqsrWR.md.png" alt="架构图"></p><h4 id="Config-Watcher"><a href="#Config-Watcher" class="headerlink" title="Config Watcher"></a>Config Watcher</h4><p>在介绍gRPC之前，我们将探讨一些常用的方法来实现负载平衡。</p><h4 id="Secret-Watcher"><a href="#Secret-Watcher" class="headerlink" title="Secret Watcher"></a>Secret Watcher</h4><h4 id="Endpoint-Discovery"><a href="#Endpoint-Discovery" class="headerlink" title="Endpoint Discovery"></a>Endpoint Discovery</h4><h4 id="Translator"><a href="#Translator" class="headerlink" title="Translator"></a>Translator</h4><h4 id="Reporter"><a href="#Reporter" class="headerlink" title="Reporter"></a>Reporter</h4><h4 id="xDS-Server"><a href="#xDS-Server" class="headerlink" title="xDS Server"></a>xDS Server</h4><hr><h3 id="二、Discovery架构"><a href="#二、Discovery架构" class="headerlink" title="二、Discovery架构"></a>二、Discovery架构</h3><p>一组可选的发现服务支持Gloo，它们会自动发现和配置Gloo上游和功能，简化了用户和自助服务的路由。</p><p><img src="../discovery_architecture.png" alt="Discovery架构" title="Discovery Architecture"></p><p>发现服务充当自动化的Gloo客户端，自动使用上游和功能填充存储层以便于用户轻松路由。 发现是可选的，但是启用后，它将尝试发现可用上游和功能。</p><p>当前支持平台:</p><ul><li>Kubernetes Service-Based Upstream Discovery</li><li>AWS Lambda-Based Function Discovery</li><li>Google Cloud Function-Based Function Discovery</li><li>OpenAPI-Based Function Discovery</li><li>Istio-Based Route Rule Discovery (Experimental)</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://docs.solo.io/gloo/latest/introduction/architecture/" target="_blank" rel="noopener">architecture</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/21/YqsrWR.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Gloo聚合后端服务并为客户端提供端到端的功能转换，从而允许与后端API分离。客户端向在Gloo上定义的路由发出请求或&lt;a href=&quot;https://github.com/solo-io/gloo-sdk-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;发出事件&lt;/a&gt;。 这些路由&lt;br&gt;通过Gloo的配置（由Gloo的API的客户端提供）在上游服务起作用。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Gloo在客户端定义的路由和后端功能之间执行必要的转换，能够&lt;br&gt;通过其可扩展的&lt;a href=&quot;https://github.com/solo-io/gloo/blob/master/projects/gloo/pkg/plugins/plugin_interface.go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插件接口&lt;/a&gt;支持各种上游功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes进阶之NT技术小解</title>
    <link href="https://ustack.io/2020-04-20-Kubernetes%E8%BF%9B%E9%98%B6%E4%B9%8BNT%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%A7%A3.html"/>
    <id>https://ustack.io/2020-04-20-Kubernetes进阶之NT技术小解.html</id>
    <published>2020-04-20T12:40:08.000Z</published>
    <updated>2020-04-20T13:41:53.742Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/J1gtsK.md.png" alt></p><div class="note info"><p>&lt;&lt;Kubernetes进阶&gt;&gt;系列将kubernetes系统的设计理念进行深入梳理与分享。<br>在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。</p></div><a id="more"></a><hr><h3 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h3><h4 id="中央处理器（Central-processing-unit）"><a href="#中央处理器（Central-processing-unit）" class="headerlink" title="中央处理器（Central processing unit）"></a>中央处理器（Central processing unit）</h4><p>在我们了解其它概念之前，我们应该首先了解一下什么是CPU，它是做什么的，它的主要组件以及相应的作用都是什么？<br>简单点说，CPU其实就是计算机内部的一个电子电路。根据一些具体的指令它可以执行基本的运算，逻辑，控制和IO操作等。<br>CPU的主要组件包括：</p><ul><li>算术逻辑单元（ALU is short for ‘arithmetic logic unit’），它主要执行一些算术和逻辑操作</li><li>处理器寄存器（processor registers），它主要的作用是给ALU提供操作数并存储ALU操作的结果</li><li>控制器（control unit），通过协调ALU，寄存器和其它组件之间的操作，从主存中取得并执行相应的指令。</li></ul><p>当今大多数地CPU都是微处理器，即它们被包含在单个集成电路芯片（integrated circuit chip）中。一个包含CPU的集成电路可能也包含内存，<br>外围接口和其它的一些计算机组件。这样的集成设备叫做微控制器（microcontrollers）或者芯片上的系统（SoC）。一些计算机采用多核处理器，<br>即单个芯片中包含2个或更多的CPU（也被叫做“cores”）; 在这种情况下，单个芯片有时也被称作”sockets”.</p><p>下图表示的是CPU与主存和IO之间的交互。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1cvxP.md.png" alt="CPU与主存和IO之间的交互"></p><h4 id="多个CPU"><a href="#多个CPU" class="headerlink" title="多个CPU"></a>多个CPU</h4><p>贯穿这个数字计算机的历史，我们一直以来的目标就是想要计算机可以做更多的事情，并且做的更快。因此在hyper-threading 和 multi-core CPUs<br>出现之前，人们想到通过增加CPU的数量来增加计算机的计算机能力和速度，但是这样的方法并没有在个人PC中得到普及，我们只会在一些超级计算机或者一<br>些服务器上会看到这个多个CPU的计算机。因为多个CPU会需要主板有多个CPU socket - 多个CPU被插入到不同的socket中。同时主板也需要额外的硬件<br>去连接这些CPU socket到RAM和一些其它的资源。如果CPU之间需要彼此通信，多个CPU的系统会有很大地开销。</p><h4 id="Hyper-Threading"><a href="#Hyper-Threading" class="headerlink" title="Hyper-Threading"></a>Hyper-Threading</h4><p>由于多个CPU上面存在的缺点，因此它并没有进入普通大众的电脑中，因此消费者电脑的计算始终没有达到并行的状态，电脑的速度也一直没有加快。直到多核<br>处理器和Hyper-Threading技术的出现，才改变了这一点。Hyper-threading这个概念是Intel提出的，这家伟大的公司想把计算机并行计算的能力带入到<br>个人PC中，它第一次进入大众PC的产品是2002年的Pentium 4 HT，最初的这款处理器仅有单个CPU核心，因此它一次只能做一件事情。但是Hyper-threading<br>技术的出现弥补了这个不足。</p><p>Hyperthreading 有时叫做 simultaneous multi-threading，它可以使我们的单核CPU执行多个控制流程。这个技术会涉及到备份一些CPU硬件的一些信息，<br>比如程序计数器和寄存器文件等，而对于比如执行浮点运算的单元它只有一个备份，可以被共享。一个传统的处理器在线程之间切换大约需要20000时钟周期，而一个<br>具有Hyperthreading技术的处理器只需要1个时钟周期，因此这大大减小了线程之间切换的成本。hyperthreading技术的关键点就是：当我们在处理器中执行代<br>码时，很多时候处理器并不会使用到全部的计算能力，部分计算能力会处于空闲状态，而hyperthreading技术会更大程度地“压榨”处理器。举个例子，如果一个线<br>程必须要等到一些数据加载到缓存中以后才能继续执行，此时CPU可以切换到另一个线程去执行，而不用去处于空闲状态，等待当前线程的IO执行完毕。</p><p>Hyper-threading 使操作系统认为处理器的核心数是实际核心数的2倍，因此如果有4个核心的处理器，操作系统会认为处理器有8个核心。这项技术通常会对程序<br>有一个性能的提升，通常提升的范围大约在15%-30%之间，对于一些程序来说它的性能甚至会小于20%, 其实性能是否提升这完全取决于具体的程序。比如，这2个逻<br>辑核心都需要用到处理器的同一个组件，那么一个线程必须要等待。因此，Hyper-threading只是一种“欺骗”手段，对于一些程序来说，它可以更有效地利用CPU的<br>计算能力，但是它的性能远没有真正有2个核心的处理器性能好，因此它不能替代真正有2个核心的处理器。但是同样都是2核的处理器，一个有hyper-threading技<br>术而另一个没有，那么有这项技术的处理器在大部分情况下都要比没有的好。</p><h4 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h4><p>相比于多个处理器而言，多核处理器把多个CPU（核心）集成到单个集成电路芯片（integrated circuit chip）中，因此主板的单个socket也可以适应这样的<br>CPU，不需要去更更改一些硬件结构。一个双核的CPU有2个中央处理单元，因此不像上面我介绍的hyper-threading技术那样，操作系统看到的只是一种假象，这<br>回操作系统看到的是真正的2个核心，所以2个不同的进程可以分别在不同的核心中同时执行，这大大加快了系统的速度。由于2个核心都在一个芯片上，因此它们之间<br>的通信也要更快，系统也会有更小地延迟。</p><p>下图展示了一个Intel Core i7处理器的一个组织结构，这个微处理器芯片中有4个CPU核，每个核中都有它自己的L1和L2缓存。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gVx0.md.png" alt="Intel Core i7处理器的一个组织结构"></p><hr><h3 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在操作系统中，有多线程（multi-threading）的概念，这很好理解，因为线程是进程最小的调度单位，一个进程至少包含一个线程。本文将介绍CPU特有的超线程<br>技术。简单来说就是，多线程比较软，超线程比较硬，二者本质上都是虚拟化。</p><p>超线程(hyper-threading)其实就是同时多线程(simultaneous multi-theading),是一项允许一个CPU执行多个控制流的技术。它的原理很简单，就是把一<br>颗CPU当成两颗来用，将一颗具有超线程功能的物理CPU变成两颗逻辑CPU，而逻辑CPU对操作系统来说，跟物理CPU并没有什么区别。因此，操作系统会把工作线程分<br>派给这两颗（逻辑）CPU上去执行，让（多个或单个）应用程序的多个线程，能够同时在同一颗CPU上被执行。注意：两颗逻辑CPU共享单颗物理CPU的所有执行资源。<br>因此，我们可以认为，超线程技术就是对CPU的虚拟化。</p><p>超线程技术是同时多线程技术的一种实现形式，由Intel公司提出，而该技术背后的概念则是Sun公司的专利。Sun公司虽然倒下了，但它永远是一个伟大的公司。</p><p>纵观计算机的历史，有两个需求是驱动计算机科技进步的持续动力。<br>    第一，人类想让计算机做得更多；<br>    第二，人类想让计算机跑得更快。<br>从这个意义上讲，那些把工程师当做机器的资本家或资本家豢养的打手在榨取程序员的剩余价值的时候，就是不断地追求上述两个需求。超线程技术的发明，就是基于<br>这样的考虑，不榨干处理器的最后一滴油决不罢休。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gmrT.md.png" alt="CPU"></p><p>常规的CPU需要大约两万个时钟周期做不同线程间的切换，而超线程的CPU可以在单个时钟周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理<br>资源。例如：假设一个线程必须等到某些数据被装入到cache中，那么CPU就可以继续去执行另一个线程。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1gMa4.md.png" alt="NT"></p><p>超线程允许单个处理器在同一时刻并行地抓取和执行两个独立的代码流。那么超线程是如何工作的？见下图。</p><p><img src="https://s1.ax1x.com/2020/04/20/J1g3GR.md.png" alt="nt工作"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现超线程技术的前提:</p><ul><li>需要CPU支持</li><li>需要主板芯片组支持</li><li>需要BIOS支持</li><li>需要操作系统支持</li><li>需要应用软件支持</li></ul><p>由此可见，超线程技术虽然很酷，但需要方方面面的支持，否则就玩不转。 类似地，如果想最大可能地榨取程序员的剩余价值的话，给程序员提供实现超线程运行的软<br>硬件环境也是必须地，否则一味地让他们拼体力(加班)实在不是个好办法，因为人毕竟不是机器，人只有需要休息好了才可能有创造力，疲惫的人们大多时候是在瞎折<br>腾，往往事倍功半。</p><p>超线程(hyper-threading)本质上就是CPU支持的同时多线程(simultaneous multi-threading)技术，简单理解就是对CPU的虚拟化，一颗物理CPU可以被操<br>作系统当做多颗CPU来使用。</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续将介绍1.18版本后的kubelet关于CPU的管理技术方案。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener">Central processing unit</a></li><li><a href="http://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">hyper threadingexplained</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/20/J1gtsK.md.png&quot; alt&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&amp;lt;&amp;lt;Kubernetes进阶&amp;gt;&amp;gt;系列将kubernetes系统的设计理念进行深入梳理与分享。&lt;br&gt;在这篇文章中我会主要介绍CPU相关的一些重要概念和技术，以此作为后续对于kubelet组件相关分析的铺垫。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ustack.io/tags/Linux/"/>
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
  <entry>
    <title>solo开源Service Mesh Hub</title>
    <link href="https://ustack.io/2020-04-10-servicemesh%E5%B9%B3%E5%8F%B0%E5%A4%A7%E8%A7%82.html"/>
    <id>https://ustack.io/2020-04-10-servicemesh平台大观.html</id>
    <published>2020-04-10T12:40:08.000Z</published>
    <updated>2020-04-14T13:33:23.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/10/G7eWJe.md.png" alt="hub"></p><div class="note info"><p>solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。</p></div><a id="more"></a><hr><h3 id="多集群，多网格管理平面"><a href="#多集群，多网格管理平面" class="headerlink" title="多集群，多网格管理平面"></a>多集群，多网格管理平面</h3><p>Service Mesh Hub的设计旨在丰富管理平面的操作，从单个Kubernetes集群上的单个服务网格到管理跨越多个集群的多个服务网格。 它由管理平面集群上运行的组件组成。</p><p>您可以在Service Mesh Hub中注册一个集群，该集群将处理与其他集群的通信-发现正在运行的服务网格，管理配置，抓取监控指标等等。 用户无需在集群之间切换Kubernetes即可更新服务网格或应用程序的配置，这使运行和扩展操作变得更加简单。</p><hr><h2 id="动态发现"><a href="#动态发现" class="headerlink" title="动态发现"></a>动态发现</h2><p>注册集群后，Service Mesh Hub将支持动态发现。探测器的第一个要务是找到集群上安装的所有服务网格。当发现了服务网格的控制<br>平面后，探测器会将网格资源写入管理平面集群，该集群链接到在集群注册期间写入的Kubernetes集群资源。目前，Service Mesh Hub<br>可以发现和管理Istio和Linkerd网格，并计划提供更多支持。然后，探测器将查找与网格相关联的工作负载，例如已使用该网格的<br>Sidecar代理创建了Pod的部署。它将一个MeshWorkload资源写入代表该工作负载的管理平面集群。最后，探测器还寻找暴露网格服务<br>工作负载的服务，与上述一样，其将MeshService资源写入管理平面集群。<br>此时，管理平面具备了跨多集群，多网格环境的网格，服务和工作负载的完整视图。</p><hr><h2 id="虚拟网格"><a href="#虚拟网格" class="headerlink" title="虚拟网格"></a>虚拟网格</h2><p>为了启用多群集配置，用户将多个网格组合在一起成为一个VirtualMesh的对象。虚拟网格包含一些便于跨集群通信的配置。<br>为了使虚拟网格生效，Service Mesh Hub首先尝试根据用户定义的互信模型建立户型，Service Mesh Hub附带一个代理，<br>可帮助安全地代理跨集群证书签名请求，以最大程度地减少管理证书的操作负担。一旦建立互信关系，Service Mesh Hub将<br>开始联合服务，以便跨集群访问。而在后端，Service Mesh Hub将处理网络（可能通过出口和入口网关，并可能受到用户定<br>义的流量和访问策略的影响），并确保将服务的请求准确路由到正确的目的地。用户可以通过编辑虚拟网格微调哪些服务将代理<br>到哪里。</p><p>从该版本开始，Service Mesh Hub支持使用跨多个群集的多个Istio 1.5+控制平面创建虚拟网格。后续，该团队计划增加<br>对更多网格类型的支持。</p><hr><h2 id="流量和访问策略"><a href="#流量和访问策略" class="headerlink" title="流量和访问策略"></a>流量和访问策略</h2><p>Service Mesh Hub使用户可以将简单的配置对象写入管理平面，为在所管理的任何群集之间制定服务之间的流量和访问策略。<br>它被用于转换基础的网格配置，同时从用户那里抽象出特定于网格类型的对象。TrafficPolicy定义了一组目的源（网格工作<br>负载）和目标（网格服务）之间关系，并用于描述诸如“当A向B发送POST请求，添加标头并将设置超时为10秒”之类的规则。或<br>“在集群C上对该服务的每个请求，增加超时并添加重试”。从该版本开始，流量策略支持超时设定、重试、cors、流量转移、<br>报头处理、故障注入、子集路由、加权目标等功能。请注意，某些网格物体不支持所有这些功能。 Service Mesh Hub将尽其<br>所能将其转换为基础网格配置，或将错误报告给用户。AccessPolicy用于精确控制允许哪些服务进行通信。在虚拟网格上，用<br>户可以指定全局策略来限制访问，并要求用户指定访问策略以实现与服务的通信。</p><p>借助流量和访问策略，Service Mesh Hub为用户提供了一种功能强大的语言，即使在复杂的多集群，多网状应用程序中也可以<br>指示服务应如何通信。</p><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Service Mesh Hub正在解决与多集群网络和配置有关的棘手问题，它附带了一个称为meshctl的命令行工具。 该工具提供了<br>交互式命令，使管理虚拟网格，注册集群、创建流量及访问策略变得更加容易。 它还会带有一个“describe”命令，以帮助您了<br>解您的工作负载和服务如何受到策略的影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/10/G7eWJe.md.png&quot; alt=&quot;hub&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;solo宣布了Service Mesh Hub的开源版本，这代表了其在简化复杂企业环境中使用服务网格的经验方面迈出的一大步。 正如在其公告中提到的那样，该项目遵循了之前在SuperGloo上的工作，之前的Service Mesh Hub版本以及与Service Mesh社区的充分反应了社区间的广泛合作。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Serverless当打之年</title>
    <link href="https://ustack.io/2020-04-09-Serverless%E5%BD%93%E6%89%93%E4%B9%8B%E5%B9%B4.html"/>
    <id>https://ustack.io/2020-04-09-Serverless当打之年.html</id>
    <published>2020-04-09T12:40:08.000Z</published>
    <updated>2020-04-09T02:40:33.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/09/G4EVSK.md.png" alt="趋势"></p><div class="note info"><p>当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。</p><p>值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：</p></div><a id="more"></a><hr><h3 id="一、初识Serverless"><a href="#一、初识Serverless" class="headerlink" title="一、初识Serverless"></a>一、初识Serverless</h3><p>Serverless的理念是从2016年开始兴起，从其发展趋势来看，它在两三年后，可能对微服务架构的地位构成一定的挑战。</p><p>我们可以知道这么几点：</p><ul><li>开发者专注于业务，摆脱运维的负担</li><li>Serverless按需使用</li><li>Serverless运行时间计费</li><li>Serverless应用严重依赖于特定的云平台、第三方服务</li></ul><p>在一个基于AWS产品开发的Serverless应用里，由以下组件构成：</p><ul><li>API Gateway来处理并发请求，其包括认证、流量管理、授权和访问控制、监控等功能</li><li>计算服务Lambda来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等</li><li>基础设施管理CloudFormation创建和配置 AWS 基础设施部署，诸如所使用的S3存储桶的名称等</li><li>静态存储S3存储前端代码和静态资源</li><li>数据库DynamoDB存储应用的相关数据</li></ul><p>因此，Serverless 并不意味着没有服务器，只是服务器以不同功能的第三方服务的形式存在。<br>在这种情况下，模块的分层演变为不同的服务。在现今的微服务设计中，每一个领域或者子域都是一个服务。而在Serverless应用中，这些领域及子域根据他们的功能，又可能会进一步切分成不同的Serverless函数。</p><hr><h3 id="二、云的征程"><a href="#二、云的征程" class="headerlink" title="二、云的征程"></a>二、云的征程</h3><p>很久之前，我们开发的软件由C/S和MVC的架构，转变为SOA，直到最近几年的微服务架构，更近一点就是Cloud Native（云原生）应用，企业应用从单体架构，到服务化，再到更细粒度的微服务化，应用开发之初就是为了应对业务的特有的高并发、容错等特性，需要很高的性能及可扩展性，人们对软件开发的追求孜孜不倦，希望力求在软件开发的复杂度和效率之间达到一个平衡。但可惜的是，没有银弹！几十年前（1975年）Fred Brooks就在The Mythical Man-Month中就写到了这句话。那么Serverlss会是那颗银弹吗？</p><p>云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚，应用必须运行在服务器上（不论是实体还是虚拟的），并且必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，同时需要保证数据的安全性，当前的云产品能解放我们吗？</p><p>Serverless架构是云的延伸，为了理解serverless，我们有必要回顾一下云计算的发展。</p><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><p>2006年AWS推出EC2（Elastic Compute Cloud），作为第一代IaaS（Infrastructure as a Service），用户可以通过AWS快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。</p><p>EC2真正对IT的改变是硬件的虚拟化（更细粒度的虚拟化），而EC2给用户带来了以下五个好处：</p><ul><li>降低劳动力成本：减少了企业本身雇佣IT人员的成本</li><li>降低风险：不用再像自己运维物理机那样，担心各种意外风险，EC2有主机损坏，再申请一个就好了。</li><li>降低基础设施成本：可以按小时、周、月或者年为周期租用EC2。</li><li>扩展性：不必过早的预期基础设施采购，因为通过云厂商可以很快的获取。</li><li>节约时间成本：快速的获取资源开展业务实验。</li></ul><p>有利有弊，我们将在后面讨论。</p><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><p>PaaS（Platform as a Service）是构建在IaaS之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可，最早的一代是Heroku。Heroko是商业的PaaS，还有一个开源的PaaS——Cloud Foundry，用户可以基于它来构建私有PaaS，如果同时使用公有云和私有云，如果能在两者之间构建一个统一的PaaS，那就是“混合云”了。<br>在PaaS上的卓越贡献者当属docker了，因为docker理念的横空出世，推动了PaaS技术的发展，从mesos、swarm与kubernetes的群雄逐鹿到后来kubernetes一家独大，再到CNCF的成立，这些我们后续再慢慢道来。因为使用容器的轻量、隔离型，推进了应用的容器化日程。管理云上的容器，可以称为是CaaS（Container as a Service），如GCE（Google Container Engine）。也可以基于Kubernetes、Mesos这类开源软件构件自己的CaaS，不论是直接在IaaS构建还是基于PaaS。<br>PaaS是对软件的一个更高的抽象层次，已经接触到应用程序的运行环境本身，可以由开发者自定义，而不必接触更底层的操作系统。</p><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>当然，Serverless不如IaaS和PaaS那么好理解，因为它通常包含了两个方面BaaS（Backend as a Service）和FaaS（Function as a Service）。</p><p><strong><em>BaaS</em></strong></p><p>BaaS（Backend as a Service）后端即服务，一般是一个个的API调用后端或别人已经实现好的程序逻辑，比如身份验证服务Auth0，这些BaaS通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的RDS可以替代我们自己部署的MySQL，还有各种其它数据库、中间价和存储服务等。</p><p><strong><em>FaaS</em></strong></p><p>FaaS（Functions as a Service）函数即服务，FaaS是无服务器计算的额一种形式，当前使用最广泛的是AWS的Lambada。<br>现在当大家讨论Serverless的时候首先想到的就是FaaS。FaaS本质上是一种事件驱动的由消息触发的服务，FaaS服务商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。<br>与传统的服务器端软件的不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而FaaS是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以杀死。</p><p>根据MF网站的无服务器架构定义，FaaS是：</p><ul><li><p>从根本上说，FaaS是关于运行后端代码而无需管理自己的服务器系统或您自己的长期驻留long-lived的服务器应用程序。与容器和PaaS（平台即服务）等其他现代架构趋势进行比较时，第二个子句 - 长期驻留（long-lived）的服务器应用程序是一个关键的区别。（FaaS不是长期驻留的普通API）</p></li><li><p>FaaS产品不需要对特定框架或库进行编码。FaaS函数是语言和环境的常规应用程序。例如，AWS Lambda函数可以在Javascript，Python，Go，任何JVM语言（Java，Clojure，Scala等）或任何.NET语言中实现。但是，Lambda函数还可以执行与其部署工件捆绑在一起的另一个进程，因此您实际上可以使用任何可以编译为Unix进程的语言。</p></li><li><p>部署与传统系统有很大不同，因为我们没有自己运行的服务器应用程序。在FaaS环境中，我们将函数功能的代码上传到FaaS提供商，提供商执行配置资源，实例化VM，管理流程等所需的一切。</p></li><li><p>水平扩展是完全自动的，弹性的，并由提供者管理。如果您的系统需要并行处理100个请求，则提供商将处理该请求而无需您进行任何额外配置。函数的执行是一个“计算容器”，运行是短暂的，FaaS提供者实现容器的创建和销毁完全是由运行时需求驱动。最重要的是，使用FaaS ，供应商可以处理所有底层资源配置和分配 - 用户根本不需要集群或VM管理。(容器+FaaS是Serverless重要的机制，只有容器或FaaS都是片面的，两者分别是静态和动态的)</p></li><li><p>FaaS中的函数通常由提供程序定义的事件类型触发。</p></li><li><p>大多数提供程序还允许触发函数作为对入站HTTP请求的响应; 在AWS中，通常通过使用API网关来实现这一点。函数也可以通过平台提供的API直接调用，无论是在外部还是在同一个云环境中，但这是一种相对不常见的用法。</p></li></ul><hr><h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><strong><em>Serverless与FaaS</em></strong></p><p>微服务（MicroService）是软件架构领域业另一个热门的话题。如果说微服务是以专注于单一责任与功能的小型功能块为基础，利用模组化的方式组合出复杂的大型应用程序，那么我们还可以进一步认为Serverless架构可以提供一种更加“代码碎片化”的软件架构范式，我们称之为Function as a Services（FaaS）。而所谓的“函数”（Function）提供的是相比微服务更加细小的程序单元。例如，可以通过微服务代表为某个客户执行所有CRUD操作所需的代码，而FaaS中的“函数”可以代表客户所要执行的每个操作：创建、读取、更新，以及删除。当触发“创建账户”事件后，将通过AWS Lambda函数的方式执行相应的“函数”。从这一层意思来说，我们可以简单地将Serverless架构与FaaS概念等同起来。</p><p><strong><em>FaaS与PaaS的比较</em></strong></p><p>乍看起来，FaaS与PaaS的概念在某些方面有许多相似的地方。人们甚至认为FaaS就是另一种形式的PaaS。但是Intent Media的工程副总裁Mike Roberts有自己的不同看法：“大部分PaaS应用无法针对每个请求启动和停止整个应用程序，而FaaS平台生来就是为了实现这样的目的。”<br>FaaS和PaaS在运维方面最大的差异在于缩放能力。对于大部分PaaS平台，用户依然需要考虑缩放。但是对于FaaS应用，这种问题完全是透明的。就算将PaaS应用设置为自动缩放，依然无法在具体请求的层面上进行缩放，而FaaS应用在成本方面效益就高多了。AWS云架构战略副总裁Adrian Cockcroft曾经针对两者的界定给出了一个简单的方法：“如果你的PaaS能够有效地在20毫秒内启动实例并运行半秒,那么就可以称之为Serverless”。</p><p><strong><em>Serverless 的优势</em></strong></p><p>a、降低运营成本<br>Serverless是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</p><p>b、降低开发成本<br>IaaS和PaaS存在的前提是，服务器和操作系统管理可以商品化。Serverless作为另一种服务的结果是整个应用程序组件被商品化。</p><p>c、扩展能力<br>Serverless架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，您只需支付您所需要的计算能力。</p><p>d、便捷管理<br>Serverless架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</p><p>e、绿色计算<br>按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供5%～15%的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</p><p>f、更快的开发速度<br>由于 Serverless 服务提供者，已经准备好了一系列的基础服务。作为开发人员的我们，只需要关注于如何更好去实现业务，而非技术上的一些限制。服务提供者已经向我们准备，并测试好了这一系列的服务。它们基本上是稳定、可靠的，不会遇上特别大的问题。事实上，当我们拥有足够强大的代码，如使用测试来保证健壮性，那么结合持续集成，我们就可以在 PUSH 代码的时候，直接部署到生产环境。当然，可能不需要这么麻烦，我们只需要添加一个 predeploy 的 hook，在这个 hook 里做一些自动测试的工作，就可以在本地直接发布新的版本。<br>这个过程里，我们并不需要考虑太多的发布事宜。</p><p>g、系统安全性更高<br>依我维护我博客的经验来看，要保持服务器一直运行不是一件容易的事。在不经意的时候，总会发现有 Cracker 在攻击你网站。我们需要防范不同类型的攻击，如在我的服务器里一直有黑客在尝试密码登录，可是我的博客的服务器是要密钥才能登录的。在一次神奇的尝试登录攻击后，我的 SSH 守护进程崩溃了。这意味着，我只能从 EC2 后台重启服务器。有了 Serverless，我不再需要担心有人尝试登录系统，因为我都不知道怎么登录服务器。</p><p>h、适应微服务架构<br>如我们所见在最近几年里看到的那样，微服务并没有大量地替换掉单体应用——毕竟使用新的架构来替换旧的系统，在业务上的价值并不大。因此，对于很多企业来说，并没有这样的强烈需求及紧迫性。活着，才是一件更紧迫的事。而 Serverless 天生就与微服务架构是相辅相成的。一个 Serverless 应用拥有自己的网关、数据库、接口，你可还以使用自己喜欢的语言（受限于服务提供者）来开发服务。换句话来说，在这种情形下，一个 Serverless 可能是一个完美的微服务实例。<br>在可见的一二年里，Serverless 将替换到某些系统中的一些组件、服务。</p><p><strong><em>Serverless的问题</em></strong></p><p>作为一个运行时，才启动的应用来说，Serverless 也存在着一个个我们所需要的问题。</p><p>a、不适合长时间运行应用<br>Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动。这个时候，可以结合 CRON 的方式或者 CloudWatch 来定期唤醒应用。<br>如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。在这种情况下，采用 EC2 这样的云服务器往往是一种更好的选择。因为 EC2 从价格上来说，更加便宜。</p><p>b、完全依赖于第三方服务<br>是的，当你决定使用某个云服务的时候，也就意味着你可能走了一条不归路。在这种情况下，只能将不重要的 API 放在 Serverless 上。当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用 Serverless 架构的时候，我们就和特别的服务供应商绑定了。我们使用了 AWS 家的服务，那么我们再将服务迁到 Google Cloud 上就没有那么容易了。<br>我们需要修改一下系列的底层代码，能采取的应对方案，便是建立隔离层。这意味着，在设计应用的时候，就需要：</p><ul><li>隔离 API 网关</li><li>隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你即支持 Firebase，又支持 DynamoDB</li><li>等等</li></ul><p>这些也将带给我们一些额外的成本，可能带来的问题会比解决的问题多。</p><p>c、冷启动时间<br>如上所说，Serverless 应用存在一个冷启动时间的问题。</p><p>d、缺乏调试和开发工具<br>当使用 Serverless Framework 的时候，遇到了这样的问题：缺乏调试和开发工具。<br>并且，对于日志系统来说，这仍然是一个艰巨的挑战。每次你调试的时候，你需要一遍又一遍地上传代码。而每次上传的时候，你就好像是在部署服务器。然后 Fuck 了，我并不能总是快速地定位出问题在哪。于是，我修改了一下代码，添加了一行 console.log，然后又一次地部署了下代码。问题解决了，挺好的，我删了一下 console.log，然后又一次地部署了下代码。</p><p>e、构建复杂<br>Serverless 很便宜，但是这并不意味着它很简单。</p><p>两者都为我们的计算资源提供了弹性的保障，BaaS其实依然是服务外包，而FaaS使我们更加关注应用程序的逻辑，两者使我们不需要关注应用程序所在的服务器，但实际上服务器依然是客观存在的。<br>当我们将应用程序迁移到容器和虚拟机中时，其实对于应用程序本身的体系结构并没有多少改变，只不过有些流程和规定需要遵守，比如12因素应用守则，但是serverlss对应用程序的体系结构来说就是一次颠覆了，通常我们需要考虑事件驱动模型，更加细化的不熟形式，以及在FaaS组件之外保持状态的需求。</p><hr><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>通过将 Serverless 的理念与当前 Serverless 实现的技术特点相结合，Serverless 架构可以适用于各种业务场景。</p><p>1.Web应用<br>Serverless 架构可以很好地支持各类静态和动态Web应用。如 RESTful API 的各类请求动作（GET、POST、PUT及DELETE等）可以很好地映射成 FaaS 的一个个函数，功能和函数之间能建立良好的对应关系。通过 FaaS 的自动弹性扩展功能，Serverless Web 应用可以很快速地构建出能承载高访问量的站点。</p><p>2.移动互联网<br>Serverless 应用通过 BaaS 对接后端不同的服务而满足业务需求，提高应用开发的效率。前端通过FaaS提供的自动弹性扩展对接移动端的流量，开发者可以更轻松地应对突发的流量增长。在 FaaS 的架构下，应用以函数的形式存在。各个函数逻辑之间相对独立，应用更新变得更容易，使新功能的开发、测试和上线的时间更短。</p><p>3.物联网（Internet of Things，IoT）<br>物联网（Internet of Things，IoT）应用需要对接各种不同的数量庞大的设备。不同的设备需要持续采集并传送数据至服务端。Serverless 架构可以帮助物联网应用对接不同的数据输入源。</p><p>4.多媒体处理<br>视频和图片网站需要对用户上传的图片和视频信息进行加工和转换。但是这种多媒体转换的工作并不是无时无刻都在进行的，只有在一些特定事件发生时才需要被执行，比如用户上传或编辑图片和视频时。通过 Serverless 的事件驱动机制，用户可以在特定事件发生时触发处理逻辑，从而节省了空闲时段计算资源的开销，最终降低了运维的成本。</p><p>5.数据及事件流处理<br>Serverless 可以用于对一些持续不断的事件流和数据流进行实时分析和处理，对事件和数据进行实时的过滤、转换和分析，进而触发下一步的处理。比如，对各类系统的日志或社交媒体信息进行实时分析，针对符合特定特征的关键信息进行记录和告警。</p><p>6.系统集成<br>Serverless 应用的函数式架构非常适合用于实现系统集成。用户无须像过去一样为了某些简单的集成逻辑而开发和运维一个完整的应用，用户可以更专注于所需的集成逻辑，只编写和集成相关的代码逻辑，而不是一个完整的应用。函数应用的分散式的架构，使得集成逻辑的新增和变更更加灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/09/G4EVSK.md.png&quot; alt=&quot;趋势&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;当前大多数公司在运营应用产品时，无论是选择公有云还是自建的数据中心，都会面临服务器数量预估、存储容量规划和数据库的选型等问题。同时需要在基础设施之上部署依赖软件，以运行应用程序。当前是否存在一种简单的架构模型能够满足我们这种应用场景？当然，这个架构已经存在许久，它就是今天软件架构世界中很热门的一个话题——Serverless。&lt;/p&gt;
&lt;p&gt;值得关注的是，在最近的几年里，微服务逐渐成为了一种新潮且实用的架构方案。微服务从2014年开始流行，如下图所示：&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>五分钟初识Gloo</title>
    <link href="https://ustack.io/2020-04-09-%E4%BA%94%E5%88%86%E9%92%9F%E5%88%9D%E8%AF%86Gloo.html"/>
    <id>https://ustack.io/2020-04-09-五分钟初识Gloo.html</id>
    <published>2020-04-09T12:40:08.000Z</published>
    <updated>2020-05-17T10:06:11.283Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/17/Ygqhod.md.png" alt="架构"></p><div class="note info"><p>Gloo是一种基于Kubernetes原生设计的功能丰富的Ingress Controller，致力于成为下一代API网关标杆产品。 Gloo在函数级路由等方面表现优异；对旧式应<br>用、微服务和serverless提供支持； 它具备高效的发现能力，且功能多样； 并与领先的开源项目（如Envoy、KNative等）紧密集成。 Gloo的独特设计旨在支持<br>异构应用程序，与多种技术，体系结构，协议和云中共存。</p></div><a id="more"></a><hr><h3 id="一、何为Gloo"><a href="#一、何为Gloo" class="headerlink" title="一、何为Gloo"></a>一、何为Gloo</h3><ul><li><p>*Kubernetes ingress controller**: 当部署在Kubernetes上时，Gloo可以充当功能丰富的入口控制器，并且当部署到AWS EKS等公共云时，可以简化路由功能。</p></li><li><p><strong>异构应用</strong>: Gloo创建的应用程序路由到实现为微服务，无服务器功能和旧式应用程序的后端。 此功能可以帮助用户逐渐从旧代码迁移到微服务、无服务器架构。<br>用户在保持其原有代码逻辑前提下，使用云原生技术添加新功能； 组织中的不同团队可以选择不同架构及其他场景。</p></li><li><p><strong>服务网格Ingress</strong>: 服务网格技术解决了跨云网络的服务到服务通信问题。 可以使用服务网格解决诸如服务标识，七层网络遥测信息收集，服务弹性，服务之<br>间的流量路由以及策略执行（例如配额，速率限制等）之类的问题。 为了使服务网格正常运行，它需要一种使流量进入网格的方法。 将流量从边缘传输到集群内部的<br>问题与服务到服务的问题有所不同。 前端网关应当提供缓存，安全性和流量管理，Oauth和最终用户身份验证/授权，用户速率限制，Web应用程序防火墙等。 Gloo<br>解决了以上问题，兼容所有服务网格技术，包括Istio，Linkerd，Consul Connect和AWS App Mesh。</p></li></ul><hr><h3 id="二、Gloo特色"><a href="#二、Gloo特色" class="headerlink" title="二、Gloo特色"></a>二、Gloo特色</h3><ul><li><p><strong>功能级路由允许集成旧版应用程序，微服务和无服务器</strong>：Gloo可以路由<br>直接向<em>functions</em>请求，可以是：无服务器功能调用（例如Lambda，Google Cloud Function，OpenFaaS函数等）；<br>微服务或旧服务上的API调用（例如REST API调用，OpenAPI操作，XML / SOAP请求等）；<br>或发布到邮件队列（例如，NATS，AMQP等）。 这种独特的功能使Gloo成为唯一的API网关<br>支持混合应用程序，以及不将用户绑定到特定范例的唯一应用程序。</p></li><li><p><strong>Gloo包含经过审查的开源项目，以提供广泛的功能</strong>：Gloo通过与顶级开源项目（包括gRPC，GraphQL，OpenTracing，NATS等）集成来支持高质量功能。<br>Gloo的体系结构允许在将来流行的开源项目出现时快速集成它们。</p></li><li><p><strong>全自动发现使用户可以快速移动</strong>：Gloo在启动时会创建所有可用目的地的目录，并不断对其进行更新。 这使开发人员无需承担“记账”的责任，并确保新功能<br>在准备就绪后立即可用。 Gloo跨IaaS，PaaS和FaaS提供程序以及Swagger，gRPC和GraphQL发现。</p></li><li><p><strong>Gloo与用户环境紧密集成</strong>：通过Gloo，用户可以自由选择自己喜欢的调度工具（例如K8S，Nomad，OpenShift等），持久性（K8s，Consul等）和安全性<br>（K8s, Vault）。</p></li></ul><h4 id="路由特性"><a href="#路由特性" class="headerlink" title="路由特性"></a>路由特性</h4><ul><li><p><strong>动态负载均衡</strong>:跨多个上游服务负载均衡流量。</p></li><li><p><strong>健康检查</strong>: 主动和被动监视上游服务。</p></li><li><p><strong>OpenTracing标准</strong>: 使用支持良好的OpenTracing标准监视请求。</p></li><li><p><strong>监控</strong>: 支持Prometheus、Statsd方式监控。</p></li><li><p><strong>SSL</strong>: 高度可定制的选项，用于向上游服务添加SSL加密，并完全支持SNI。</p></li><li><p><strong>转换</strong>: 添加，删除或处理HTTP请求和响应。</p></li></ul><h4 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h4><p>Gloo可以轻松应对管理入口流量进入应用程序架构（不单单是Kubernetes）的挑战。在Kubernetes，AWS Lambda，VM，Terraform，EC2，Consul<br>等架构/平台中运行时，可以动态发现后端服务。Gloo同时也被选为KNative项目的首选ingress项目，其主要有以下特性。</p><ul><li>解决云原生和混合云的挑战：微服务使应用程序的API更加复杂。 Gloo实现了API网关模式，通过实现管理平面来提升业务的可操作性。</li><li>构建Envoy代理：Gloo是Envoy Proxy的控制平面，使开发人员和操作员可以通过以声明性格式的xDS gRPC API动态更新Envoy配置。</li><li>服务网格的基石：Gloo将服务网格功能添加到集群入口。 Gloo允许您以迭代的方式渐进式使用高级功能，并与诸如Flagger的系统进<br>行金丝雀自动化发布，同时以本地化方式插入服务网格实现（如Istio，Linkerd或Consul）。</li><li>针对应用程序的集成：Gloo可以将请求直接路由到Function、微服务或遗留服务上的API，或发布到消息队列。这种独特的功能使Gloo成为支持混合应用程序的唯一<br>API网关，而不会将用户束缚于特定的技术方案。</li><li>强大的社区特性：Gloo通过与顶级开源项目（如gRPC，GraphQL，OpenTracing，NATS等）集成来支持高级别功能。 Gloo的技术架构允许在未来流行的开源项目<br>出现时快速集成。</li><li>全自动发现能力：Gloo动态发现能力，跨IaaS，PaaS和FaaS</li><li>与现有工具集成：使用Gloo，用户可以自由选择自己喜欢的调度工具（例如K8S，Nomad，OpenShift等），持久化（K8S，Consul等）和安全特性（K8，Vault）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/17/Ygqhod.md.png&quot; alt=&quot;架构&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Gloo是一种基于Kubernetes原生设计的功能丰富的Ingress Controller，致力于成为下一代API网关标杆产品。 Gloo在函数级路由等方面表现优异；对旧式应&lt;br&gt;用、微服务和serverless提供支持； 它具备高效的发现能力，且功能多样； 并与领先的开源项目（如Envoy、KNative等）紧密集成。 Gloo的独特设计旨在支持&lt;br&gt;异构应用程序，与多种技术，体系结构，协议和云中共存。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
      <category term="serverless" scheme="https://ustack.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 1.18 福履将之</title>
    <link href="https://ustack.io/2020-03-25-Kubernetes%201.18%20%E7%A6%8F%E5%B1%A5%E5%B0%86%E4%B9%8B.html"/>
    <id>https://ustack.io/2020-03-25-Kubernetes 1.18 福履将之.html</id>
    <published>2020-03-25T12:40:08.000Z</published>
    <updated>2020-03-25T10:32:17.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/22/MTa1tH.png" alt="k8s"></p><div class="note info"><p>Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？</p><p>有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。</p><p>我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。</p></div><p>此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！</p><p>以下为Kubernetes 1.18中新功能的详细列表。</p><a id="more"></a><hr><h3 id="一、版本维护"><a href="#一、版本维护" class="headerlink" title="一、版本维护"></a>一、版本维护</h3><h4 id="维护周期"><a href="#维护周期" class="headerlink" title="维护周期"></a>维护周期</h4><p>Kubernetes 发现版本的通常只维护支持九个月，在维护周期内，如果发现有比较重大的 bug 或者安全问题的话，<br>可能会发布补丁版本。下面是 Kubernetes 的发布和维护周期。</p><table><thead><tr><th>Kubernetes 版本</th><th>发行月份</th><th>终止维护月份</th></tr></thead><tbody><tr><td>v1.11.x</td><td>2018 年 6 月</td><td>2019 年 3 月</td></tr><tr><td>v1.12.x</td><td>2018 年 9 月</td><td>2019 年 6 月</td></tr><tr><td>v1.13.x</td><td>2018 年 12 月</td><td>2019 年 9 月</td></tr><tr><td>v1.14.x</td><td>2019 年 3 月</td><td>2019 年 12 月</td></tr><tr><td>v1.15.x</td><td>2019 年 6 月</td><td>2020 年 3 月</td></tr><tr><td>v1.16.x</td><td>2019 年 9 月</td><td>2020 年 6 月</td></tr><tr><td>v1.17.x</td><td>2019 年 12 月</td><td>2020 年9 月</td></tr></tbody></table><hr><h3 id="二、Kubernetes-1-18-主要变更"><a href="#二、Kubernetes-1-18-主要变更" class="headerlink" title="二、Kubernetes 1.18 主要变更"></a>二、Kubernetes 1.18 主要变更</h3><h4 id="核心变更"><a href="#核心变更" class="headerlink" title="核心变更"></a>核心变更</h4><ol><li>＃1393 为服务帐户提供OIDC的支持</li></ol><p>维护阶段：Alpha<br>SIG-Group：auth</p><p>Kubernetes服务帐户（KSA）可以使用令牌（JSON Web令牌或JWT）对Kubernetes API进行身份验证，例如使用kubectl –token &lt;the_token_string&gt;。需要注意的是，Kubernetes API是唯一可以验证这些令牌的服务。</p><p>由于无法（也不应该）从公共网络访问Kubernetes API服务器，因此某些工作负载必须使用单独的系统进行身份验证。比如跨群集进行身份验证时，从群集内部到其他地方进行身份验证。</p><p>此增强功能旨在让KSA令牌更实用，从而使群集外部的服务可以将它们用作常规身份验证方法，而不会使API Server过载。为此，API服务器提供了一个OpenID Connect（OIDC）相关文档，其中包含令牌公共密钥以及其他数据。现有的OIDC身份验证者可以使用这些密钥来验证KSA令牌等。</p><p>可以使用ServiceAccountIssuerDiscovery功能门启用OIDC发现，但需要进行一些配置才能使用。</p><ol start="2"><li>＃853 HPA的扩展速度可配</li></ol><p>维护阶段：Alpha<br>SIG-Group：autoscaling</p><p>HPA可以自动扩展Pod的数量，以满足调整工作负载的需求。 到目前为止，您只能为整个集群定义全局缩放速度。 但是，并非所有应用场景的使用资源情况都一样，因此您可能更需要的是针对特殊群体的扩展效率的个性化方案。</p><p>现在，可以将这些需求添加到HPA配置中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line"><span class="attr">   scaleDown:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Percent</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">   scaleUp:</span></span><br><span class="line"><span class="attr">     policies:</span></span><br><span class="line"><span class="attr">     - type:</span> <span class="string">Pods</span></span><br><span class="line"><span class="attr">       value:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">       periodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p>在此示例中，pod可以每15秒加倍。 缩容时，每分钟可以减少四个pod。 检查文档中的完整语法。</p><ol start="3"><li>＃1513 CertificateSigningRequest API</li></ol><p>维护阶段：Beta<br>SIG-Group：auth</p><p>每个Kubernetes集群都有一个根证书颁发机构，该CA用于保护核心组件之间的通信，这些组件由Certificates API处理，它开始用于为非核心用途提供证书。</p><p>此增强功能旨在适应新的应用场景，从而改善签名过程及其安全性。</p><p>注册机构的数字，即批准者，确保实际的请求者已经提交了证书签名请求（CSR）； 同时他们还确保请求者具有提交该请求的适当权限。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKbd0.md.png" alt="CertificateSigningRequest-API"></p><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ol><li>＃1451 运行多个调度配置文件</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>并非Kubernetes集群中的所有工作负载都相同。您很可能希望将Web服务器分布在尽可能多的节点上，同时您可能希望在同一节点中捆绑尽可能多的对延迟敏感的资源。这就是为什么您需要在同一集群中配置多个调度程序，并指定每个Pod使用哪个调度程序的原因。</p><p>但是，这可能会导致竞争状况，因为每个调度程序在给定时刻可能具有不同的集群资源数据。</p><p>此增强功能使您可以运行一个具有不同配置的调度程序，每个配置都有其自己的调度名称。 Pod会继续使用schedulerName来定义要使用的配置文件，但是它将由相同的调度程序来完成工作，从而避免出现竞争情况。</p><ol start="2"><li>＃895 topologySpreadConstraints</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：scheduling</p><p>使用topologySpreadConstraints，您可以定义规则以在整个多区域群集中均匀分布pod，因此高可用性将正确运行，并且资源利用率将得到提高。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃1258添加可配置的默认Even Pod传播规则</li></ol><p>维护阶段：Alpha<br>SIG-Group：scheduling</p><p>为了利用均匀的pod扩散优势，每个pod都需要有自己的扩散规则，这可能是一项繁琐的任务。</p><p>通过此增强功能，您可以定义全局defaultConstraints，这些默认defaultConstraints将在群集级别应用到所有未定义其自己的topologySpreadConstraints的Pod。</p><ol start="4"><li>＃166基于污点驱逐</li></ol><p>维护阶段：GA<br>SIG-Group：scheduling</p><p>在Kubernetes 1.13中，基于污点的驱逐的功能，在从alpha阶段变为beta阶段后，默认启用此功能（–feature-gates中的TaintBasedEvictions = true），NodeController（或kubelet）会自动添加污点，并且基于Ready NodeCondition禁用了从节点逐出pod的逻辑。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ol><li>＃1539扩展HugePages功能</li></ol><p>维护阶段：GA<br>SIG-Group：node</p><p>HugePages是一种保留具有预定义大小的大内存块的机制，由于硬件优化，这些块可以更快地访问。这对于处理内存中的大的数据集或对内存访问延迟敏感的应用程序（例如数据库或虚拟机）特别有用。</p><p>在Kubernetes 1.18中，此功能添加了两个增强配置。</p><p>首先，现在允许Pod请求不同大小的HugePage。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        hugepages-2Mi:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">        hugepages-1Gi:</span> <span class="number">2</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>其次，已经实现了HugePages的容器隔离，以解决Pod可能使用比请求更多的内存，最终导致资源匮乏的问题。</p><ol start="2"><li>＃688 Pod Overhead：帐户资源绑定到Pod沙箱，但不包含特定的容器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>除了请求的资源之外，您的Pod还需要额外的资源来维护其运行时环境。</p><p>启用PodOverhead功能后，Kubernetes将在调度Pod时考虑到此开销。此开销与pod使用的RuntimeClass相关联。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="3"><li>＃693节点拓扑管理器</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>机器学习，科学计算和金融服务是计算密集型且要求超低延迟的系统的场景。这些类型的工作负载受益于隔离到一个CPU内核的进程，而不是在内核之间切换或与其他进程共享。</p><p>节点拓扑管理器是一个kubelet组件，可集中协调硬件资源分配。当前方法将此任务划分为几个组件（CPU管理器，设备管理器，CNI），这有时会导致分配未优化。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃950为慢启动的pod添加pod-startup、liveness-probe</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：节点</p><p>探针使Kubernetes可以监视应用程序的状态。如果Pod启动所需的时间太长，这些探针可能会认为Pod已死，从而导致重新启动循环。此功能使您可以定义一个启动探针，该探针将推迟所有其他探针，直到容器完成其启动。例如，“在给定的HTTP端点可用之前，请勿测试活动性”。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="网路"><a href="#网路" class="headerlink" title="网路"></a>网路</h4><ol><li>＃752 EndpointSlice API</li></ol><p>维护阶段：Beta重大更新<br>SIG-Group：network</p><p>新的EndpointSlice API将把端点分为几个Endpoint Slice资源。这解决了当前API中与大型Endpoints对象有关的许多问题。该新API还旨在支持其他将来的功能，例如每个吊舱有多个IP。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="2"><li>＃508 IPv6支持添加</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>早在Kubernetes 1.9上就引入了对仅IPv6群集的支持。此功能已由社区进行了广泛的测试，现在正逐步升级为Beta。</p><ol start="3"><li>＃1024 节点本地DNS缓存到GA</li></ol><p>阶段：毕业至稳定<br>功能组：网络</p><p>NodeLocal DNSCache通过在群集节点上作为Daemonset运行dns缓存代理来提高群集DNS性能，从而避免了iptables DNAT规则和连接跟踪。本地缓存代理将查询dns服务以获取集群主机名的未命中缓存（默认为cluster.local后缀）。</p><p>您可以阅读其Kubernetes增强建议（KEP）文档中的设计说明，以了解有关此Beta功能的更多信息。</p><p>在1.15版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1453 ingress功能增强</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：network</p><p>Ingress资源将外部HTTP和HTTPS路由公开为服务，集群中的其他服务可以访问这些服务。</p><p>该API对象包含在Kubernetes 1.1中，成为事实上的稳定功能。此增强功能消除了Ingress实施之间的不一致之处。</p><p>例如，您现在可以定义一个pathType来显式声明将路径视为前缀还是完全匹配。如果Ingress中的多个路径与请求匹配，则最长的匹配路径将优先。</p><p>另外，不建议使用kubernetes.io/ingress.class注释。现在应该使用新的ingressClassName字段和IngressClass资源。</p><ol start="5"><li>＃1507将AppProtocol添加到服务和端点</li></ol><p>维护阶段：GA<br>SIG-Group：network</p><p>EndpointSlice API在Kubernetes 1.17中添加了一个新的AppProtocol字段，以允许为每个端口指定应用程序协议。此增强功能将该字段带入ServicePort和EndpointPort资源中，替换了可能引起不良用户体验的非标准注释。</p><h4 id="API相关"><a href="#API相关" class="headerlink" title="API相关"></a>API相关</h4><ol><li>＃1040 API服务器请求的优先级和公平性</li></ol><p>维护阶段：Alpha<br>SIG-Group：api-machinery</p><p>在高负载期间，Kubernetes API服务器需要负责管理和维护任务。现有的–max-requests-inflight和–max-mutating-requests-inflight命令行标志可以限制传入的请求，但它们的粒度过于粗糙，并且在流量繁忙时会过滤掉重要的请求。</p><p>APIPriorityAndFairness功能门可在apiserver中启用新的请求处理流程。您可以使用FlowSchema对象定义不同类型的请求，并使用RequestPriority对象为它们设定资源优先级。</p><p>例如，垃圾收集器是低优先级服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">FlowSchema</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  matchingPriority:</span> <span class="number">900</span></span><br><span class="line"><span class="attr">  requestPriority:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">  flowDistinguisher:</span></span><br><span class="line"><span class="attr">    source:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  match:</span></span><br><span class="line"><span class="attr">  - and:</span></span><br><span class="line"><span class="attr">    - equals:</span></span><br><span class="line"><span class="attr">      field:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">system:controller:garbage-collector</span></span><br></pre></td></tr></table></figure><p>因此，您可以为其分配很少的资源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-low</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>但是，自我维护请求具有更高的优先级：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RequestPriority</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">system-high</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  assuredConcurrencyShares:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">  queues:</span> <span class="number">128</span></span><br><span class="line"><span class="attr">  handSize:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">  queueLengthLimit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>您可以在增强建议中找到更多示例。</p><ol start="2"><li>＃1601 client-go签名相关重构，以标准化选项和上下文处理</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>在client-go上已经完成了一些代码重构，许多文件都使用该库来连接到Kubernetes API，以保持方法签名的一致性。</p><p>这包括向一些方法中添加上下文对象，该对象在API边界和进程之间承载请求范围的值。访问此对象可简化一些功能的实现，例如在超时和取消后释放调用线程，或添加对分布式跟踪的支持。</p><ol start="3"><li>＃576 APIServer DryRun</li></ol><p>维护阶段：GA<br>SIG-Group：api-machinery</p><p>ryRun运行模式使您可以模拟真实的API请求，并查看请求是否成功（准入控制器链，验证，合并冲突等）和在不实际修改状态的情况下会发生什么。该请求的响应主体应尽可能接近非空运行响应。此核心功能将启用其他用户级别的功能，例如kubectl diff子命令。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1281 API服务器网络代理KEP到Beta</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：api-machinery</p><p>有些用户（大多数是云提供商）更喜欢将其群集API Server隔离在单独的控制网络中，而不是在集群网络中。实现此功能的一种方法是保持与其他集群组件的连通性，同时使用API Server网络代理。</p><p>具有此额外的层可以启用其他功能，例如元数据审核日志记录和传出API服务器连接的验证。</p><p>在Kubernetes 1.18中，API Server代理允许在服务，节点，webhooks和Pods之外的单独网络中分离API。</p><p><img src="https://s1.ax1x.com/2020/03/25/8vKOiT.md.png" alt="Kubernetes-1.18-enhancement-1281-API-Server-Network-Proxy.png"></p><p>此增强功能涵盖了解决一些已知问题并让该代理支持一般性的工作，例如从Kubernetes API服务器中删除SSH隧道代码，以及改善控制网络与集群网络的隔离。</p><h4 id="Windows变更"><a href="#Windows变更" class="headerlink" title="Windows变更"></a>Windows变更</h4><ol><li>＃1001在Windows上支持CRI-ContainerD</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>ContainerD是与Kubernetes兼容的OCI兼容运行时。与Docker相反，ContainerD在Windows Server 2019中包括对主机容器服务（HCS v2）的支持，该服务可更好地控制容器的管理方式并可以改善Kubernetes API的兼容性。</p><p>此增强功能引入了Windows中作为容器运行时接口（CRI）的ContainerD 1.3支持。在此增强页面中查看更多详细信息。</p><ol start="2"><li>＃1301在Windows上实现RuntimeClass</li></ol><p>维护阶段：Alpha<br>SIG-Group：windows</p><p>使用RuntimeClass，您可以定义集群中存在的不同类型的节点，然后使用runtimeClassName指定可以将Pod部署在哪些节点中。此功能在Kubernetes 1.12上引入，并在Kubernetes 1.14上进行了重大更改。</p><p>此增强功能将此功能扩展到Windows节点，这在异构集群包含Windows Pod时，对部署在Windows节点上非常有用。这是定义RuntimeClass的方法，以将pod限制为Windows Server 1903版（10.0.18362）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">node.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RuntimeClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">windows-1903</span></span><br><span class="line"><span class="attr">handler:</span> <span class="string">'docker'</span></span><br><span class="line"><span class="attr">scheduling:</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line">    <span class="string">kubernetes.io/os:</span> <span class="string">'windows'</span></span><br><span class="line">    <span class="string">kubernetes.io/arch:</span> <span class="string">'amd64'</span></span><br><span class="line">    <span class="string">node.kubernetes.io/windows-build:</span> <span class="string">'10.0.18362'</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">windows</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Equal</span></span><br><span class="line"><span class="attr">    value:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>然后，您需要在pod中使用runtimeClassName，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  runtimeClassName:</span> <span class="string">windows-1903</span></span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>检查增强页面以获取更多详细信息。</p><ol start="3"><li>＃689为Windows工作负载支持GMSA</li></ol><p>维护阶段：GA<br>SIG-Group：windows</p><p>这将使操作员可以在部署时选择GMSA，并使用它运行容器以连接到现有应用程序（例如数据库或API服务器），而无需更改组织内部对身份验证和授权的管理方式。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃1043 Windows版RunAsUserName</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：windows</p><p>现在，Kubernetes支持组托管服务帐户，我们可以使用Windows的runAsUserName特定属性来定义哪个用户将运行容器的入口点。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><ol start="5"><li>＃995 Windows版Kubeadm</li></ol><p>维护阶段：升级到Beta<br>SIG-Group：cluster-lifecycle</p><p>Kubernetes 1.14中引入了对Windows节点的支持，但是没有一种简单的方法可以将Windows节点加入集群。</p><p>从Kubernetes 1.16开始，具有部分功能的Windows用户可以使用kubeadm join。它将缺少一些功能，例如kubeadm init或kubeadm join –control-plane。</p><p>在1.16版本的Kubernetes新增功能中了解更多信息。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol><li>＃695跳过卷所有权更改</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>在将卷绑定安装到容器内之前，其所有文件权限都将更改为提供的fsGroup值。这最终会导致非常大的卷上的缓慢过程，还会破坏一些对权限敏感的应用程序，例如数据库。</p><p>已添加新的FSGroupChangePolicy字段以控制此行为。如果设置为始终，它将保持当前行为。但是，当设置为OnRootMismatch时，仅当顶级目录与预期的fsGroup值不匹配时，它才会更改卷权限。</p><ol start="2"><li>＃1412不可变的Secrets和ConfigMap</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>新的不可变字段已添加到Secrets和ConfigMaps中。设置为true时，将拒绝对资源密钥所做的任何更改。这样可以保护集群数据，避免意外或错误更新从而破坏应用程序。</p><p>由于它们不变，因此Kubelet不需要定期检查其更新，这可以提高可伸缩性和性能。</p><p>启用ImmutableEmphemeralVolumes功能门之后，您可以执行以下操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">…</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是，一旦将资源标记为不可变，就无法还原此更改。您只能删除并重新创建密钥，并且需要重新创建使用已删除密钥的Pod。</p><ol start="3"><li>＃1495通用数据填充器</li></ol><p>维护阶段：Alpha<br>SIG-Group：storage</p><p>这项增强功能为用户创建预先填充的卷奠定了基础。例如，使用操作系统映像预填充用于虚拟机的磁盘，或启用数据备份和还原。</p><p>为此，将取消对持久卷的DataSource字段的当前验证，从而允许将任意对象设置为值。有关如何填充卷的实现详细信息委托给专用控制器。</p><ol start="4"><li>＃770</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>这种内部优化将简化为不需要附加/分离操作的容器存储接口（CSI）驱动程序（例如NFS或临时机密卷）创建VolumeAttachment对象的操作。</p><p>对于这些驱动程序，Kubernetes Attach/Detach控制器始终创建VolumeAttachment对象，并一直等到它们被报告为“已绑定”。对CSI卷插件进行了更改，以跳过此步骤。</p><ol start="5"><li>＃351使用永久卷源的BlockVolume</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>BlockVolume在Kubernetes 1.18中达到了常规可用性。您可以仅将volumeMode的值设置为block即可访问原始块设备。使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的高性能应用程序（如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="6"><li>＃565 CSI块存储支持</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用不带文件系统抽象的原始块设备的能力使Kubernetes可以为需要高I/O性能和低延迟的应用程序（例如数据库）提供更好的支持。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="7"><li>＃603在CSI调用中传递Pod信息</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>CSI存储驱动程序可以选择接收关于在NodePublish请求中请求卷的Pod的信息，例如Pod名称和名称空间。</p><p>CSI驱动程序可以使用此信息来授权或审核卷的使用，或生成针对Pod定制的卷内容。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><ol start="8"><li>＃989扩展允许的PVC数据源</li></ol><p>维护阶段：GA<br>SIG-Group：storage</p><p>使用此功能，可以“克隆”现有的持久卷。克隆会导致从现有卷中调配新的重复卷。</p><p>在1.15版本的Kubernetes新增功能中阅读更多内容。</p><hr><h3 id="Kubernetes-1-18-其他更新"><a href="#Kubernetes-1-18-其他更新" class="headerlink" title="Kubernetes 1.18 其他更新"></a>Kubernetes 1.18 其他更新</h3><ol><li>＃1441 kubectl调试</li></ol><p>维护阶段：Alpha<br>SIG-Group：功能组：cli</p><p>添加了新的kubectl debug命令以扩展调试功能。</p><p>此命令允许在正在运行的Pod中创建临时容器，使用修改后的PodSpec重新启动Pod，以及启动并附加到主机名称空间中的特权容器。</p><ol start="2"><li>＃1020将kubectl软件包代码移至暂存</li></ol><p>维护阶段：GA<br>SIG-Group：功能组：cli</p><p>kubectl代码的这种内部重组是将kubectl二进制文件移到其自己的存储库中的第一步。这有助于将kubectl与kubernetes代码库分离，并使树外项目更易于重用其代码。</p><ol start="3"><li>＃1333禁用没有Beta REST API或功能</li></ol><p>维护阶段：Beta<br>SIG-Group：architecture</p><p>此增强功能收集了所做的工作，以确保Kubernetes组件和Kubernetes一致性都不依赖于Beta REST API或功能。最终目标是确保各个发行版之间的一致性，因为启用非GA功能不需要使用非官方发行版（例如k3s，Rancher或Openshift）。</p><ol start="4"><li>＃491 Kubectl Diff</li></ol><p>维护阶段：GA<br>SIG-Group：cli</p><p>kubectl diff将为您预览kubectl将对您的集群进行哪些更改。尽管易于描述，但此功能对于群集操作员的日常工作确实非常方便。请注意，您需要在API服务器上启用dry run功能，此命令才能起作用。</p><p>在1.13版本的Kubernetes新增功能中了解更多信息。</p><ol start="4"><li>＃670支持vSphere Cloud Provider</li></ol><p>维护阶段：GA<br>SIG-Group：cloud-provider</p><p>提供对vSphere云提供商的支持。这涉及到经过测试的云控制器管理器版本，该版本具有与kube-controller-manager奇偶校验的功能。</p><p>在1.14版本的Kubernetes新增功能中了解更多信息。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.18.md" target="_blank" rel="noopener">kubernetes 1.18</a></li><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Golang</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/22/MTa1tH.png&quot; alt=&quot;k8s&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Kubernetes 1.18即将发布！ 在发布了1.17的小版本之后，1.18变得日益健壮并充满了新颖性。 关于新版本的介绍从哪里开始？&lt;/p&gt;
&lt;p&gt;有一些新功能，例如API Server对OIDC的支持以及kubelet关于Windows节点的功能增强，这些都会对用户产生重大影响。&lt;/p&gt;
&lt;p&gt;我们也很高兴看到长时间处于Alpha状态的某些功能被重新考虑而备受关注，例如Ingress或API Server Network Proxy。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;此外，我们庆祝即将升级到稳定版的13个功能。 这涵盖了所有新变化的三分之一内容！&lt;/p&gt;
&lt;p&gt;以下为Kubernetes 1.18中新功能的详细列表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://ustack.io/tags/kubernetes/"/>
    
      <category term="cloudnative" scheme="https://ustack.io/tags/cloudnative/"/>
    
  </entry>
  
</feed>
