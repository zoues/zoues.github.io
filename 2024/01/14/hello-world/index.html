<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="这份zig简明教程适合已经有编程基础知识的同学快速了解zig语言，同时也适合没有编程经验但是懂得善用搜索引擎的同学,该文章详细介绍Zig编程语言各种概念，主要包括基础知识、函数、结构体、枚举、数组、切片、控制结构、错误处理、指针、元编程和堆管理等内容。 基础知识命令 zig run my_code.zig 将编译并立即运行你的 Zig 程序。每个单元格都包含一个 Zig 程序，你可以尝试运行它们（">
<meta property="og:type" content="article">
<meta property="og:title" content="Ziglang简明教程">
<meta property="og:url" content="http://example.com/2024/01/14/hello-world/index.html">
<meta property="og:site_name" content="ustack.io">
<meta property="og:description" content="这份zig简明教程适合已经有编程基础知识的同学快速了解zig语言，同时也适合没有编程经验但是懂得善用搜索引擎的同学,该文章详细介绍Zig编程语言各种概念，主要包括基础知识、函数、结构体、枚举、数组、切片、控制结构、错误处理、指针、元编程和堆管理等内容。 基础知识命令 zig run my_code.zig 将编译并立即运行你的 Zig 程序。每个单元格都包含一个 Zig 程序，你可以尝试运行它们（">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-14T05:40:08.000Z">
<meta property="article:modified_time" content="2024-01-15T03:18:48.397Z">
<meta property="article:author" content="zouyee">
<meta property="article:tag" content="zig">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Ziglang简明教程</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="ustack.io" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/tags/~">tags</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/01/20/embracing-cgroup-v2-best-practices-for-migrating-kubernetes-clusters-to-almalinux/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2021/01/28/Kubernetes%E9%9B%86%E7%BE%A4%E5%9C%A8OpenAI%E7%9A%84%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/01/14/hello-world/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/01/14/hello-world/&text=Ziglang简明教程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/01/14/hello-world/&is_video=false&description=Ziglang简明教程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Ziglang简明教程&body=Check out this article: http://example.com/2024/01/14/hello-world/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/01/14/hello-world/&name=Ziglang简明教程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/01/14/hello-world/&t=Ziglang简明教程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">5.</span> <span class="toc-text">数组和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">堆管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Ziglang简明教程
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">zouyee</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-01-14T05:40:08.000Z" class="dt-published" itemprop="datePublished">2024-01-14</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/zig/" rel="tag">zig</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>这份zig简明教程适合已经有编程基础知识的同学快速了解zig语言，同时也适合没有编程经验但是懂得善用搜索引擎的同学,该文章详细介绍Zig编程语言各种概念，主要包括基础知识、函数、结构体、枚举、数组、切片、控制结构、错误处理、指针、元编程和堆管理等内容。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>命令 <code>zig run my_code.zig</code> 将编译并立即运行你的 Zig 程序。每个单元格都包含一个 Zig 程序，你可以尝试运行它们（其中一些包含编译时错误，你可以注释掉后再尝试）。</p>
<p>首先需要声明一个 <code>main()</code> 函数来运行代码。</p>
<p>下面的代码什么都不会做，只是简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// comments look like this and go to the end of the line</span><br><span class="line">pub fn main() void &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 内置函数<code>@import</code> 导入标准库，并将命名空间赋值给一个 <code>const</code> 值。Zig 中的几乎所有东西都必须明确地被赋予标识符。你也可以通过这种方式导入其他 Zig 文件，类似地，你可以使用 <code>@cImport</code> 导入 C 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;hello world!\n&quot;, .&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：后续会在结构部分部分解释 <code>print</code> 语句中的第二个参数。</p>
<p>一般用<code>var</code> 来声明变量，同时在大多数情况下，需要带上声明变量类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x: i32 = 47; // declares &quot;x&quot; of type i32 to be 47.</span><br><span class="line">    std.debug.print(&quot;x: &#123;&#125;\n&quot;, .&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>const</code> 声明一个变量的值是不可变的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub fn main() void &#123;</span><br><span class="line">    const x: i32 = 47;</span><br><span class="line">    x = 42; // error: cannot assign to constant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zig 非常严苛，不允许你从外部作用域屏蔽标识符，以防止混淆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const x: i32 = 47;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x: i32 = 42;  // error: redefinition of &#x27;x&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>全局作用域的常量默认为编译时的 “comptime” 值，如果省略了类型，它们就是编译时类型，并且可以在运行时转换为运行时类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const x: i32 = 47;</span><br><span class="line">const y = -47;  // comptime integer.</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var a: i32 = y; // comptime constant coerced into correct type</span><br><span class="line">    var b: i64 = y; // comptime constant coerced into correct type</span><br><span class="line">    var c: u32 = y; // error: cannot cast negative value -47 to unsigned integer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望在后面设置它，也可以明确选择将其保留为未定义。如果你在调试模式下意外使用它引发错误，Zig 将使用 0XAA 字节填充一个虚拟值，以帮助检测错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">  var x: i32 = undefined;</span><br><span class="line">  std.debug.print(&quot;undefined: &#123;&#125;\n&quot;, .&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，如果 Zig 可以推断出类型信息，才允许你省略类型信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x: i32 = 47;</span><br><span class="line">    var y: i32 = 47;</span><br><span class="line">    var z = x + y; // declares z and sets it to 94.</span><br><span class="line">    std.debug.print(&quot;z: &#123;&#125;\n&quot;, .&#123;z&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意，整数字面值是编译时类型，所以下面的示例是行不通的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x = 47; // error: variable of type &#x27;comptime_int&#x27; must be const or comptime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以带参数和返回值，使用<code>fn</code>关键字声明。<code>pub</code>关键字表示函数可以从当前作用域导出，使其它地方可以调用。下面示例是一个不返回任何值的函数（foo）。<code>pub</code>关键字表示该函数可以从当前作用域导出，这就是为什么<code>main</code>函数必须是<code>pub</code>的。你可以像大多数编程语言中一样调用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo() void &#123;</span><br><span class="line">    std.debug.print(&quot;foo!\n&quot;, .&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    //optional:</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面示例是一个返回整数值的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo() i32 &#123;</span><br><span class="line">    return 47;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var result = foo();</span><br><span class="line">    std.debug.print(&quot;foo: &#123;&#125;\n&quot;, .&#123;result&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zig不允许你忽略函数的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn foo() i32 &#123;</span><br><span class="line">    return 47;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    foo(); // error: expression value is ignored</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是你可以将其赋值给丢弃变量 <code>_</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn foo() i32 &#123;</span><br><span class="line">    return 47;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">  _ = foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以声明函数时带上参数的类型，这样函数调用时可以传入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo(x: i32) void &#123;</span><br><span class="line">    std.debug.print(&quot;foo param: &#123;&#125;\n&quot;, .&#123;x&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    foo(47);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体通过使用<code>const</code>关键字分配一个名称来声明，它们的赋值顺序可以是任意的，并且可以使用常规的点语法进行解引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">const Vec2 = struct &#123;</span><br><span class="line">    x: f64,</span><br><span class="line">    y: f64</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var v = Vec2&#123;.y = 1.0, .x = 2.0&#125;;</span><br><span class="line">    std.debug.print(&quot;v: &#123;&#125;\n&quot;, .&#123;v&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体可以有默认值；结构体也可以是匿名的，并且可以强制转换为另一个结构体，只要所有的值都能确定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">const Vec3 = struct&#123;</span><br><span class="line">    x: f64 = 0.0,</span><br><span class="line">    y: f64,</span><br><span class="line">    z: f64</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var v: Vec3 = .&#123;.y = 0.1, .z = 0.2&#125;;  // ok</span><br><span class="line">    var w: Vec3 = .&#123;.y = 0.1&#125;; // error: missing field: &#x27;z&#x27;</span><br><span class="line">    std.debug.print(&quot;v: &#123;&#125;\n&quot;, .&#123;v&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将函数放入结构体中，使其像面向对象编程中的对象一样工作。这里有一个语法糖，如果你定义的函数的第一个参数为对象的指针，我们称之为”面向对象编程”，类似于Python带self参数的函数。一般约定是通过将变量命名为self来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">const LikeAnObject = struct&#123;</span><br><span class="line">    value: i32,</span><br><span class="line"></span><br><span class="line">    fn print(self: *LikeAnObject) void &#123;</span><br><span class="line">        std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;self.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var obj = LikeAnObject&#123;.value = 47&#125;;</span><br><span class="line">    obj.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一直传递给<code>std.debug.print</code>的第二个参数是一个元组，它是一个带有数字字段的匿名结构体。在编译时，<code>std.debug.print</code>会找出元组中参数的类型，并生成一个针对你提供的参数字符串的版本，这就是为何Zig知道如何将打印的内容变得漂亮的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;&#123;&#125;\n&quot;, .&#123;1, 2&#125;); #  error: Unused arguments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举通过使用<code>const</code>关键字将枚举组以类型方式来声明。</p>
<p>注意：在某些情况下，可以简化枚举的名称。 其可以将枚举的值设置为整数，但它不会自动强制转换，你必须使用<code>@enumToInt</code>或<code>@intToEnum</code>来进行转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">const EnumType = enum&#123;</span><br><span class="line">    EnumOne,</span><br><span class="line">    EnumTwo,</span><br><span class="line">    EnumThree = 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;One: &#123;&#125;\n&quot;, .&#123;EnumType.EnumOne&#125;);</span><br><span class="line">    std.debug.print(&quot;Two?: &#123;&#125;\n&quot;, .&#123;EnumType.EnumTwo == .EnumTwo&#125;);</span><br><span class="line">    std.debug.print(&quot;Three?: &#123;&#125;\n&quot;, .&#123;@enumToInt(EnumType.EnumThree) == 3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>Zig有数组概念，它们是具有在编译时已知长度的连续内存。你可以通过在前面声明类型并提供值列表来初始化它们，同时可以通过数组的<code>len</code>字段访问它们的长度。</p>
<p>注意：Zig中的数组也是从零开始索引的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var array: [3]u32 = [3]u32&#123;47, 47, 47&#125;;</span><br><span class="line"></span><br><span class="line">    // also valid:</span><br><span class="line">    // var array = [_]u32&#123;47, 47, 47&#125;;</span><br><span class="line"></span><br><span class="line">    var invalid = array[4]; // error: index 4 outside array of size 3.</span><br><span class="line">    std.debug.print(&quot;array[0]: &#123;&#125;\n&quot;, .&#123;array[0]&#125;);</span><br><span class="line">    std.debug.print(&quot;length: &#123;&#125;\n&quot;, .&#123;array.len&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟golang类似，Zig也有切片（slices），它们的长度在运行时已知。你可以使用切片操作从数组或其他切片构造切片。与数组类似，切片有一个<code>len</code>字段，告诉它的长度。</p>
<p>注意：切片操作中的间隔参数是开口的（不包含在内）。 尝试访问超出切片范围的元素会引发运行时panic。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var array: [3]u32 = [_]u32&#123;47, 47, 47&#125;;</span><br><span class="line">    var slice: []u32 = array[0..2];</span><br><span class="line"></span><br><span class="line">    // also valid:</span><br><span class="line">    // var slice = array[0..2];</span><br><span class="line"></span><br><span class="line">    var invalid = slice[3]; // panic: index out of bounds</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;slice[0]: &#123;&#125;\n&quot;, .&#123;slice[0]&#125;);</span><br><span class="line">    std.debug.print(&quot;length: &#123;&#125;\n&quot;, .&#123;slice.len&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>字符串文字是以null结尾的utf-8编码的const u8字节数组。Unicode字符只允许在字符串文字和注释中使用。</p>
<p>注意：长度不包括null终止符（官方称为”sentinel termination”）。 访问null终止符是安全的。 索引是按字节而不是Unicode字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const string = &quot;hello 世界&quot;;</span><br><span class="line">const world = &quot;world&quot;;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var slice: []const u8 = string[0..5];</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;string &#123;&#125;\n&quot;, .&#123;string&#125;);</span><br><span class="line">    std.debug.print(&quot;length &#123;&#125;\n&quot;, .&#123;world.len&#125;);</span><br><span class="line">    std.debug.print(&quot;null &#123;&#125;\n&quot;, .&#123;world[5]&#125;);</span><br><span class="line">    std.debug.print(&quot;slice &#123;&#125;\n&quot;, .&#123;slice&#125;);</span><br><span class="line">    std.debug.print(&quot;huh? &#123;&#125;\n&quot;, .&#123;string[0..7]&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const数组可以强制转换为const切片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo() []const u8 &#123;  // note function returns a slice</span><br><span class="line">    return &quot;foo&quot;;      // but this is a const array.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;foo: &#123;&#125;\n&quot;, .&#123;foo()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Zig提供了与其他语言类似的if语句、switch语句、for循环和while循环。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo(v: i32) []const u8 &#123;</span><br><span class="line">    if (v &lt; 0) &#123;</span><br><span class="line">        return &quot;negative&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return &quot;non-negative&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;positive &#123;&#125;\n&quot;, .&#123;foo(47)&#125;);</span><br><span class="line">    std.debug.print(&quot;negative &#123;&#125;\n&quot;, .&#123;foo(-47)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo(v: i32) []const u8 &#123;</span><br><span class="line">    switch (v) &#123;</span><br><span class="line">        0 =&gt; return &quot;zero&quot;,</span><br><span class="line">        else =&gt; return &quot;nonzero&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    std.debug.print(&quot;47 &#123;&#125;\n&quot;, .&#123;foo(47)&#125;);</span><br><span class="line">    std.debug.print(&quot;0 &#123;&#125;\n&quot;, .&#123;foo(0)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-loop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var array = [_]i32&#123;47, 48, 49&#125;;</span><br><span class="line"></span><br><span class="line">    for (array) | value | &#123;</span><br><span class="line">        std.debug.print(&quot;array &#123;&#125;\n&quot;, .&#123;value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (array) | value, index | &#123;</span><br><span class="line">        std.debug.print(&quot;array &#123;&#125;:&#123;&#125;\n&quot;, .&#123;index, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var slice = array[0..2];</span><br><span class="line"></span><br><span class="line">    for (slice) | value | &#123;</span><br><span class="line">        std.debug.print(&quot;slice &#123;&#125;\n&quot;, .&#123;value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (slice) | value, index | &#123;</span><br><span class="line">        std.debug.print(&quot;slice &#123;&#125;:&#123;&#125;\n&quot;, .&#123;index, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while loop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var array = [_]i32&#123;47, 48, 49&#125;;</span><br><span class="line">    var index: u32 = 0;</span><br><span class="line"></span><br><span class="line">    while (index &lt; 2) &#123;</span><br><span class="line">        std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;array[index]&#125;);</span><br><span class="line">        index += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误是特殊的联合类型，你可以在函数前面加上 ! 来表示该函数可能返回错误。你可以通过简单地将错误作为正常返回值返回来抛出错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const MyError = error&#123;</span><br><span class="line">    GenericError,</span><br><span class="line">    OtherError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    return MyError.GenericError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn wrap_foo(v: i32) void &#123;</span><br><span class="line">    if (foo(v)) |value| &#123;</span><br><span class="line">        std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;value&#125;);</span><br><span class="line">    &#125; else |err| &#123;</span><br><span class="line">        std.debug.print(&quot;error: &#123;&#125;\n&quot;, .&#123;err&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你编写一个可能出错的函数，当它返回时你必须决定如何处理错误。两个常见的选择是 <code>try</code> 和 <code>catch</code>。<code>try</code> 方式很摆烂，它只是简单地将错误转发为函数的错误。而 <code>catch</code> 需要处理错误。</p>
<p><code>try</code> 其实就是 <code>catch | err | &#123;return err&#125;</code> 的语法糖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const MyError = error&#123;</span><br><span class="line">    GenericError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn foo(v: i32) !i32 &#123;</span><br><span class="line">    if (v == 42) return MyError.GenericError;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    // catch traps and handles errors bubbling up</span><br><span class="line">    _ = foo(42) catch |err| &#123;</span><br><span class="line">        std.debug.print(&quot;error: &#123;&#125;\n&quot;, .&#123;err&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // try won&#x27;t get activated here.</span><br><span class="line">    std.debug.print(&quot;foo: &#123;&#125;\n&quot;, .&#123;try foo(47)&#125;);</span><br><span class="line"></span><br><span class="line">    // this will ultimately cause main to print an error trace and return nonzero</span><br><span class="line">    _ = try foo(42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <code>if</code> 来检查错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const MyError = error&#123;</span><br><span class="line">    GenericError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn foo(v: i32) !i32 &#123;</span><br><span class="line">    if (v == 42) return MyError.GenericError;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// note that it is safe for wrap_foo to not have an error ! because</span><br><span class="line">// we handle ALL cases and don&#x27;t return errors.</span><br><span class="line">fn wrap_foo(v: i32) void &#123;    </span><br><span class="line">    if (foo(v)) | value | &#123;</span><br><span class="line">        std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;value&#125;);</span><br><span class="line">    &#125; else | err | &#123;</span><br><span class="line">        std.debug.print(&quot;error: &#123;&#125;\n&quot;, .&#123;err&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    wrap_foo(42);</span><br><span class="line">    wrap_foo(47);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Zig使用<code>*</code>表示指针类型，可以通过<code>.*</code>语法访问指针指向的值。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn printer(value: *i32) void &#123;</span><br><span class="line">    std.debug.print(&quot;pointer: &#123;&#125;\n&quot;, .&#123;value&#125;);</span><br><span class="line">    std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;value.*&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var value: i32 = 47;</span><br><span class="line">    printer(&amp;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在Zig中，指针需要正确对齐到它所指向的值的对齐方式。 对于结构体，类似于Java，您可以解引用指针并一次获取字段，使用 . 运算符。需要注意的是，这仅适用于一层间接引用，因此如果您有指向指针的指针，您必须首先解引用外部指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">const MyStruct = struct &#123;</span><br><span class="line">    value: i32</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn printer(s: *MyStruct) void &#123;</span><br><span class="line">    std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;s.value&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var value = MyStruct&#123;.value = 47&#125;;</span><br><span class="line">    printer(&amp;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zig允许任何类型（不仅仅是指针）可为空，但请注意它们是基本类型和特殊值 null 的联合体。要访问未包装的可选类型，请使用 .? 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var value: i32 = 47;</span><br><span class="line">    var vptr: ?*i32 = &amp;value;</span><br><span class="line">    var throwaway1: ?*i32 = null;</span><br><span class="line">    var throwaway2: *i32 = null; // error: expected type &#x27;*i32&#x27;, found &#x27;(null)&#x27;</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;vptr.*&#125;); // error: attempt to dereference non-pointer type</span><br><span class="line">    std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;vptr.?.*&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当我们使用来自C ABI函数的指针时，它们会自动转换为可为空指针。 获得未包装的可选指针的另一种方法是使用 if 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn nullChoice(value: ?*i32) void &#123;</span><br><span class="line">    if (value) | v | &#123;</span><br><span class="line">        std.debug.print(&quot;value: &#123;&#125;\n&quot;, .&#123;v.*&#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std.debug.print(&quot;null!\n&quot;, .&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var value: i32 = 47;</span><br><span class="line">    var vptr1: ?*i32 = &amp;value;</span><br><span class="line">    var vptr2: ?*i32 = null;</span><br><span class="line"></span><br><span class="line">    nullChoice(vptr1);</span><br><span class="line">    nullChoice(vptr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>Zig的元编程受几个基本概念驱动：</p>
<ul>
<li><p>类型在编译时是有效的值。</p>
</li>
<li><p>大多数运行时代码在编译时也能工作。</p>
</li>
<li><p>结构体字段的评估是编译时的鸭子类型（duck-typed）。</p>
</li>
<li><p>Zig标准库提供了执行编译时反射的工具。</p>
<p>下面是元编程的一个示例：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo(x : anytype) @TypeOf(x) &#123;</span><br><span class="line">    // note that this if statement happens at compile-time, not runtime.</span><br><span class="line">    if (@TypeOf(x) == i64) &#123;</span><br><span class="line">        return x + 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 2 * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x: i64 = 47;</span><br><span class="line">    var y: i32 =  47;</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;i64-foo: &#123;&#125;\n&quot;, .&#123;foo(x)&#125;);</span><br><span class="line">    std.debug.print(&quot;i32-foo: &#123;&#125;\n&quot;, .&#123;foo(y)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是泛型类型的一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn Vec2Of(comptime T: type) type &#123;</span><br><span class="line">    return struct&#123;</span><br><span class="line">        x: T,</span><br><span class="line">        y: T</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const V2i64 = Vec2Of(i64);</span><br><span class="line">const V2f64 = Vec2Of(f64);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var vi = V2i64&#123;.x = 47, .y = 47&#125;;</span><br><span class="line">    var vf = V2f64&#123;.x = 47.0, .y = 47.0&#125;;</span><br><span class="line">    </span><br><span class="line">    std.debug.print(&quot;i64 vector: &#123;&#125;\n&quot;, .&#123;vi&#125;);</span><br><span class="line">    std.debug.print(&quot;f64 vector: &#123;&#125;\n&quot;, .&#123;vf&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些概念，我们可以构建非常强大的泛型类型！</p>
<h3 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h3><p>Zig为我们提供了与堆交互的多种方式，通常要求您明确选择使用哪种方式。它们都遵循下述相同的模式：</p>
<ol>
<li>创建一个分配器工厂结构体。</li>
<li>检索由分配器工厂创建的<code>std.mem.Allocator</code>结构体。</li>
<li>使用<code>alloc/free</code>和<code>create/destroy</code>函数来操作堆。</li>
<li>（可选）销毁分配器工厂。</li>
</ol>
<p>这么处理的目的是：</p>
<ul>
<li>为了阻止您过度使用堆。</li>
<li>这使得调用堆的任何东西（基本上是可失败的操作）都是显式的。</li>
<li>您可以仔细调整权衡，并使用标准数据结构而无需重写标准库。</li>
<li>您可以在测试中运行非常安全的分配器，并在发布&#x2F;生产环境中切换到不同的分配器。</li>
</ul>
<p>好的，但是你也可以偷点懒。你是不是想一直使用jemalloc？ 只需选择一个全局分配器，并在所有地方使用它（请注意，某些分配器是线程安全的，而某些则不是）。</p>
<p>在这个示例中，我们将使用<code>std.heap.GeneralPurposeAllocator</code>工厂创建一个具有多种特性（包括泄漏检测）的分配器，并看看它是如何组合在一起的。</p>
<p>最后一件事，这里使用了<code>defer</code>关键字，它非常类似于Go语言中的<code>defer</code>关键字！还有一个<code>errdefer</code>关键字，如果需要了解更多信息，请查阅Zig文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">// factory type</span><br><span class="line">const Gpa = std.heap.GeneralPurposeAllocator(.&#123;&#125;);</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    // instantiates the factory</span><br><span class="line">    var gpa = Gpa&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    // retrieves the created allocator.</span><br><span class="line">    var galloc = &amp;gpa.allocator;</span><br><span class="line">    </span><br><span class="line">    // scopes the lifetime of the allocator to this function and</span><br><span class="line">    // performs cleanup; </span><br><span class="line">    defer _ = gpa.deinit();</span><br><span class="line"></span><br><span class="line">    var slice = try galloc.alloc(i32, 2);</span><br><span class="line">    // uncomment to remove memory leak warning</span><br><span class="line">    // defer galloc.free(slice);</span><br><span class="line">    </span><br><span class="line">    var single = try galloc.create(i32);</span><br><span class="line">    // defer gallo.destroy(single);</span><br><span class="line"></span><br><span class="line">    slice[0] = 47;</span><br><span class="line">    slice[1] = 48;</span><br><span class="line">    single.* = 49;</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;slice: [&#123;&#125;, &#123;&#125;]\n&quot;, .&#123;slice[0], slice[1]&#125;);</span><br><span class="line">    std.debug.print(&quot;single: &#123;&#125;\n&quot;, .&#123;single.*&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们已经掌握了相当大的Zig基础知识。没有覆盖的一些（非常重要的）内容包括：</p>
<ul>
<li>测试（Zig使得编写测试非常容易）</li>
<li>标准库</li>
<li>内存模型（Zig在分配器方面没有倾向性）</li>
<li>异步编程（Zig 的异步特性在编译器中出现了性能退化，在 0.11 版本的 Zig 中已经不存在了，并且在 Zig 0.12 版本中也可能不会出现。）</li>
<li>交叉编译</li>
<li><code>build.zig</code> 文件</li>
</ul>
<p>如果想要了解更多细节，请查阅最新的文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ziglang.org/documentation/master/">https://ziglang.org/documentation/master/</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/ityonemo/769532c2017ed9143f3571e5ac104e50">https://gist.github.com/ityonemo/769532c2017ed9143f3571e5ac104e50</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/tags/~">tags</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/zouyee">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">5.</span> <span class="toc-text">数组和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">堆管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/01/14/hello-world/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/01/14/hello-world/&text=Ziglang简明教程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/01/14/hello-world/&is_video=false&description=Ziglang简明教程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Ziglang简明教程&body=Check out this article: http://example.com/2024/01/14/hello-world/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/01/14/hello-world/&title=Ziglang简明教程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/01/14/hello-world/&name=Ziglang简明教程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/01/14/hello-world/&t=Ziglang简明教程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    zouyee
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/tags/~">tags</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
