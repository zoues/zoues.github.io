<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Ziglang适配OpenMP循环指令以实现共享内存并行计算Original： https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2408.09902v1 摘要Zig 编程语言以性能和安全性为核心设计目标，近年来逐渐受到欢迎。由于 Zig 基于 LLVM 构建，因此能够利用该生态系统的诸多优势，包括访问丰富的支持后端，这使得 Zig 在高性能工作负载方向具备显著潜力。然而，Zig 尚未在高性能计算（H">
<meta property="og:type" content="article">
<meta property="og:title" content="Ziglang适配OpenMP 循环指令以实现共享内存并行计算">
<meta property="og:url" content="https://zoues.com/posts/d1d12995/index.html">
<meta property="og:site_name" content="zouyee">
<meta property="og:description" content="Ziglang适配OpenMP循环指令以实现共享内存并行计算Original： https:&#x2F;&#x2F;arxiv.org&#x2F;html&#x2F;2408.09902v1 摘要Zig 编程语言以性能和安全性为核心设计目标，近年来逐渐受到欢迎。由于 Zig 基于 LLVM 构建，因此能够利用该生态系统的诸多优势，包括访问丰富的支持后端，这使得 Zig 在高性能工作负载方向具备显著潜力。然而，Zig 尚未在高性能计算（H">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/pragma_tokens.png">
<meta property="og:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/private_clause.png">
<meta property="og:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/cg-speedup.png">
<meta property="og:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/ep-speedup.png">
<meta property="og:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/is-speedup.png">
<meta property="article:published_time" content="2024-12-04T00:23:48.000Z">
<meta property="article:modified_time" content="2024-12-04T00:47:14.099Z">
<meta property="article:author" content="zouyee">
<meta property="article:tag" content="zig">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/pragma_tokens.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Ziglang适配OpenMP 循环指令以实现共享内存并行计算</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="zouyee" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/3881eb8f/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zoues.com/posts/d1d12995/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zoues.com/posts/d1d12995/&text=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zoues.com/posts/d1d12995/&is_video=false&description=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Ziglang适配OpenMP 循环指令以实现共享内存并行计算&body=Check out this article: https://zoues.com/posts/d1d12995/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zoues.com/posts/d1d12995/&name=Ziglang适配OpenMP 循环指令以实现共享内存并行计算&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zoues.com/posts/d1d12995/&t=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Ziglang%E9%80%82%E9%85%8DOpenMP%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">Ziglang适配OpenMP循环指令以实现共享内存并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">I 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E8%83%8C%E6%99%AF%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">II 背景与相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#II-A-Zig"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">II-A Zig</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-Zig%E9%80%82%E9%85%8DOpenMP"><span class="toc-number">1.1.3.</span> <span class="toc-text">III Zig适配OpenMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">III-A 词法分析与语法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A1-%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8%E5%AD%90%E5%8F%A5"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">III-A1 处理列表子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A2-%E5%A4%84%E7%90%86%E5%8E%8B%E7%BC%A9%E5%AD%90%E5%8F%A5"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">III-A2 处理压缩子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">III-B 代码生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B1-%E5%A4%84%E7%90%86%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">III-B1 处理并行区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B2-%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E5%85%B1%E4%BA%AB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">III-B2 处理工作共享循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B3-%E5%8F%98%E9%87%8F%E9%87%8D%E5%86%99"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">III-B3 变量重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-C-%E5%B0%81%E8%A3%85-OpenMP-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">III-C 封装 OpenMP 运行时功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">实验方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-%E7%BB%93%E6%9E%9C%E4%B8%8E%E8%AF%84%E4%BC%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">V 结果与评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#V-A-%E5%85%B1%E8%BD%AD%E6%A2%AF%E5%BA%A6-CG"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">V-A 共轭梯度 (CG)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-B-%E6%9E%81%E6%98%93%E5%B9%B6%E8%A1%8C-EP"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">V-B 极易并行 (EP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-C-%E6%95%B4%E6%95%B0%E6%8E%92%E5%BA%8F-IS"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">V-C 整数排序 (IS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VI-%E7%BB%93%E8%AE%BA%E4%B8%8E%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.6.</span> <span class="toc-text">VI 结论与进一步工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.7.</span> <span class="toc-text">参考索引</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Ziglang适配OpenMP 循环指令以实现共享内存并行计算
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">zouyee</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-04T00:23:48.000Z" class="dt-published" itemprop="datePublished">2024-12-04</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/zig/" rel="tag">zig</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Ziglang适配OpenMP循环指令以实现共享内存并行计算"><a href="#Ziglang适配OpenMP循环指令以实现共享内存并行计算" class="headerlink" title="Ziglang适配OpenMP循环指令以实现共享内存并行计算"></a>Ziglang适配OpenMP循环指令以实现共享内存并行计算</h1><p>Original： <a target="_blank" rel="noopener" href="https://arxiv.org/html/2408.09902v1">https://arxiv.org/html/2408.09902v1</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Zig 编程语言以性能和安全性为核心设计目标，近年来逐渐受到欢迎。由于 Zig 基于 LLVM 构建，因此能够利用该生态系统的诸多优势，包括访问丰富的支持后端，这使得 Zig 在高性能工作负载方向具备显著潜力。然而，Zig 尚未在高性能计算（HPC）领域赢得广泛关注，其中一个原因是其缺乏基于预编译指令（pragma）实现共享内存并行计算的能力。</p>
<p>本文描述了如何通过优化 Zig 编译器来支持 OpenMP 循环指令，并使用 NASA 的并行基准测试套件（NPB）来测试其性能表现。 Zig 与 OpenMP 的集成不仅在扩展性上可与 Fortran 和 C 的 NPB 参考实现相媲美，同时在某些场景下，Zig 的性能相较Fortran来说，提升幅度多大1.25倍。</p>
<p><em><strong>Index Terms:</strong></em>  Zig, OpenMP, LLVM, High Performance Computing, NAS Parallel Benchmark suite</p>
<blockquote>
<p>目前Zig 社区在推动移除LLVM、LCD以及Clang代码库依赖，详见<a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/16270">https://github.com/ziglang/zig/issues/16270</a></p>
</blockquote>
<h3 id="I-介绍"><a href="#I-介绍" class="headerlink" title="I 介绍"></a>I 介绍</h3><p>随着高性能计算（HPC）领域迈入百亿亿次计算（Exascale）时代，面临的一个关键问题是如何选择用于超级计算机日益复杂场景的编程语言。目前 Fortran 和 C 等传统语言仍然占据着HPC领域的绝大多数份额。</p>
<p>Zig 是一种系统编程语言，由 Andrew Kelly 于 2016 年创建，设计目标是追求快速和安全。近年来，围绕这一语言逐渐形成充满活力的生态。目前Zig 在 HPC 领域已有一些边缘应用，例如 Cerebras 的 CSL 编程技术（用于其 Wafer Scale Engine，WSE）的开发是基于 Zig ，但总体而言，Zig 在 HPC 中尚未被广泛采用。其未被广泛采用的原因之一是语言本身缺乏对常见 HPC 编程技术的支持。尽管 Zig 的 C 互操作性特性十分出色，使得使用 MPI 相对简单，但其缺少对于 HPC 中普遍存在的基于编译指令（pragma）的共享内存并行编程的支持，因此需要对Zig编译器进行修改。</p>
<p>本文探索了一种通过为Zig 编译器添加OpenMP 循环指令的支持，实现基于编译指令的共享内存并行特性。通过调用 LLVM 的 OpenMP 运行时库，我们描述了支持 OpenMP 循环指令所需的修改，并比较了 NASA 的 NAS 并行基准测试套件（NPB）中内核在 C、Fortran 和 Zig 之间的性能表现。本文的结构如下：第二部分描述了该研究的背景；第三部分探讨了为支持 OpenMP 循环指令对 Zig 的增强；第四部分重点介绍了评估方法，包括将 Zig 与 C 和 Fortran 集成的探索；第五部分分析了 Zig 与 OpenMP 在这些基准中的性能表现；最后，第六部分总结了本文的研究，并讨论了未来工作。</p>
<p>本文的主要贡献包括：</p>
<ol>
<li><p>描述如何与 Zig 编译器中集成 OpenMP 循环指令。</p>
</li>
<li><p>首次探索 Zig 与 Fortran 代码的集成方式，为将 Zig 应用于更大规模的传统代码库提供了可能。</p>
</li>
<li><p>对 Zig、Fortran 和 C 在三项 HPC 基准测试中的进行性能对比，其中涵盖线程化时的加速比以及运行时性能。最终证明 Zig 表现良好，是 HPC 领域的可行选择。</p>
</li>
</ol>
<h3 id="II-背景与相关工作"><a href="#II-背景与相关工作" class="headerlink" title="II 背景与相关工作"></a>II 背景与相关工作</h3><p>LLVM 是一套工具和库，部分用于生成和操作LLVM-IR<sup>[1]</sup>。LLVM 上构建了丰富的后端，可以从这种内部表示生成机器代码，并支持多种硬件，包括 CPU、GPU 和 FPGA。除了在主代码库中提供针对 C 和 Fortran 的前端工具（如 Clang 和 Flang）外，LLVM 还被许多流行的编程语言使用，如 Swift<sup>[2]</sup>、Rust<sup>[3]</sup>和 Zig<sup>[4]</sup>。</p>
<p>LLVM 还提供了其自身的 OpenMP 库。OpenMP 是一种通过多线程实现的基于编译指令的共享内存并行编程技术，也是 HPC 中最受欢迎的编程技术之一。OpenMP 的核心功能通过指令实现，因此编译器需要修改以支持这些编译指令。OpenMP 标准<sup>[5]</sup>规定了 C、C++ 和 Fortran 程序员如何使用该技术，其中编译器指令在 C 和 C++ 中表示为预编译指令（pragma），而在 Fortran 中则表示为特殊注释。定义指令开始的这串标记被称为标志符。</p>
<h4 id="II-A-Zig"><a href="#II-A-Zig" class="headerlink" title="II-A Zig"></a>II-A Zig</h4><p>Zig 是由 Andrew Kelly 于 2016 年创建的系统编程语言，旨在成为 C 的一种更优化、更安全且更易读的替代方案<sup>[4]</sup>。Zig 的设计专注于减少程序执行时间，同时在安全性和编程体验上相比 C 提供更高的水平。Zig 使用 LLVM 编译器基础设施<sup>[6]</sup>进行代码生成，从而能够利用其优化功能<sup>[7]</sup>。这种对 LLVM 的利用使得 Zig 支持大量 CPU 架构和操作系统，其目标是支持所有由 LLVM 支持的目标平台<sup>[8]</sup>。</p>
<p>Zig 提供了一些安全特性来改善软件开发体验，主要包括比 C 更强的类型系统和改进的静态分析功能，以及在调试模式下编译器启用的可选运行时安全检查。静态分析功能可以帮助程序员防止常见的错误，例如解引用空指针或与整数和浮点数类型转换相关的截断和舍入错误。例如，在 C 中，对于 <code>int *ptr = 0</code>，解引用并读取 <code>ptr</code> 是合法的，但在运行时可能导致段错误。示例1 中的两个代码示例展示了 Zig 中如何防止这一问题。这两个示例均无法编译。第一个示例尝试将整数文字赋值给指针，这种隐式转换被 Zig 的类型系统所禁止。示例 1 中的第二个示例使用内置的 <code>@intToPtr</code> 函数执行显式的整数到指针转换，这种也会失败，因为在 Zig 中，只有可空指针可以被赋值为零。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ptr: *i32 = 0;</span><br><span class="line">_ = ptr.*;</span><br><span class="line">// —————————————</span><br><span class="line">var ptr: *i32 = @intToPtr(*i32, 0);</span><br><span class="line">_ = ptr.*;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 1：在 Zig 中如何表示解引用和读取 <code>ptr</code> 的示例（基于 C 中的 <code>int *ptr = 0</code>）。然而，由于 Zig 提供的安全性，这些示例均无法编译</p>
</blockquote>
<p>在编译时无法识别的错误可能会通过运行时的安全检查标记为未定义行为。Zig 为代码编译提供了两种模式：生产模式和调试模式。在调试模式下，额外的代码会被插入到可执行文件中，例如检查是否发生了数组越界或整数溢出。如果发生此类情况，会触发运行时错误。而在生产模式中，出于性能原因，不提供此类安全检查，因此未定义行为不会被捕获到。Zig建议程序员在开发代码时使用调试模式，在代码成熟后切换到生产模式。</p>
<p>Zig 的设计目标之一是与现有的 C 代码库实现互操作<sup>[9]</sup>。这使得开发者能够利用 C 的库和框架，例如 MPI<sup>[10]</sup>，并在项目中逐步用 Zig 替代 C。为实现这种互操作，Zig 提供了一种方法，既可以调用 C 函数，也可以让 C 调用 Zig 函数。示例2展示了从 Zig 调用 C 标准库函数 <code>puts</code> 的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern fn puts(s: [*:0]const u8) c_int;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">// calling puts</span><br><span class="line">  _ = puts(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 2：从 Zig 调用 C 函数的示例  </p>
</blockquote>
<p>示例3 展示了函数 <code>add</code> 被导出以供 C 使用的示例。该函数可以通过编译为目标文件（object file）或静态库(so)方式，链接到 C 程序中进行访问。此外，Zig 可以自动生成一个包含所有导出函数签名的 C 头文件，供 C 程序调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub export fn add(a: c_int, b: c_int) c_int&#123;</span><br><span class="line"> return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例3：导出 Zig 函数供 C 使用的示例</p>
</blockquote>
<p>Zig 编译器还提供了将 C 源代码转换为 Zig 的工具，这可以加速将整个项目或部分项目迁移到 Zig 的过程。此机制也被编译器用于自动解析 C 头文件，并导入其中的函数、结构体和常量。示例4展示了一个来自示例2的修改代码，其中函数 <code>puts</code> 的显式声明被替换为通过自动翻译 C 标准库 <code>stdio.h</code> 头文件所实现的导入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Importing the C stdio.h header</span><br><span class="line">const stdio = @cImport(@cInclude(&quot;stdio.h&quot;));</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line"> // calling the puts function from the stdio.h header</span><br><span class="line"> _ = stdio.puts(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例4：通过 Zig 导入 C 头文件并调用其中函数的示例</p>
</blockquote>
<h3 id="III-Zig适配OpenMP"><a href="#III-Zig适配OpenMP" class="headerlink" title="III Zig适配OpenMP"></a>III Zig适配OpenMP</h3><p>LLVM 提供了OpenMP 运行时库，而本文工作的目标是调用该库提供的函数，在 Zig 中实现基于 pragma 的共享内存并发编程。本节探讨了将带有 OpenMP pragma 注解的 Zig 源代码与 LLVM 的运行时库连接的方法。所有修改均基于 Zig 0.10.1版本。</p>
<h4 id="III-A-词法分析与语法解析"><a href="#III-A-词法分析与语法解析" class="headerlink" title="III-A 词法分析与语法解析"></a>III-A 词法分析与语法解析</h4><p>如第 II 节所述，OpenMP 依赖于 pragma 来指定程序如何并行，但 Zig 本身并不支持 pragma语法。因此，必须将其作为一种新类型的语句添加到Zig中。我们决定将 pragma 实现为特殊的注释，这与 Fortran 中的支持方式类似。  </p>
<p>Zig 编译管道的第一步是词法分析（tokenisation），主要决策点是选择将整个 pragma 解析为单个标记，还是将其每个字段解析为独立的标记，分别对应图 1 中的选项 A 和 B。最终决定通过标识符（sentinel），然后将 pragma 的其余部分作为常规代码进行标记化，假装标识符不存在。这种方法之所以可行，是因为 pragma 完全由 Zig 本身使用的标记组成。  </p>
<p><img src="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/pragma_tokens.png" alt="Refer to caption"></p>
<blockquote>
<p>图 1：解析方式选择的示意图，A) 将整个 pragma 解析为单个标记，或 B) 将 pragma 分解为多个标记</p>
</blockquote>
<p>Zig 的词法分析器支持对关键字进行标记化。因此，最初计划利用此机制来解析 OpenMP 的指令和子句（例如 <code>parallel</code> 或 <code>default</code>）作为关键字。然而，这种方法行不通，因为在 Zig 中关键字不能用作标识符，添加这些关键字会破坏与现有代码的兼容性。因此，解决方案是将 OpenMP 的关键字存储为标识符，并在解析时将其与常规标识符区分开。</p>
<p>标记化完成后，下一步是解析，这一步从标记生成抽象语法树（AST）。Pragma 应像其他语句一样被处理，Zig 解析器的核心是 <code>eatToken</code> 方法。该方法接受一个枚举值，表示标记的类型（称为标记标签）。如果下一个标记与标签匹配，则返回并推进解析器到下一个标记，否则返回 null。然而，由于 OpenMP 关键字未分配唯一的标签，该函数无法按正常工作。因此，添加了一组新标签来表示不同的 OpenMP 关键字，并使用字符串到关键字标记的哈希映射来识别字符串是否为关键字。我们修改了 <code>eatToken</code> 函数，使其能够接受新增关键词，并在解析 OpenMP 关键字标签时相应地解析标识符标签。</p>
<p>每个 OpenMP 指令都有一个 AST 节点标签，子句作为节点数据存储。子句数据存储在 <code>extra_data</code> 数组中，该数组是Zig 编译器用于注释 AST 节点的杂项数据的 32 位整数数组。所有子句数据必须能够以这种形式表示，其中所有子句都存储在单个数据结构中，其整数表示子句不同。</p>
<h4 id="III-A1-处理列表子句"><a href="#III-A1-处理列表子句" class="headerlink" title="III-A1 处理列表子句"></a>III-A1 处理列表子句</h4><p><code>private</code>、<code>firstprivate</code> 和 <code>shared</code> 子句被定义为标识符的列表。在获取每个标识符的 AST 节点索引后，这些索引被连续存储在 <code>extra_data</code> 数组中，子句结构的开始和结束索引则存储在子句中。图 2 展示了 <code>private</code> 子句的一个示例，其中指令节点包含一个索引到 <code>extra_data</code> 数组，表示子句结构的起始位置。</p>
<p><img src="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/private_clause.png" alt="Refer to caption"></p>
<blockquote>
<p>图 2：将私有变量存储在 <code>extra_data</code> 数组中的示例</p>
</blockquote>
<h4 id="III-A2-处理压缩子句"><a href="#III-A2-处理压缩子句" class="headerlink" title="III-A2 处理压缩子句"></a>III-A2 处理压缩子句</h4><p>非列表子句的存储大小是静态已知的，因此可以将它们存储在单一结构中。通过将该结构标记为压缩结构，可以将其视为一个 32 位整数并存储在 <code>extra_data</code> 数组中。这种方法允许通过读取数组的单个索引提取所有数据，无需进一步的间接访问。例如，循环调度信息存储为一个 3 位的枚举值（表示调度类型）以及一个 29 位的整数（表示区块大小），其支持多达 536,870,912 次迭代。由于区块大小必须大于 0<sup>[5]</sup>，值 0 表示未指定区块大小。</p>
<p>有些子句可以用少于 32 位表示，并将它们组合到一个压缩结构中。例如，<code>default</code> 子句使用 2 位的枚举表示，而 <code>nowait</code> 子句用一个布尔值表示，占用压缩结构中的 1 位。<code>collapse</code> 子句则占用 4 位，因为用户通常不会希望折叠超过 16 层的循环。</p>
<h4 id="III-B-代码生成"><a href="#III-B-代码生成" class="headerlink" title="III-B 代码生成"></a>III-B 代码生成</h4><p>在将 OpenMP 的 pragma 进行词法分析和语法解析后，下一步是代码生成。支持 OpenMP 的典型编译器会在指令的位置插入对 OpenMP 运行时的调用。这里的替换需要在编译期改造AST语法树时完成。</p>
<p>我们最初尝试直接修改 AST 并注入所需的 OpenMP 调用。然而，在 Zig 中，AST 节点与原始源代码之间存在严格的关联性，因此无法随意添加新的节点。基于此，我们尝试了一种变通方案：在解析目标源代码之前，向其开头预置一个函数和结构定义模板，以便在代码生成期间复制这些模板来完成 OpenMP 函数和结构实例化。然而，由于当前 Zig编译器的设计，此方法不可行，因为在编译过程中很难找到这些模板的位置并将其传播到 AST中。</p>
<p>因此，我们采用了基于预处理器的方法，这种方法的优点在于可以轻松生成新代码，而无需手动确保每个标记和 AST 节点引用源文件都在固定位置。当然，这种预处理方法也存在一些挑战，主要是因为 Zig并未涵盖该场景的步骤。首先，所有未使用的函数参数和非全局范围的变量必须显式丢弃，这意味着只有已知会使用的变量才应生成。第二个挑战是，在预处理阶段缺乏语义上下文（例如变量类型及其用途），这一点在 <strong>III-B3</strong> 中有更详细讨论。</p>
<p>将预处理器纳入 Zig 编译器的一个核心部分，具有以下几个优点。首先，这使预处理器可以复用 Zig 编译器中内置的解析基础设施。其次，通过在文件加载后立即执行预处理器，可以在无需修改的情况下继续使用编译器的缓存机制。</p>
<p>我们的预处理器在多个环节运行，通过每次处理不同的 OpenMP 构造来替换相关代码。其总体算法的伪代码在<strong>清单 5</strong>中进行了描述。例如，所有并行区域在工作共享循环之前被替换。因此，只要嵌套的构造属于不同类型，就无需在预处理器中进行特殊处理。伪代码中的 <code>&lt;&lt;adjust source offset&gt;&gt;</code> 是因为节点以源代码列表的偏移量表示，因此在每次替换代码后必须调整修改的位置偏移量。此外，伪代码展示了为每个替换节点通过 <code>create-payload</code> 创建一个负载（payload）。此负载包含进行替换所需的信息，例如每个指令需要在源代码中执行替换的位置，以及该指令的具体信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION preprocess (source, step)</span><br><span class="line"></span><br><span class="line">ast := parse-source-into-ast(source)</span><br><span class="line">replacements := empty-list</span><br><span class="line"></span><br><span class="line">FOREACH node IN ast DO</span><br><span class="line">IF node IS OpenMP-node AND</span><br><span class="line">&lt;&lt;node matches current step&gt;&gt; THEN</span><br><span class="line">append(replacements, create-payload(node))</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">IF step = parallel THEN</span><br><span class="line">FOREACH replacement IN replacements</span><br><span class="line">&lt;&lt;perform parallel region replacement&gt;&gt;</span><br><span class="line">&lt;&lt;adjust source offset&gt;&gt;</span><br><span class="line">END</span><br><span class="line">ELSE IF step == while THEN</span><br><span class="line">FOREACH replacement IN replacements</span><br><span class="line">&lt;&lt;perform worksharing loop replacement&gt;&gt;</span><br><span class="line">&lt;&lt;adjust source offset&gt;&gt;</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">IF &lt;&lt;is last step&gt;&gt; THEN</span><br><span class="line">RETURN source</span><br><span class="line">ELSE</span><br><span class="line">RETURN preprocess(source, step)</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 示例5：替换 OpenMP Pragma 和子句的预处理器算法的伪代码</p>
</blockquote>
<h4 id="III-B1-处理并行区域"><a href="#III-B1-处理并行区域" class="headerlink" title="III-B1 处理并行区域"></a>III-B1 处理并行区域</h4><p>大多数编译器通过函数分解的方式表示 OpenMP 并行区域，其中生成一个包含并行区域内容的函数<sup>[11]</sup>。访问这些区域的变量，例如默认共享的变量或通过 <code>shared</code>、<code>firstprivate</code> 或 <code>reduction</code> 子句显式捕获的变量，会作为参数传递给该函数。然后，该函数的指针被传递给 OpenMP 运行时库的函数，该函数会在每个线程上调用它。例如，LLVM 的 OpenMP API 使用 <code>__kmpc_fork_call</code> 实现此功能。</p>
<p>我们选择采用上述方法，传递给分解函数的变量作为参数传递给 OpenMP 运行时库函数 <code>__kmpc_fork_call</code>，后者将它们转发给分解函数的回调。<code>__kmpc_fork_call</code> 是变参函数，接受可变数量的参数。我们的设计是将参数分为三组，每组表示为 <code>?*anyopaque</code> 指针，这是 Zig 中等同于 C 的 <code>void *</code> 的类型。这三组参数指向包含 <code>firstprivate</code>、<code>shared</code> 和 <code>reduction</code> 子句变量的结构体。</p>
<p>在分解函数中，一旦 <code>?*anyopaque</code> 指针被还原为其原始类型，就会为这些结构体的每个成员变量创建变量并初始化值。例如：</p>
<ul>
<li>对于 <code>firstprivate</code> 子句，值为并行区域外作用域中的变量值；</li>
<li>对于 <code>shared</code> 子句，需要通过指针访问变量，并将共享变量的访问重写为指针访问；</li>
<li>对于 <code>private</code> 变量，只需在分解函数中简单定义。</li>
</ul>
<p><strong>Reduction 操作</strong>更为复杂，通过使用 Zig 的标准原子类型创建一个值来实现。一个 reduction 结构体被创建，包含指向这些原子值的指针，并以与其他变量相同的方式传递给分解函数回调。分解函数为每个 reduction 变量创建一个单独的变量，并使用 reduction 变量中持有的初始值进行初始化。初始化必须符合 OpenMP 标准<sup>[5]</sup>。为了保证线程安全，基于原子类型定义了原子读-修改-写操作。</p>
<p>然而，这种方法受限于 Zig 支持的原子操作。目前 Zig 仅支持加法、减法、最小值、最大值、二进制与（AND）、或（OR）、非与（NAND）、异或（XOR）和比较交换（CAS）。例如，乘法和逻辑与或不支持。我们使用 CAS 循环算法<sup>[12]</sup>实现了这些缺失的 reduction 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">atom := &lt;&lt;value to be updated&gt;&gt;</span><br><span class="line">operand := &lt;&lt;value to update it with&gt;&gt;</span><br><span class="line"></span><br><span class="line">old := atomic-load(atom)</span><br><span class="line">new := old * operand</span><br><span class="line"></span><br><span class="line">WHILE TRUE DO</span><br><span class="line"> exchange-success, actual-value :=</span><br><span class="line"> compare-and-swap(&amp;atom, old, new)</span><br><span class="line"> IF exchange-success THEN</span><br><span class="line"> BREAK</span><br><span class="line"> ELSE</span><br><span class="line"> old = actual-value</span><br><span class="line"> new = old * operand</span><br><span class="line"> END</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 清单 6 展示了我们使用 CAS 算法实现乘法 reduction 的伪代码。</p>
</blockquote>
<h4 id="III-B2-处理工作共享循环"><a href="#III-B2-处理工作共享循环" class="headerlink" title="III-B2 处理工作共享循环"></a>III-B2 处理工作共享循环</h4><p>与并行区域不同，工作共享循环不需要分解函数。Clang 的 OpenMP API 提供了两种实现工作共享循环的策略：</p>
<ol>
<li><strong>静态调度</strong>：通过 <code>__kmpc_for_static_*</code> 函数实现；</li>
<li><strong>动态、分布式和运行时调度</strong>：通过 <code>__kmpc_dispatch_*</code> 函数实现。</li>
</ol>
<p>这两种策略都要求明确循环的上界、下界、增量和比较操作符：</p>
<ul>
<li>比较操作符直接从 Zig <code>while</code> 循环的条件中获取；</li>
<li>下界由循环计数器变量的初始值决定；</li>
<li>上界来自比较操作符右侧的值；</li>
<li>增量来自继续表达式中增量操作符右侧的值。</li>
</ul>
<p>静态调度的 <code>__kmpc_for_static_*</code> 包括：</p>
<ul>
<li><code>__kmpc_for_static_init</code>：执行循环迭代；</li>
<li><code>__kmpc_for_static_fini</code>：每个线程完成后调用以最终化循环。</li>
</ul>
<p>对于动态循环，<code>__kmpc_dispatch_next</code> 用于处理下一个批次的迭代，而 <code>__kmpc_dispatch_init</code> 接收调度类型（如 <code>kmp_sch_dynamic_chunked</code>、<code>kmp_sch_guided_chunked</code>、<code>kmp_sch_runtime</code>）。</p>
<h4 id="III-B3-变量重写"><a href="#III-B3-变量重写" class="headerlink" title="III-B3 变量重写"></a>III-B3 变量重写</h4><p>预处理器尽量利用已有的变量名和表达式，例如，在分解函数中解包 <code>private</code> 和 <code>firstprivate</code> 变量时复用相同的变量名。但也有不尽如人意之处，例如，<code>shared</code> 变量必须重写为指针访问，而工作共享循环的 reduction 临时变量可能不能与其对应的 <code>shared</code> 变量同名。</p>
<p>由于预处理时缺乏语义上下文，这种替换更具挑战性。得益于 Zig 的简单语法<sup>[13]</sup>和无变量遮蔽机制，其只需利用 AST即可实现变量重写。</p>
<h4 id="III-C-封装-OpenMP-运行时功能"><a href="#III-C-封装-OpenMP-运行时功能" class="headerlink" title="III-C 封装 OpenMP 运行时功能"></a>III-C 封装 OpenMP 运行时功能</h4><p>OpenMP 标准定义了一组运行时函数，这些函数必须由符合 OpenMP 实现的运行时库提供。这些函数旨在让用户直接调用，通过 <code>omp_</code> 前缀标识，例如 <code>omp_get_thread_num</code> 和 <code>omp_get_num_threads</code>。为了使 Zig 程序员能够使用这些函数，我们在标准库中添加了一个 <code>omp</code> 命名空间，并通过 Zig 编译器的 <code>translate-c</code> 功能将所有函数声明从 C 转换为 Zig。这些转换后的函数声明随后被重新导出，同时移除了 <code>omp_</code> 前缀。示例 7 展示了如何通过此方法在 Zig 中获取线程 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const omp = @import(&quot;std&quot;).omp;</span><br><span class="line">const thread_id = omp.get_thread_num();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 7：使用 OpenMP 库封装器在 Zig 中获取线程 ID。</p>
</blockquote>
<p>除了为 Zig 程序员提供的标准 OpenMP API，我们还需要一个内部 OpenMP API 供预处理器使用，以实现将 OpenMP 编译指令映射到 LLVM OpenMP 运行时库。这些函数和常量并非由 OpenMP 标准定义，而是由运行时实现（例如 LLVM OpenMP 的 <code>libomp</code>）提供。这些函数声明与标准 OpenMP 函数采用相同方式转换，但被放置在 <code>.omp.internal</code> 命名空间中。与标准 API 不同，这些函数在导出时没有移除前缀，它们非直接供程序员使用。</p>
<p>此外，<code>.omp.internal</code> 命名空间还包含一些开发的辅助工具，这些工具被预处理器用来支持 OpenMP 功能的实现。例如，<code>__kmpc_dispatch_*</code> 和 <code>__kmpc_for_static_*</code> 函数族的通用封装器，以及 III-B1 节中描述的 CAS 循环 reduction 算法。</p>
<h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><p>本文中的所有基准测试均在 Cray-EX ARCHER2 超级计算机的单节点上进行。每个节点由两个 64 核 AMD EPYC 7742 处理器组成，每个核包含32KB 的 L1 数据缓存、32KB 的 L1 指令缓存和 512KB 的 L2 缓存，以及由四个核共享的 16.4MB 的 L3 缓存。基准测试中使用的 OpenMP 运行时为基于 LLVM 13.0.0 的 libomp，它被 AMD 优化的 C 和 Fortran 编译器（AOCC）使用。C 和 Fortran 基准测试的参考实现分别通过 AOCC 的 Clang 和 Flang 编译器进行编译，使用相同的 OpenMP 运行时。与 Zig 版本基准测试集成的 Fortran 代码由 GNU gfortran 编译器（版本 7.5.0）编译，所有 C 代码均由 AMD Clang（版本 13.0.0）编译。AOCC 和 gfortran 的版本均为基准测试时 ARCHER2 平台上可用的最新版本。</p>
<p>每项基准测试针对每种线程数运行 5 次，并报告 5 次运行的平均值。执行时间使用参考实现中的内部计时器测量。</p>
<p>由于目前尚无现成的 Zig 高性能计算 (HPC) 基准测试，本文决定使用其他成熟 HPC 语言（如 Fortran 和 C）创建的基准测试，并将其转换为 Zig。为将 C 代码转换为 Zig，本文使用了 Zig 提供的 <code>translate-c</code> 子命令。然而，该工具实际使用中存在一些限制。首先，它会忽略所有 C 的编译指令（pragma），导致所有 OpenMP 相关信息丢失。其次，<code>translate-c</code> 会在转换代码为 Zig 之前执行 C 的预处理器，这意味着所有通过 <code>#include</code> 引入的头文件也会被转换并出现在生成的 Zig 代码中。例如，示例 8 展示了一段定义返回预处理器定义常量的 C 代码，而清单 9 显示了转换后的 Zig 代码，尽管 <code>CONSTANT</code> 被定义了，但并未直接使用，取而代之的是其展开后的值。因此，尽管该工具有一定帮助，但这些限制意味着部分代码仍需手动移植并进行严格验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT (37 + 5)</span><br><span class="line"></span><br><span class="line">int foo(void) &#123; return CONSTANT; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 8: 用 translate-c 子命令转换的 C 程序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub export fn foo() c_int &#123;</span><br><span class="line">    return @as(c_int, 37) + @as(c_int, 5);</span><br><span class="line">&#125;</span><br><span class="line">pub const CONSTANT = @as(c_int, 37) + @as(c_int, 5);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 9: 使用 translate-c 子命令从 C 代码转换的 Zig 程序</p>
</blockquote>
<p>Zig 编译器没有提供 Fortran 等效的 translate-c，因此所有 Fortran 代码都需要手动移植。然而，Zig 和 Fortran 之间有几个主要区别，最显著的是 Fortran 中的数组是从 1 开始索引的，且 DO 循环的上界是包含在内的，而 Zig 中则不是。因此，在这样的移植过程中，所有数组索引和循环下界都需要调整，这增加了复杂性。</p>
<p>尽管以前从未这样做过，但从 Zig 调用 Fortran 过程的过程类似于调用 C 函数，所有参数类型都更改为指针。此外，为了符合 LLVM 的名称修饰方案，必须在函数名的末尾添加一个下划线。同样，也可以从 Fortran 调用 Zig 函数，但必须再次注意名称修饰方案。例如，只有 GNU gfortran 提供可预测的全局变量条目名称。</p>
<h3 id="V-结果与评估"><a href="#V-结果与评估" class="headerlink" title="V 结果与评估"></a>V 结果与评估</h3><p>在这项工作中，我们利用了 NAS 并行基准测试 (NPB) 套件中的内核，该套件包括基于计算流体动力学 (CFD) 应用中常见算法模式的各种内核。</p>
<h4 id="V-A-共轭梯度-CG"><a href="#V-A-共轭梯度-CG" class="headerlink" title="V-A 共轭梯度 (CG)"></a>V-A 共轭梯度 (CG)</h4><p>共轭梯度 (CG) 是我们选择的第一个基准测试，它利用了我们支持的大量 OpenMP 特性。我们将 Fortran 中的 conj_grad 子程序移植到 Zig 中，该子程序占据了大约 95% 的运行时间。这个子程序包括并行和工作共享指令、private、shared 和 firstprivate 变量共享子句、nowait 子句，以及在并行区域和工作共享循环上的归约操作。此外，这个内核还代表了在高性能计算 (HPC) 中形成大量工作负载的迭代算法。</p>
<p><img src="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/cg-speedup.png" alt="Refer to caption"></p>
<blockquote>
<p>图 3：CG 基准测试（C 类）在不同线程数下的加速比（包括我们在 Zig 中的方法和 Fortran 参考实现）</p>
</blockquote>
<p>图3展示了在不同线程数下进行强缩放时，在C类问题规模下CG 内核的加速比。两种语言在 64 个线程以内通常遵循阿姆达尔定律，但在 96 和 128 个线程上运行时表现显著优于预期。这似乎是算法的固有特性，因为我们的 Zig 移植版和参考实现都遵循几乎相同的加速曲线，表明在这个基准测试中，Fortran 中的 OpenMP 和 Zig 中的 OpenMP 之间的性能非常相似。</p>
<blockquote>
<p>表 I：在强缩放时，Zig 和 Fortran NPB CG 基准测试（C 类）在不同线程数下的运行时间</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Number of threads</strong></th>
<th><strong>Zig runtime (s)</strong></th>
<th><strong>Fortran runtime (s)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>149.40</td>
<td>170.17</td>
</tr>
<tr>
<td>2</td>
<td>82.34</td>
<td>83.35</td>
</tr>
<tr>
<td>16</td>
<td>21.85</td>
<td>21.80</td>
</tr>
<tr>
<td>32</td>
<td>11.26</td>
<td>11.28</td>
</tr>
<tr>
<td>64</td>
<td>5.83</td>
<td>5.98</td>
</tr>
<tr>
<td>96</td>
<td>2.80</td>
<td>2.98</td>
</tr>
<tr>
<td>128</td>
<td>1.81</td>
<td>2.07</td>
</tr>
</tbody></table>
<p>表I显示了 Zig 和 Fortran 中 CG 基准测试的运行时间，可以看出，Zig 版本在单核上比 Fortran 代码快 1.15 倍，随后在所有其他线程数下性能大致相等，尽管 Zig 往往比 Fortran 略快。</p>
<h4 id="V-B-极易并行-EP"><a href="#V-B-极易并行-EP" class="headerlink" title="V-B 极易并行 (EP)"></a>V-B 极易并行 (EP)</h4><p>极易并行 (EP) 内核仅关注计算性能，不需要线程之间的同步，并具有高效的内存访问模式。除了计时和验证例程外，我们将整个代码从 Fortran 移植到 Zig。这个内核利用了 private 和 firstprivate 变量共享子句，以及并行区域归约。此外，还使用了 threadprivate 和 atomic 指令。</p>
<p><img src="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/ep-speedup.png" alt="Refer to caption"></p>
<blockquote>
<p>图 4：EP 基准测试（C 类）在不同线程数下的加速比（包括我们在 Zig 中的方法和 Fortran 参考实现）</p>
</blockquote>
<p>图4显示C类问题规模时进行强缩放时，Zig 移植版和 Fortran 参考实现版本的 EP 基准测试的加速比。可以看出，对于 Zig 移植版和参考实现，因为该算法不需要线程之间的通信，所以加速比与线程数成正比。例外情况出现在 128 个线程时，Fortran 参考实现的加速比超过了 128 倍，意味着该基准测试受益于超线性缩放，而在 Zig 移植版中未观察到这种情况。这可能是由于 Fortran 版本在更多线程数下更好地利用了缓存，因为每个线程的问题规模减少了。</p>
<blockquote>
<p>表 II：在强缩放时，Zig 和 Fortran NPB EP 基准测试（C 类）在不同线程数下的运行时间</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Number of threads</strong></th>
<th><strong>Zig runtime (s)</strong></th>
<th><strong>Fortran runtime (s)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>147.66</td>
<td>185.26</td>
</tr>
<tr>
<td>2</td>
<td>76.17</td>
<td>94.90</td>
</tr>
<tr>
<td>16</td>
<td>9.84</td>
<td>11.83</td>
</tr>
<tr>
<td>32</td>
<td>4.72</td>
<td>5.92</td>
</tr>
<tr>
<td>64</td>
<td>2.29</td>
<td>2.84</td>
</tr>
<tr>
<td>96</td>
<td>1.57</td>
<td>1.97</td>
</tr>
<tr>
<td>128</td>
<td>1.36</td>
<td>1.42</td>
</tr>
</tbody></table>
<p>表II显示了在强缩放时，Zig 移植版和 Fortran版本实现的 EP 基准测试的运行时间，可以看出，Zig 版本平均比Fortan版本快 1.2 倍。这与 CG 基准测试类似，基于 Fortran 在这些科学工作负载中的流行程度，我们对此结论感到惊讶。尽管 Fortran 版本在 128 核时表现变好，但其执行速度仍然比 Zig 版本的基准测试慢。</p>
<h4 id="V-C-整数排序-IS"><a href="#V-C-整数排序-IS" class="headerlink" title="V-C 整数排序 (IS)"></a>V-C 整数排序 (IS)</h4><p>整数排序 (IS) 内核包含间接内存访问，旨在对内存子系统施加压力。该内核利用了 private 和 firstprivate 共享指令，并使用了 static,1 调度。IS 基准测试与本文考虑的其他基准测试的主要区别在于，它是用 C 语言编写的，我们将占总运行时间约 70% 的 rank 函数移植到了 Zig。</p>
<p><img src="https://arxiv.org/html/2409.20148v1/extracted/5889514/images/is-speedup.png" alt="Refer to caption"></p>
<p>图 5：IS 基准测试（C 类）在不同线程数下的加速比（包括我们在 Zig 中的方法和 C 参考实现）</p>
<p>图5显示了在C类问题规模下进行强缩放时，Zig 移植版与 C 参考实现的 IS 基准测试在不同线程数下的加速比。可以看出，这两个版本的基准测试在整个线程数范围内遵循非常相似的缩放模式，然而 Zig 版本在初始阶段缩放得更好，因此在较多线程数时能够提供更大的加速比。</p>
<p>表 III：在强缩放时，Zig 和 Fortran NPB IS 基准测试（C 类）在不同线程数下的运行时间</p>
<table>
<thead>
<tr>
<th><strong>Number of threads</strong></th>
<th><strong>Zig runtime (s)</strong></th>
<th><strong>Fortran runtime (s)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>11.87</td>
<td>9.29</td>
</tr>
<tr>
<td>2</td>
<td>6.12</td>
<td>4.76</td>
</tr>
<tr>
<td>16</td>
<td>1.05</td>
<td>0.93</td>
</tr>
<tr>
<td>32</td>
<td>0.55</td>
<td>0.54</td>
</tr>
<tr>
<td>64</td>
<td>0.33</td>
<td>0.31</td>
</tr>
<tr>
<td>96</td>
<td>0.29</td>
<td>0.28</td>
</tr>
<tr>
<td>64</td>
<td>0.27</td>
<td>0.24</td>
</tr>
</tbody></table>
<p>表III显示了在强缩放时，IS 基准测试的运行时间。可以看出，与 Fortran 基准测试相比，对于用 C 实现的基准测试，C 版本在单线程上表现最佳。虽然在并发1场景下运行时差异明显，在更多线程数时，两种语言的性能非常接近。</p>
<h3 id="VI-结论与进一步工作"><a href="#VI-结论与进一步工作" class="headerlink" title="VI 结论与进一步工作"></a>VI 结论与进一步工作</h3><p>在本文中，我们探讨了通过添加 OpenMP 的循环共享结构来增强 Zig。Zig 最初设计为一种系统编程语言，并利用了 LLVM 生态系统，该语言的一个主要特点是提供性能和安全性，这使其成为高性能计算（HPC）未来的一个非常有趣的潜在编程语言。虽然在 Zig 中调用 C 函数的能力意味着与 MPI 的集成相对简单，但支持基于 pragma 的 OpenMP 方法需要对编译器进行额外工作，但这对于该语言被 HPC 社区采纳却至关重要。</p>
<p>在描述了我们通过在编译器中支持 OpenMP 循环指令来为 Zig 添加基于 pragma 的共享内存并行性的方法之后，我们进行了使用 NASA 的 NPB 基准测试套件的性能对比。我们证明了该方法提供了类似于 C 和 Fortran 编译器的线程缩放，通过观察发现 Zig 基准测试的运行时间低于其 Fortran 对应版本。鉴于 Fortran 在科学计算中的应用范围，这些结果令我们感到惊讶。</p>
<p>我们认为推动 Zig 在 HPC 中落地的关键性条件将是为 Zig 编译器添加支持分析功能。目前，Zig 编译器使用 Tracy 库<sup>[17]</sup>进行分析，该库的 Zig 接口是编译器本身的一部分，不能在应用程序中使用。修改编译器以自动为应用程序添加调用该库的代码，提供类似于 gprof 的功能。此外，增强 Zig 与 Fortran 之间的互操作性非常重要，这将使 Zig 能够集成到现有的大型 Fortran 代码库中。虽然在本文中我们已经证明了这种集成是可行的，但这需要在编译器内部进行额外的工作，并可能扩展 Fortran 标准，以确保这种方法的可靠性和一致性。</p>
<p>总之，我们得出结论，Zig 编程语言所提供的性能和安全性组合使其有潜力应用于 HPC 工作负载场景。通过增强编译器以支持 OpenMP 循环指令，我们提供了在 Zig 中基于 pragma 的共享内存并行性的能力，并证明了其缩放性与其他语言相当。此外，对于 HPC 工作负载，性能甚至超过原有语言。</p>
<h3 id="参考索引"><a href="#参考索引" class="headerlink" title="参考索引"></a>参考索引</h3><ol>
<li><p>C. Lattner, Architecture of open source applications &#x2F; structure, scale, and a few more fearless hacks.   Lulu Com, 2012, vol. 1. [Online]. Available: <a target="_blank" rel="noopener" href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p>
</li>
<li><p>Apple, “Swift compiler,” 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.swift.org/swift-compiler/">https://www.swift.org/swift-compiler/</a></p>
</li>
<li><p>“The rustc book,” 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rustc/what-is-rustc.html">https://doc.rust-lang.org/rustc/what-is-rustc.html</a></p>
</li>
<li><p>A. Kelly, “Introduction to the Zig programming language,” Feb 2016. [Online]. Available: <a target="_blank" rel="noopener" href="https://andrewkelley.me/post/intro-to-zig.html">https://andrewkelley.me/post/intro-to-zig.html</a></p>
</li>
<li><p>OpenMP Application Programming Interface, nov 2021. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5-2.pdf">https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5-2.pdf</a></p>
</li>
<li><p>The LLVM Compiler Infrastructure, 06 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://llvm.org/">https://llvm.org/</a></p>
</li>
<li><p>The LLVM Compiler Infrastructure, 08 2023. [Online]. Available: LLVM’s Analysis and Transform Passes</p>
</li>
<li><p>A. Kelley, “bindings.zig,” Mar 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/blob/master/src/codegen/llvm/bindings.zig">https://github.com/ziglang/zig/blob/master/src/codegen/llvm/bindings.zig</a></p>
</li>
<li><p>A. Kelly, “Complete C ABI Compatibility,” Feb 2016. [Online]. Available: <a target="_blank" rel="noopener" href="https://andrewkelley.me/post/intro-to-zig.html#c-abi">https://andrewkelley.me/post/intro-to-zig.html#c-abi</a></p>
</li>
<li><p>MPI: A Message-Passing Interface Standard Version 4.0, Message Passing Interface Forum, jun 2021. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.mpi-forum.org/docs/mpi-4.0/mpi40-report.pdf">https://www.mpi-forum.org/docs/mpi-4.0/mpi40-report.pdf</a></p>
</li>
<li><p>13.10 Implementing PARALLEL construct. [Online]. Available: <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libgomp/Implementing-PARALLEL-construct.html">https://gcc.gnu.org/onlinedocs/libgomp/Implementing-PARALLEL-construct.html</a></p>
</li>
<li><p>H. Sutter, “How to write a CAS loop using std::atomics,” aug 2012. [Online]. Available: <a target="_blank" rel="noopener" href="https://herbsutter.com/2012/08/31/reader-qa-how-to-write-a-cas-loop-using-stdatomics/">https://herbsutter.com/2012/08/31/reader-qa-how-to-write-a-cas-loop-using-stdatomics/</a></p>
</li>
<li><p>Zig Language Reference. [Online]. Available: <a target="_blank" rel="noopener" href="https://ziglang.org/documentation/0.10.1/#Grammar">https://ziglang.org/documentation/0.10.1/#Grammar</a></p>
</li>
<li><p>LLVM&#x2F;OpenMP, 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://openmp.llvm.org/">https://openmp.llvm.org/</a></p>
</li>
<li><p>Programming languages — Fortran, ISO&#x2F;IEC, 2004. [Online]. Available: <a target="_blank" rel="noopener" href="https://j3-fortran.org/doc/year/04/04-007.pdf">https://j3-fortran.org/doc/year/04/04-007.pdf</a></p>
</li>
<li><p>“NAS Parallel Benchmarks,” Jul 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.nas.nasa.gov/software/npb.html">https://www.nas.nasa.gov/software/npb.html</a></p>
</li>
<li><p>B. Taudul, R. Kupstys, A. Machizaud, and A. Gerstmann, “Tracy Profiler,” aug 2023. [Online]. Available: <a target="_blank" rel="noopener" href="https://github.com/wolfpld/tracy">https://github.com/wolfpld/tracy</a></p>
</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Ziglang%E9%80%82%E9%85%8DOpenMP%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text">Ziglang适配OpenMP循环指令以实现共享内存并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">I 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E8%83%8C%E6%99%AF%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">II 背景与相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#II-A-Zig"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">II-A Zig</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-Zig%E9%80%82%E9%85%8DOpenMP"><span class="toc-number">1.1.3.</span> <span class="toc-text">III Zig适配OpenMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">III-A 词法分析与语法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A1-%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8%E5%AD%90%E5%8F%A5"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">III-A1 处理列表子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-A2-%E5%A4%84%E7%90%86%E5%8E%8B%E7%BC%A9%E5%AD%90%E5%8F%A5"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">III-A2 处理压缩子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">III-B 代码生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B1-%E5%A4%84%E7%90%86%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">III-B1 处理并行区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B2-%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E5%85%B1%E4%BA%AB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">III-B2 处理工作共享循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-B3-%E5%8F%98%E9%87%8F%E9%87%8D%E5%86%99"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">III-B3 变量重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-C-%E5%B0%81%E8%A3%85-OpenMP-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">III-C 封装 OpenMP 运行时功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">实验方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-%E7%BB%93%E6%9E%9C%E4%B8%8E%E8%AF%84%E4%BC%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">V 结果与评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#V-A-%E5%85%B1%E8%BD%AD%E6%A2%AF%E5%BA%A6-CG"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">V-A 共轭梯度 (CG)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-B-%E6%9E%81%E6%98%93%E5%B9%B6%E8%A1%8C-EP"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">V-B 极易并行 (EP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-C-%E6%95%B4%E6%95%B0%E6%8E%92%E5%BA%8F-IS"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">V-C 整数排序 (IS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VI-%E7%BB%93%E8%AE%BA%E4%B8%8E%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.6.</span> <span class="toc-text">VI 结论与进一步工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.7.</span> <span class="toc-text">参考索引</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zoues.com/posts/d1d12995/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zoues.com/posts/d1d12995/&text=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zoues.com/posts/d1d12995/&is_video=false&description=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Ziglang适配OpenMP 循环指令以实现共享内存并行计算&body=Check out this article: https://zoues.com/posts/d1d12995/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zoues.com/posts/d1d12995/&title=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zoues.com/posts/d1d12995/&name=Ziglang适配OpenMP 循环指令以实现共享内存并行计算&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zoues.com/posts/d1d12995/&t=Ziglang适配OpenMP 循环指令以实现共享内存并行计算"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    zouyee
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
