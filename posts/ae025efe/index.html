<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="如果你以前只有在宏、泛型或代码生成场景中体会过编译时执行，那么可以在Zig语言中好好体会一番。 Zig是由Andrew Kelley开发的一种新的通用编程语言。尽管仍在积极开发中（当前版本0.13），但我认为这种语言已经展现出了巨大的潜力。Zig的目标是成为更好的C，类似于Rust可以被理解为更好的C++。它没有垃圾回收，没有内置事件循环，也没有其他运行时机制。它像C一样精简，并且实际上可以与C轻">
<meta property="og:type" content="article">
<meta property="og:title" content="超越C++：Ziglang 元编程一文打尽">
<meta property="og:url" content="https://zoues.com/posts/ae025efe/index.html">
<meta property="og:site_name" content="zouyee">
<meta property="og:description" content="如果你以前只有在宏、泛型或代码生成场景中体会过编译时执行，那么可以在Zig语言中好好体会一番。 Zig是由Andrew Kelley开发的一种新的通用编程语言。尽管仍在积极开发中（当前版本0.13），但我认为这种语言已经展现出了巨大的潜力。Zig的目标是成为更好的C，类似于Rust可以被理解为更好的C++。它没有垃圾回收，没有内置事件循环，也没有其他运行时机制。它像C一样精简，并且实际上可以与C轻">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-09T10:00:43.000Z">
<meta property="article:modified_time" content="2024-11-09T10:06:39.752Z">
<meta property="article:author" content="zouyee">
<meta property="article:tag" content="zig">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>超越C++：Ziglang 元编程一文打尽</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="zouyee" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/ffe3c38f/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zoues.com/posts/ae025efe/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zoues.com/posts/ae025efe/&text=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zoues.com/posts/ae025efe/&is_video=false&description=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=超越C++：Ziglang 元编程一文打尽&body=Check out this article: https://zoues.com/posts/ae025efe/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zoues.com/posts/ae025efe/&name=超越C++：Ziglang 元编程一文打尽&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zoues.com/posts/ae025efe/&t=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Phase-distinction"><span class="toc-number">1.</span> <span class="toc-text">Phase distinction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">2.</span> <span class="toc-text">编译时与运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6"><span class="toc-number">2.1.</span> <span class="toc-text">编译时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">2.2.</span> <span class="toc-text">运行时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zig-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">Zig 元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">3.2.</span> <span class="toc-text">编译时执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">编译时函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.4.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">3.5.</span> <span class="toc-text">泛型类型与反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        超越C++：Ziglang 元编程一文打尽
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">zouyee</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-11-09T10:00:43.000Z" class="dt-published" itemprop="datePublished">2024-11-09</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/zig/" rel="tag">zig</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>如果你以前只有在宏、泛型或代码生成场景中体会过编译时执行，那么可以在Zig语言中好好体会一番。</p>
<p>Zig是由Andrew Kelley开发的一种新的通用编程语言。尽管仍在积极开发中（当前版本0.13），但我认为这种语言已经展现出了巨大的潜力。Zig的目标是成为更好的C，类似于Rust可以被理解为更好的C++。它没有垃圾回收，没有内置事件循环，也没有其他运行时机制。它像C一样精简，并且实际上可以与C轻松互操作。有关完整概述，请访问官网。</p>
<p>如果你对Zig操作的抽象级别有一般的了解，那么也就不会对在运行时没有反射感到惊讶；在编译时无法做的事情，可以在编译时完成。</p>
<h2 id="Phase-distinction"><a href="#Phase-distinction" class="headerlink" title="Phase distinction"></a>Phase distinction</h2><p>阶段区分是指在编程语言中，类型和术语之间有严格分隔的一种特性。Luca Cardelli 提出了一个简明的规则，用于判断语言是否保持了阶段区分：如果 A 是一个编译时术语，并且 B 是 A 的一个子术语，那么 B 也必须是一个编译时术语。</p>
<p>大多数静态类型语言都遵循阶段区分原则。然而，一些拥有特别灵活且表达能力强的类型系统的语言（尤其是依赖类型的编程语言）允许像操作普通术语一样操作类型。类型可以被传递给函数或作为结果返回。</p>
<p>具有阶段区分的语言可能会为类型和运行时变量设置单独的命名空间。在优化编译器中，阶段区分标记了哪些表达式可以安全删除的边界。</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>阶段区分通常与静态检查结合使用。通过基于演算的系统，阶段区分消除了在不同类型和术语之间实施线性逻辑的必要性。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>阶段区分将编译时的处理与运行时的处理区分开来。</p>
<p>一种简单的语言，其术语包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t ::= true | false | x | λx : T . t | t t | if t then t else t</span><br></pre></td></tr></table></figure>

<p>以及类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T ::= Bool | T -&gt; T </span><br></pre></td></tr></table></figure>

<p>注意类型和术语是如何分开的。在编译时，类型用于验证术语的正确性。然而，在运行时，类型并不起任何作用。</p>
<h2 id="编译时与运行时"><a href="#编译时与运行时" class="headerlink" title="编译时与运行时"></a>编译时与运行时</h2><p>编译时与运行时源自“Phase distinction”理论。这个概念是较难理解，尤其是对于编程语言背景不太深的人来说。为了解决这个问题，我觉得有帮助的办法是回答下面几个问题：</p>
<ol>
<li>程序满足了哪些不变性？</li>
<li>在这个阶段可能出什么问题？</li>
<li>如果这个阶段成功了，我们知道什么后置条件？</li>
<li>如果有输入和输出，它们是什么？</li>
</ol>
<h3 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h3><p>程序不需要满足任何不变性。实际上，它甚至不需要是一个格式正确的程序。你可以把一段 HTML 代码交给编译器，编译器会直接报错……</p>
<p>编译时可能出的问题：</p>
<ul>
<li>语法错误</li>
<li>类型检查错误</li>
<li>（极少情况）编译器崩溃</li>
</ul>
<p>如果编译成功，我们知道什么？</p>
<ul>
<li>程序格式正确——在所使用的语言中是一个有意义的程序。</li>
<li>程序可以开始运行。（程序可能会立刻失败，但至少我们可以尝试运行。）</li>
</ul>
<p>输入和输出是什么？</p>
<ul>
<li>输入是正在编译的程序，加上任何头文件、接口、库，或其他为了编译而需要导入的内容。</li>
<li>输出通常是汇编代码、可重定位的目标代码，或者甚至是一个可执行程序。或者如果出错了，输出是一堆错误信息。</li>
</ul>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>我们对程序的不变性一无所知——它们完全由程序员设定。运行时的不变性很少只靠编译器来保证；这通常需要程序员的帮助。</p>
<p>运行时可能出的问题：</p>
<ul>
<li>运行时错误：<ul>
<li>除零错误</li>
<li>解引用空指针</li>
<li>内存不足</li>
</ul>
</li>
<li>还可能有程序自身检测到的错误：<ul>
<li>尝试打开一个不存在的文件</li>
<li>试图查找网页却发现提供的 URL 格式不正确</li>
</ul>
</li>
</ul>
<p>如果运行时成功，程序就会顺利完成（或继续运行）而不会崩溃。</p>
<p>输入和输出完全由程序员决定。例如，文件、屏幕上的窗口、网络数据包、发送到打印机的作业等等。假如程序发射导弹，那也是一个输出，并且只能在运行时发生 :-)</p>
<p><strong>在编译时运行代码</strong></p>
<p>让我们从基础知识开始：使用<code>comptime</code>关键字可以在编译时运行任意代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn multiply(a: i64, b: i64) i64 &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    const len = comptime multiply(4, 5);</span><br><span class="line">    const my_static_array: [len]u8 = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数定义没有任何说明在编译时可用的属性。这只是一个普通的函数，我们在调用点请求其在编译时执行。</p>
<p><strong>在编译时定义块</strong></p>
<p>你还可以使用<code>comptime</code>在函数内定义编译时块。以下示例是一个处理不区分大小写的字符串比较函数，针对其中一个字符串是硬编码的情况进行了优化。编译时执行确保函数不被滥用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn insensitive_eql(comptime uppr: []const u8, str: []const u8) bool &#123;</span><br><span class="line">    comptime &#123;</span><br><span class="line">        var i = 0;</span><br><span class="line">        while (i &lt; uppr.len) : (i += 1) &#123;</span><br><span class="line">            if (uppr[i] &gt;= &#x27;a&#x27; and uppr[i] &lt;= &#x27;z&#x27;) &#123;</span><br><span class="line">                @compileError(&quot;`uppr` must be all uppercase&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var i = 0;</span><br><span class="line">    while (i &lt; uppr.len) : (i += 1) &#123;</span><br><span class="line">        const val = if (str[i] &gt;= &#x27;a&#x27; and str[i] &lt;= &#x27;z&#x27;)</span><br><span class="line">            str[i] - 32</span><br><span class="line">        else</span><br><span class="line">            str[i];</span><br><span class="line">        if (val != uppr[i]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    const x = insensitive_eql(&quot;Hello&quot;, &quot;hElLo&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的编译失败并产生以下输出。</p>
<p><strong>编译时代码消除</strong></p>
<p>Zig可以静态解析依赖于编译时已知值的控制流表达式。例如，你可以强制在while&#x2F;for循环上进行循环展开，并从if&#x2F;switch语句中省略分支。下面的程序要求用户输入一个数字，然后迭代地对其应用一系列操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const builtin = @import(&quot;builtin&quot;);</span><br><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const fmt = std.fmt;</span><br><span class="line">const io = std.io;</span><br><span class="line"></span><br><span class="line">const Op = enum &#123;</span><br><span class="line">    Sum,</span><br><span class="line">    Mul,</span><br><span class="line">    Sub,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn ask_user() !i64 &#123;</span><br><span class="line">    var buf: [10]u8 = undefined;</span><br><span class="line">    std.debug.warn(&quot;A number please: &quot;);</span><br><span class="line">    const user_input = try io.readLineSlice(buf[0..]);</span><br><span class="line">    return fmt.parseInt(i64, user_input, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn apply_ops(comptime operations: []const Op, num: i64) i64 &#123;</span><br><span class="line">    var acc: i64 = 0;</span><br><span class="line">    inline for (operations) |op| &#123;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            .Sum =&gt; acc +%= num,</span><br><span class="line">            .Mul =&gt; acc *%= num,</span><br><span class="line">            .Sub =&gt; acc -%= num,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    const user_num = try ask_user();</span><br><span class="line">    const ops = [4]Op&#123;.Sum, .Mul, .Sub, .Sub&#125;;</span><br><span class="line">    const x = apply_ops(ops[0..], user_num);</span><br><span class="line">    std.debug.warn(&quot;Result: &#123;&#125;\n&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码的有趣部分是for循环。<code>inline</code>关键字强制进行循环展开，循环体内有一个在编译时解析的switch语句。简而言之，在前面示例中对<code>apply_ops</code>的调用基本上解析为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var acc: i64 = 0;</span><br><span class="line">acc +%= num;</span><br><span class="line">acc *%= num;</span><br><span class="line">acc -%= num;</span><br><span class="line">acc -%= num;</span><br><span class="line">return acc;</span><br></pre></td></tr></table></figure>

<p>为了测试这是否确实发生了，将程序代码粘贴到<a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org</a>，选择Zig作为目标语言，然后选择大于0.4.0的Zig版本。Godbolt将编译代码并显示生成的汇编代码。右键单击代码行，会弹出一个上下文菜单，让你跳转到相应的汇编代码。你会注意到for循环和switch都没有对应的汇编代码。删除<code>inline</code>关键字，它们现在将会显示出来。</p>
<p><strong>泛型</strong></p>
<p><code>comptime</code>关键字指示在编译时解析的代码区域和值。在前面的示例中，我们使用它执行类似于模板元编程的操作，但它也可用于泛型编程，因为类型是有效的编译时值。</p>
<p><strong>泛型函数</strong></p>
<p>由于泛型编程与<code>comptime</code>参数相关，Zig没有传统的菱形括号语法。除此之外，泛型的基本用法与其他语言非常相似。以下代码是从标准库中提取的Zig的<code>mem.eql</code>实现，用于测试两个切片是否相等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// Compares two slices and returns whether they are equal.</span><br><span class="line">pub fn eql(comptime T: type, a: []const T, b: []const T) bool &#123;</span><br><span class="line">    if (a.len != b.len) return false;</span><br><span class="line">    for (a) |item, index| &#123;</span><br><span class="line">        if (b[index] != item) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，<code>T</code>是<code>type</code>类型的变量，后续的参数将其用作泛型参数。这样，就可以使用<code>mem.eql</code>与任何类型的切片。</p>
<p>还可以对<code>type</code>类型的值执行内省。在之前的示例中，我们从用户输入解析了一个整数，并请求了一个特定类型的整数。解析函数使用该信息从其泛型实现中省略了一些代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">return fmt.parseInt(i64, user_input, 10);</span><br><span class="line"></span><br><span class="line">// 这是`parseInt`的stdlib实现</span><br><span class="line">pub fn parseInt(comptime T: type, buf: []const u8, radix: u8) !T &#123;</span><br><span class="line">    if (!T.is_signed) return parseUnsigned(T, buf, radix);</span><br><span class="line">    if (buf.len == 0) return T(0);</span><br><span class="line">    if (buf[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">        return math.negate(try parseUnsigned(T, buf[1..], radix));</span><br><span class="line">    &#125; else if (buf[0] == &#x27;+&#x27;) &#123;</span><br><span class="line">        return parseUnsigned(T, buf[1..], radix);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return parseUnsigned(T, buf, radix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型结构体</strong></p>
<p>在描述如何创建泛型结构体之前，先简要介绍一下Zig中结构体的工作原理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line">const math = std.math;</span><br><span class="line">const assert = std.debug.assert;</span><br><span class="line"></span><br><span class="line">// 结构体定义不包括名称。</span><br><span class="line">// 将结构体分配给变量会为其赋予名称。</span><br><span class="line">const Point = struct &#123;</span><br><span class="line">    x: f64,</span><br><span class="line">    y: f64,</span><br><span class="line">    z: f64,</span><br><span class="line">    </span><br><span class="line">    // 结构体定义还可以包含命名空间函数。</span><br><span class="line">    // 当通过结构体实例调用带有Self参数的结构体函数时，</span><br><span class="line">    // 将自动填充第一个参数，就像方法一样。</span><br><span class="line">    const Self = @This();</span><br><span class="line">    pub fn distance(self: Self, p: Point) f64 &#123;</span><br><span class="line">        const x2 = math.pow(f64, self.x - p.x, 2);</span><br><span class="line">        const y2 = math.pow(f64, self.y - p.y, 2);</span><br><span class="line">        const z2 = math.pow(f64, self.z - p.z, 2);</span><br><span class="line">        return math.sqrt(x2 + y2 + z2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub fn main() !void &#123;</span><br><span class="line">    const p1 = Point&#123; .x = 0, .y = 2, .z = 8 &#125;;</span><br><span class="line">    const p2 = Point&#123; .x = 0, .y = 6, .z = 8 &#125;;</span><br><span class="line">    </span><br><span class="line">    assert(p1.distance(p2) == 4);</span><br><span class="line">    assert(Point.distance(p1, p2) == 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以深入讨论泛型结构体了。要创建泛型结构体，只需创建一个接受类型参数的函数，并在结构体定义中使用该参数。以下是从Zig文档中提取的示例。它是一个双向链接的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn LinkedList(comptime T: type) type &#123;</span><br><span class="line">    return struct &#123;</span><br><span class="line">        pub const Node = struct &#123;</span><br><span class="line">            prev: ?*Node = null,</span><br><span class="line">            next: ?*Node = null,</span><br><span class="line">            data: T,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        first: ?*Node = null,</span><br><span class="line">        last: ?*Node = null,</span><br><span class="line">        len: usize = 0,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回一个类型，这意味着它只能在编译时调用。它定义了两个结构体：</p>
<ul>
<li>主LinkedList结构体</li>
<li>命名空间内的Node结构体，嵌套在主结构体中</li>
</ul>
<p>就像结构体可以对函数进行命名空间分组一样，它们也可以对变量进行命名空间分组。在创建复合类型时，这对内省非常有用。以下是LinkedList如何与先前的Point结构体组合的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const PointList = LinkedList(Point);</span><br><span class="line">const p = Point&#123; .x = 0, .y = 2, .z = 8 &#125;;</span><br><span class="line"></span><br><span class="line">var my_list = PointList&#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 完整实现需要提供一个`append`方法。</span><br><span class="line">// 现在我们手动添加新节点。</span><br><span class="line">var node = PointList.Node&#123; .data = p &#125;;</span><br><span class="line">my_list.first = &amp;node;</span><br><span class="line">my_list.last = &amp;node;</span><br><span class="line">my_list.len = 1;</span><br></pre></td></tr></table></figure>

<p>Zig标准库中包含了一些完成度非常高的链表实现。</p>
<p><strong>编译时反射</strong></p>
<p>现在我们已经涵盖了所有基础知识，我们终于可以进入 Zig 元编程真正强大且有趣的内容。</p>
<p>在之前的例子中，我们已经看到了在 parseInt 中检查 T.is_signed 时的反射示例，但在这一节中，我想专注于更高级的反射用法。我将通过一个代码示例来介绍这个概念。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn make_couple_of(x: anytype) [2]@typeOf(x) &#123;</span><br><span class="line">    return [2]@typeOf(x) &#123;x, x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个几乎没什么用的函数可以接受任何值作为输入，并创建一个包含两个副本的数组。以下调用都是正确的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make_couple_of(5); // 创建 [2]comptime_int&#123;5, 5&#125;</span><br><span class="line">make_couple_of(i32(5)); // 创建 [2]i32&#123;5, 5&#125;</span><br><span class="line">make_couple_of(u8); // 创建 [2]type&#123;u8, u8&#125;</span><br><span class="line">make_couple_of(type); // 创建 [2]type&#123;type, type&#125;</span><br><span class="line">make_couple_of(make_couple_of(&quot;hi&quot;)); </span><br><span class="line">// 创建 [2][2][2]u8&#123;[2][2]u8&#123;&quot;hi&quot;,&quot;hi&quot;&#125;, [2][2]u8&#123;&quot;hi&quot;,&quot;hi&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>anytype 类型的参数非常强大，允许构建经过优化但仍然“动态”的函数。对于下一个例子，我将从标准库中提取一些代码，展示这种功能的更有用的用法。</p>
<p>以下代码是 math.sqrt 的实现，我们在先前的例子中用它来计算两点之间的欧几里德距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 为了更好的可读性，我将原始定义的一部分移动到单独的函数中。</span><br><span class="line">fn decide_return_type(comptime T: type) type &#123;</span><br><span class="line">    if (@typeId(T) == TypeId.Int) &#123;</span><br><span class="line">        return @IntType(false, T.bit_count / 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn sqrt(x: anytype) decide_return_type(@typeOf(x)) &#123;</span><br><span class="line">    const T = @typeOf(x);</span><br><span class="line">    switch (@typeId(T)) &#123;</span><br><span class="line">        TypeId.ComptimeFloat =&gt; return T(@sqrt(f64, x)),</span><br><span class="line">        TypeId.Float =&gt; return @sqrt(T, x),</span><br><span class="line">        TypeId.ComptimeInt =&gt; comptime &#123;</span><br><span class="line">            if (x &gt; maxInt(u128)) &#123;</span><br><span class="line">                @compileError(</span><br><span class="line">                    &quot;sqrt not implemented for &quot; ++ </span><br><span class="line">                    &quot;comptime_int greater than 128 bits&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (x &lt; 0) &#123;</span><br><span class="line">                @compileError(&quot;sqrt on negative number&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return T(sqrt_int(u128, x));</span><br><span class="line">        &#125;,</span><br><span class="line">        TypeId.Int =&gt; return sqrt_int(T, x),</span><br><span class="line">        else =&gt; @compileError(&quot;not implemented for &quot; ++ @typeName(T)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的返回类型有点奇怪。如果看一下 sqrt 的签名，它在应声明返回类型的地方调用了一个函数。在 Zig 中，这是允许的。原始代码实际上内联了一个 if 表达式，但出于更好的可读性，我将其移到了一个单独的函数中。</p>
<p>那么 sqrt 对其返回类型想要做什么呢？当我们传入整数值时，它应用了一个小优化。在这种情况下，函数将其返回类型声明为原始输入的比特大小的一半的无符号整数。这意味着，如果我们传入一个 i64 值，该函数将返回一个 u32 值。这主要考虑到平方根函数的作用。然后，声明的其余部分使用反射进一步类型化，并在适当的情况下报告编译时错误。</p>
<p>总的来说，编译时执行非常出色，特别是当语言非常具有表达力时。没有良好的编译时元编程，人们必须借助宏或代码生成，或者更糟糕地在运行时执行许多无用的工作。</p>
<p>如果你希望想看到Zig更酷的例子，请看一下 Andrew 本人的这篇博文。他使用了一些上述技术来为编译时已知的字符串列表生成完美的哈希函数。其结果是用户可以创建一个在 O(1) 时间内匹配字符串的开关。代码非常易于理解，他还提供了关于如何轻松、有趣和安全地使用所有其他次要功能的一些独特见解。</p>
<h2 id="Zig-元编程"><a href="#Zig-元编程" class="headerlink" title="Zig 元编程"></a>Zig 元编程</h2><p>Zig 的元编程由几个基本概念驱动：</p>
<ul>
<li>类型在编译时是有效值。</li>
<li>大多数运行时代码也可以在编译时工作。</li>
<li>结构体字段在编译时是鸭子类型（duck-typed）。</li>
<li>Zig 标准库提供了一些工具来进行编译时反射。</li>
<li>示例：多分派（multiple dispatch）。</li>
</ul>
<p><em><strong>Zig 示例代码</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const std = @import(&quot;std&quot;);</span><br><span class="line"></span><br><span class="line">fn foo(x: anytype) @TypeOf(x) &#123;</span><br><span class="line">    // 注意，这个 if 语句是在编译时执行的，而不是在运行时。</span><br><span class="line">    if (@TypeOf(x) == i64) &#123;</span><br><span class="line">        return x + 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 2 * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var x: i64 = 47;</span><br><span class="line">    var y: i32 = 47;</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;i64-foo: &#123;&#125;\n&quot;, .&#123;foo(x)&#125;);</span><br><span class="line">    std.debug.print(&quot;i32-foo: &#123;&#125;\n&quot;, .&#123;foo(y)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn Vec2Of(comptime T: type) type &#123;</span><br><span class="line">    return struct &#123;</span><br><span class="line">        x: T,</span><br><span class="line">        y: T</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const V2i64 = Vec2Of(i64);</span><br><span class="line">const V2f64 = Vec2Of(f64);</span><br><span class="line"></span><br><span class="line">pub fn main() void &#123;</span><br><span class="line">    var vi = V2i64&#123;.x = 47, .y = 47&#125;;</span><br><span class="line">    var vf = V2f64&#123;.x = 47.0, .y = 47.0&#125;;</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;i64 vector: &#123;&#125;\n&quot;, .&#123;vi&#125;);</span><br><span class="line">    std.debug.print(&quot;f64 vector: &#123;&#125;\n&quot;, .&#123;vf&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编译时执行"><a href="#编译时执行" class="headerlink" title="编译时执行"></a>编译时执行</h3><p>使用 <code>comptime</code> 关键字，可以强制在编译时执行代码块。在这个例子中，变量 <code>x</code> 和 <code>y</code> 是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test &quot;comptime blocks&quot; &#123;</span><br><span class="line">    var x = comptime fibonacci(10);</span><br><span class="line"></span><br><span class="line">    var y = comptime blk: &#123;</span><br><span class="line">        break :blk fibonacci(10);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>comptime_int和 comptime_float</strong></em></p>
<ul>
<li><code>comptime_int</code> 是一种特殊类型，在编译时没有大小限制，并具有任意精度。它可以转换为能够容纳其值的任何整数类型，也可以转换为浮点数。</li>
<li><code>comptime_float</code> 是 <code>f128</code> 类型，不能转换为整数，即使其值是一个整数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test &quot;comptime_int&quot; &#123;</span><br><span class="line">    const a = 12;</span><br><span class="line">    const b = a + 10;</span><br><span class="line"></span><br><span class="line">    const c: u4 = a;</span><br><span class="line">    const d: f32 = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编译时函数参数"><a href="#编译时函数参数" class="headerlink" title="编译时函数参数"></a>编译时函数参数</h3><p>Zig 的函数参数可以标记为 <code>comptime</code>，这意味着传入的值必须在编译时已知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn Matrix(</span><br><span class="line">    comptime T: type,</span><br><span class="line">    comptime width: comptime_int,</span><br><span class="line">    comptime height: comptime_int,</span><br><span class="line">) type &#123;</span><br><span class="line">    return [height][width]T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &quot;returning a type&quot; &#123;</span><br><span class="line">    expect(Matrix(f32, 4, 4) == [4][4]f32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>常见问题</strong></em></p>
<ul>
<li>在 <code>comptime</code> 执行中没有“同级”类型解析。</li>
<li>所有 <code>comptime</code> 值都不遵循常规的生命周期规则，具有“静态”生命周期（可以认为这些值是垃圾回收的）。</li>
<li>允许结构体字段使用 <code>anytype</code>，这将使结构体成为编译时类型。</li>
<li>可以使用 <code>comptime var</code> 来创建编译时闭包。</li>
</ul>
<hr>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在 Zig 中，类型是 <code>type</code> 类型的值，仅在编译时可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test &quot;branching on types&quot; &#123;</span><br><span class="line">    const a = 5;</span><br><span class="line">    const b: if (a &lt; 10) f32 else i32 = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用内建的 <code>@typeInfo</code> 来反射类型，这会返回一个标记联合（tagged union）。</p>
<hr>
<h3 id="泛型类型与反射"><a href="#泛型类型与反射" class="headerlink" title="泛型类型与反射"></a>泛型类型与反射</h3><p><em><strong>创建泛型类型</strong></em></p>
<p>使用 <code>@This</code> 获取最内层的结构体、联合或枚举的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fn Vec(</span><br><span class="line">    comptime count: comptime_int,</span><br><span class="line">    comptime T: type,</span><br><span class="line">) type &#123;</span><br><span class="line">    return struct &#123;</span><br><span class="line">        data: [count]T,</span><br><span class="line">        const Self = @This();</span><br><span class="line"></span><br><span class="line">        fn abs(self: Self) Self &#123;</span><br><span class="line">            var tmp = Self&#123; .data = undefined &#125;;</span><br><span class="line">            for (self.data) |elem, i| &#123;</span><br><span class="line">                tmp.data[i] = if (elem &lt; 0) -elem else elem;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fn init(data: [count]T) Self &#123;</span><br><span class="line">            return Self&#123; .data = data &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const eql = @import(&quot;std&quot;).mem.eql;</span><br><span class="line"></span><br><span class="line">test &quot;generic vector&quot; &#123;</span><br><span class="line">    const x = Vec(3, f32).init([_]f32&#123; 10, -10, 5 &#125;);</span><br><span class="line">    const y = x.abs();</span><br><span class="line">    expect(eql(f32, &amp;y.data, &amp;[_]f32&#123; 10, 10, 5 &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>动态绑定</strong></em></p>
<p>Zig 使用 <code>anytype</code> 绑定任意类型，实现基于调用类型的绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn makeCoupleOf(x: anytype) [2]@TypeOf(x) &#123;</span><br><span class="line">    return [2]@TypeOf(x)&#123; x, x &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过这些功能，Zig 的元编程提供了灵活而强大的编译时能力，允许在编译阶段实现类型检查、类型推断和代码生成等高级功能。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://kristoff.it/blog/what-is-zig-comptime/">https://kristoff.it/blog/what-is-zig-comptime/</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phase_distinction">https://en.wikipedia.org/wiki/Phase_distinction</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/846103/runtime-vs-compile-time">https://stackoverflow.com/questions/846103/runtime-vs-compile-time</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phase_distinction">https://en.wikipedia.org/wiki/Phase_distinction</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdaniu/p/15456650.html">https://www.cnblogs.com/cdaniu/p/15456650.html</a></li>
<li><a target="_blank" rel="noopener" href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/">https://ikrima.dev/dev-notes/zig/zig-metaprogramming/</a></li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Phase-distinction"><span class="toc-number">1.</span> <span class="toc-text">Phase distinction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">2.</span> <span class="toc-text">编译时与运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6"><span class="toc-number">2.1.</span> <span class="toc-text">编译时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">2.2.</span> <span class="toc-text">运行时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zig-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">Zig 元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">3.2.</span> <span class="toc-text">编译时执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">编译时函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.4.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">3.5.</span> <span class="toc-text">泛型类型与反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zoues.com/posts/ae025efe/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zoues.com/posts/ae025efe/&text=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zoues.com/posts/ae025efe/&is_video=false&description=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=超越C++：Ziglang 元编程一文打尽&body=Check out this article: https://zoues.com/posts/ae025efe/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zoues.com/posts/ae025efe/&title=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zoues.com/posts/ae025efe/&name=超越C++：Ziglang 元编程一文打尽&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zoues.com/posts/ae025efe/&t=超越C++：Ziglang 元编程一文打尽"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    zouyee
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zouyee">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
